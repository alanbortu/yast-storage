/*
 * Copyright (c) 2012 Novell, Inc.
 *
 * All Rights Reserved.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as published
 * by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
 * more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, contact Novell, Inc.
 *
 * To contact Novell about this file by physical or electronic mail, you may
 * find current contact information at www.novell.com.
 */

/**
 * File:        TabPanel.ycp
 * Package:     yast2-storage
 * Summary:	Expert Partitioner
 * Authors:     Arvin Schnell <aschnell@suse.de>
 *
 * The DumbTab widget must have id `tab.  The ids of the items of the DumbTab
 * widget must be made of symbols.
 */
{
    module "TabPanel";


    import "Event";


    map<symbol, map> data = nil;

    symbol current_item = nil;

    list<symbol> history = [];


    global const term empty_panel = `VBox(`VStretch(), `HStretch());


    void CallCreate()
    {
	map tmp = data[current_item]:nil;
	void(any) create_func = (void(any)) tmp[`create]:nil;
	if (create_func != nil)
	{
	    any user_data = tmp[`user_data]:nil;
	    create_func(user_data);
	}
    }

    void CallRefresh()
    {
	map tmp = data[current_item]:nil;
	void(any) refresh_func = (void(any)) tmp[`refresh]:nil;
	if (refresh_func != nil)
	{
	    any user_data = tmp[`user_data]:nil;
	    refresh_func(user_data);
	}
    }

    void CallHandle(map event)
    {
	map tmp = data[current_item]:nil;
	void(any, map) handle_func = (void(any, map)) tmp[`handle]:nil;
	if (handle_func != nil)
	{
	    any user_data = tmp[`user_data]:nil;
	    handle_func(user_data, event);
	}
    }

    void CallDestroy()
    {
	map tmp = data[current_item]:nil;
	void(any) destroy_func = (void(any)) tmp[`destroy]:nil;
	if (destroy_func != nil)
	{
	    any user_data = tmp[`user_data]:nil;
	    destroy_func(user_data);
	}
    }


    void AddToHistory()
    {
	history = filter(symbol s, history, { return s != current_item; });
	history = prepend(history, current_item);
    }


    /**
     * When calling this function the DumbTab widget must already exist.
     *
     * The tab with symbol fallback will be selected if no other tab is found
     * in the tab history.
     */
    global void Init(map<symbol, map> d, symbol fallback)
    {
	data = d;

	list<symbol> items = maplist(symbol s, map m, data, { return s; });
	current_item = find(symbol s, history, { return contains(items, s); });

	if (current_item == nil && contains(items, fallback))
	    current_item = fallback;

	if (current_item != nil)
	    UI::ChangeWidget(`tab, `CurrentItem, current_item);

	current_item = (symbol) UI::QueryWidget(`tab, `CurrentItem);

	CallCreate();
    }

    global void Create()
    {
	CallCreate();
    }

    global void Refresh()
    {
	CallRefresh();
    }

    global void Handle(map event)
    {
	symbol widget = Event::IsMenu(event);

	if (widget != nil && haskey(data, widget))
	{
	    if (widget != current_item)
	    {
		CallDestroy();
		current_item = widget;
		AddToHistory();
		CallCreate();
	    }
	}
	else
	{
	    CallHandle(event);
	}
    }

    global void Destroy()
    {
	CallDestroy();
    }
}
