/*
 * Copyright (c) 2012 Novell, Inc.
 *
 * All Rights Reserved.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as published
 * by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
 * more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, contact Novell, Inc.
 *
 * To contact Novell about this file by physical or electronic mail, you may
 * find current contact information at www.novell.com.
 */

/**
 * File:	ep-loop-dialogs.ycp
 * Package:	yast2-storage
 * Summary:	Expert Partitioner
 * Authors:	Arvin Schnell <aschnell@suse.de>
 *
 * This file must only be included in other Expert Partitioner files ("ep-*.ycp").
 */
{
    textdomain "storage";


    string MiniWorkflowStepLoopNameSizeHelptext()
    {
	// TODO

	// helptext
	string helptext = _("
<p><b>Path Name of Loop File:</b><br>This must be an absolute path to the file
containing the data for the encrypted loop device to set up.</p>
");

	// helptext
	helptext = helptext + _("
<p><b>Create Loop File:</b><br>If this is checked, the file will be created
with the size given in the next field. <b>NOTE:</b> If the file already
exists, all data in it is lost.</p>
");

	// helptext
	helptext = helptext + _("
<p><b>Size:</b><br>This is the size of the loop file.  The file system
created in the encrypted loop device will have this size.</p>
");

	// helptext
	helptext = helptext + _("
<p><b>NOTE:</b> During installation, YaST cannot carry out consistency
checks of file size and path names because the file system is not
accessible. It will be created at the end of the installation. Be
careful when providing the size and path name.</p>
");

	return helptext;
    }


    symbol MiniWorkflowStepLoopNameSize(map<string, any> &data)
    {
	y2milestone("MiniWorkflowStepLoopNameSize data:%1", data);

	integer min_size_k = 1024;
	integer size_k = data["size_k"]:(50 * 1024);
	string fpath = data["fpath"]:"";
	boolean create_file = data["create_file"]:false;

	term contents = `HVSquash(
	    `VBox(
		// input field label
		`Left(`MinWidth(25, `InputField(`id(`fpath), `opt(`hstretch), _("Path Name of Loop File"), fpath))),
		// push button text
		Mode::normal() ? `Left(`PushButton(`id(`browse), _("Browse..."))) : `Empty(),
		`VSpacing(0.75),
		// check box text
		`LeftCheckBoxWithAttachment(`id(`create_file), `opt(`notify), _("Create Loop File"),
					    // input field label
					    `MinWidth(15, `InputField(`id(`size), `opt(`shrinkable), _("Size"),
								      Storage::KByteToHumanString(size_k))))
		)
	    );

	MiniWorkflow::SetContents(Greasemonkey::Transform(contents), MiniWorkflowStepLoopNameSizeHelptext());
	MiniWorkflow::SetLastStep(false);

	UI::ChangeWidget(`id(`create_file), `Value, create_file);
	UI::ChangeWidget(`id(`size), `Enabled, create_file);

	symbol widget = nil;

	repeat
	{
	    widget = MiniWorkflow::UserInput();

	    switch (widget)
	    {
		case `browse:
		    string tmp = UI::AskForExistingFile("/", "*", "");
		    if (tmp != nil)
			fpath = tmp;
		    UI::ChangeWidget(`id(`fpath), `Value, fpath);

		    if (Mode::normal())
		    {
			integer s = (integer) SCR::Read(.target.size, fpath);
			create_file = s < 0;
			UI::ChangeWidget(`id(`create_file), `Value, create_file);
		    }

		    break;

		case `create_file:
		    create_file = (boolean) UI::QueryWidget(`id(`create_file), `Value);
		    UI::ChangeWidget(`id(`size), `Enabled, create_file);
		    break;

		case `next:
		    fpath = (string) UI::QueryWidget(`id(`fpath), `Value);

		    if (fpath == "" || substring(fpath, 0, 1) != "/")
		    {
			// popup text
			Popup::Error(sformat(_("The file name \"%1\" is invalid.
Use an absolute path name.
"), fpath));
			widget = `again;
			continue;
		    }

		    if (create_file)
		    {
			string tmp = (string) UI::QueryWidget(`id(`size), `Value);
			if (!Storage::HumanStringToKByteWithRangeCheck(tmp, size_k, min_size_k, nil))
			{
			    // error popup, %1 is replaced by size
			    Popup::Error(sformat(_("The size entered is invalid. Enter a size of at least %1."),
						 Storage::KByteToHumanString(min_size_k)));
			    widget = `again;
			    continue;
			}
		    }
		    else
		    {
			integer s = (integer) SCR::Read(.target.size, fpath);
			y2milestone("loop file size:%1", s);

			if (Mode::normal())
			{
			    if (s < 0)
			    {
				// popup text
				Popup::Error( sformat(_("The file name \"%1\" does not exist
and the flag for create is off. Either use an existing file or activate
the create flag."), fpath));
				widget = `again;
				continue;
			    }
			    else
			    {
				size_k = s / 1024;
			    }
			}
		    }

		    break;
	    }
	}
	until (widget == `abort || widget == `back || widget == `next);

	if (widget == `next)
	{
	    data["fpath"] = fpath;
	    data["create_file"] = create_file;
	    data["size_k"] = size_k;
	}

	y2milestone("MiniWorkflowStepLoopNameSize data:%1 ret:%2", data, widget);

	return widget;
    }


    boolean DlgCreateLoop(map<string, any> &data)
    {
	map<string, any> aliases = $[
	    "NameSize"    : ``(MiniWorkflowStepLoopNameSize(data)),
	    "FormatMount" : ``(MiniWorkflowStepFormatMount(data)),
	    "Password"	  : ``(MiniWorkflowStepPassword(data))
	];

	map<string, any> sequence = $[
	    "NameSize"    : $[ `next : "FormatMount" ],
	    "FormatMount" : $[ `next : "Password",
			       `finish : `finish ],
	    "Password"    : $[ `finish : `finish ]
	];

	// dialog title
	string title = _("Add Crypt File");

	symbol widget = MiniWorkflow::Run(title, StorageIcons::loop_icon, aliases, sequence, "NameSize");

	return widget == `finish;
    }


    boolean DlgEditLoop(map<string, any> &data)
    {
	string device = data["device"]:"error";

	map<string, any> aliases = $[
	    "FormatMount" : ``(MiniWorkflowStepFormatMount(data)),
	    "Password"	  : ``(MiniWorkflowStepPassword(data))
	];

	map<string, any> sequence = $[
	    "FormatMount" : $[ `next : "Password",
			       `finish : `finish ],
	    "Password"    : $[ `finish : `finish ]
	];

	// dialog title
	string title = sformat(_("Edit Crypt File %1"), device);

	symbol widget = MiniWorkflow::Run(title, StorageIcons::loop_icon, aliases, sequence, "FormatMount");

	return widget == `finish;
    }
}
