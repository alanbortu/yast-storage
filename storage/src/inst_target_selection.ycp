/*
 * Copyright (c) 2012 Novell, Inc.
 *
 * All Rights Reserved.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as published
 * by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
 * more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, contact Novell, Inc.
 *
 * To contact Novell about this file by physical or electronic mail, you may
 * find current contact information at www.novell.com.
 */

/**
 * Module: 		inst_target_selection.ycp
 *
 * Authors: 		Klaus Kaempf (kkaempf@suse.de)
 *
 * Purpose: 		This module selects the harddisk(s) for installation.
 *			-Harddisk recognition
 *			-Selecting the harddisk for the installation by
 *			 the user ( if possible harddisks > 1 ).
 *			-Write selected harddisk(s) with SetPartDisk into 
 *                       Storage
 *                      "target_is":<devicename> (key to "targets" map)
 *			if custom, set "target_is":"CUSTOM"
 *
 * $Id$
 */
{
    textdomain "storage";

    import "Arch";
    import "Mode";
    import "Stage";
    import "Popup";
    import "Partitions";
    import "Wizard";
    import "Storage";
    import "StorageFields";

    include "partitioning/custom_part_helptexts.ycp";

    //////////////////////////////////////////////////////
    // look what inst_part_propose has said:

    y2milestone( "GetPartMode %1", Storage::GetPartMode() );

    if( Storage::GetPartMode() == "PROP_MODIFY" )
        return Storage::GetExitKey();


    //////////////////////////////////////////////////////
    // if we get here in update mode it's a BUG

    if( Mode::update () ) {
	return `cancel;
    }

/////////////////////////////////////////////////////////////////////
// MAIN:
/////////////////////////////////////////////////////////////////////

    map<string,map> targetMap = Storage::GetTargetMap();

    // Check the partition table for correctness
  
    term contents = `Dummy();

    boolean custom_val = (Storage::GetPartMode() == "CUSTOM");
    y2milestone( "custom_val %1", custom_val );

    if (!isempty(targetMap))
	{
	// loop over targetMap and build radio buttons for selection
	// dont use foreach here since we need a counter (as a shortcut)
	// anyway

	map<string, map> usable_target_map = filter(string d, map e, targetMap, {
	    return Storage::IsPartitionable(e) && 
		!contains([ `UB_DMRAID, `UB_DMMULTIPATH, `UB_MDPART ], e["used_by_type"]:`UB_NONE);
	});

	integer dskcnt = size(usable_target_map);
	y2milestone("dskcnt:%1", dskcnt);

	term buttonbox = `VBox();

	if (dskcnt >= 10)
	{
	    list<term> disklist = [];
	    foreach(string tname, map tdata, usable_target_map, {
		string tlinename = tdata["proposal_name"]:tdata["device"]:"?";
		string tline = sformat("%1", tlinename);
		disklist = add(disklist, `item(`id(tname), tline));
	    });
	    buttonbox = add(buttonbox, `MinWidth(40, `SelectionBox(`id(`disklist), `opt(`notify),
								   _("Available &Disks"), disklist)));
	}
	else
	{
	    integer i = 1;
	    foreach(string tname, map tdata, usable_target_map, {
		string tlinename = tdata["proposal_name"]:tdata["device"]:"?";
		string tline = sformat("&%1:    %2", i, tlinename);
		boolean sel = Storage::GetPartDisk() == tname && !custom_val;
		buttonbox = add(buttonbox, `Left(`RadioButton(`id(tname), tline, sel)));
		i = i + 1;
	    });
	}

	buttonbox = add(buttonbox, `VSpacing(0.8) );
	// Check box for expert partitioning mode rather than
	// just selecting one of the hard disks and use
	// a standard partitioning scheme
	buttonbox = 
	    add(buttonbox, `Left(`RadioButton(`id("CUSTOM"), `opt(`notify),
	                         // label text
				 _("&Custom Partitioning (for experts)"),
				 custom_val )));
    
	// This dialog selects the target disk for the installation.
	// Below this label, all targets are listed that can be used as 
	// installation target

	                   // heading text
	contents = `Frame( _("Hard Disk"),
			   `RadioButtonGroup(`id(`options),
					     `VBox( `VSpacing(0.4),
						    `HSquash(buttonbox),
						    `VSpacing(0.4)
						  )
					    )
			 );
	}
    else 
	{
	y2milestone("NO targetMap");
	// normally the target is located on hard disks. Here no hard disks 
	// can be found. YaST2 cannot install. Update CD might have newer drivers.
	contents = `Label (_("No disks found. Try using the update CD, if available, for installation."));
	}


    // There are several hard disks found. Linux is completely installed on
    // one hard disk - this selection is done here
    // "Preparing Hard Disk" is the description of the dialog what to 
    // do while the following locale is the help description
    // help part 1 of 3
    string helptext = _("<p>
All hard disks automatically detected on your system
are shown here. Select the hard disk on which to install &product;.
</p>
");
    // help part 2 of 3
    helptext = helptext + _("<p>
You may select later which part of the disk is used for &product;.
</p>
");
    // help part 3 of 3
    helptext = helptext + _("
<p>
The <b>Custom Partitioning</b> option for experts allows full
control over partitioning the hard disks and assigning
partitions to mount points when installing &product;.
</p>
");


    // first step of hd prepare, select a single disk or "expert" partitioning
    Wizard::SetContents( _("Preparing Hard Disk"),
			 contents, helptext, (boolean)WFM::Args(0), 
			 (boolean)WFM::Args(1));
    if ( Stage::initial () )
	Wizard::SetTitleIcon( "yast-partitioning" );
    
    if( UI::WidgetExists( `id(`disklist)) && !custom_val )
	{
	UI::ChangeWidget( `id(`disklist), `CurrentItem, Storage::GetPartDisk());
	}
    any ret = nil;

    // Event handling

    any option = nil;

    symbol sym = `none;

    repeat
	{
	ret = Wizard::UserInput();


	y2milestone( "ret %1", ret );

	if( is(ret, string) && (string)ret == "CUSTOM" )
	    {
	    //UI::ChangeWidget( `id(`disklist), `CurrentItem, "" );
	    custom_val = !custom_val;
	    }

	sym = `none;
	if( is( ret, symbol))
	    {
	    sym = (symbol)ret;
	    }

	if( sym == `disklist )
	    {
	    y2milestone( "set CUSTOM false" );
	    custom_val = false;
	    UI::ChangeWidget( `id("CUSTOM"), `Value, false );
	    }

	if( sym == `abort && Popup::ReallyAbort(true) )
	    return `abort;
	
	if( sym == `next ) 
	    {
	    option = UI::QueryWidget(`id(`options), `CurrentButton);
	    y2milestone( "option %1", option );
	    if( option == nil ) 
		{
		string disk = "";
		if( UI::WidgetExists( `id(`disklist)) && !custom_val )
		    {
		    disk = (string)UI::QueryWidget(`id(`disklist), `CurrentItem);
		    if( disk == nil ) disk="";
		    }
		if( search( disk, "/dev/" ) == 0 )
		    option = disk;
		else
		    {
		    // there is a selection from which one option must be 
		    // chosen - at the moment no option is chosen
		    Popup::Message(_("Select one of the options to continue."));
		    sym = `again;
		    }
		}
	    if( option!=nil && substring((string)option,0,5) == "/dev/" )
		{
		map<string, any> disk_map = (map<string, any>) targetMap[(string) option]:$[];
		if( disk_map["readonly"]:false )
		    {
		    Popup::Error(Partitions::RdonlyText(disk_map, true));
		    sym = `again;
		    }
		else if( Storage::IsUsedBy(targetMap[(string)option]:$[]))
		    {
		    string s = StorageFields::UsedByString(targetMap[(string)option,"used_by",0]:$[] );
		    Popup::Error( sformat(_("Disk %1 is in use by %2"), (string)option, s ));
		    sym = `again;
		    }
		else
		    {
		    Storage::SetPartMode( "USE_DISK" );
		    y2milestone( "PartMode Disk old %1 name %2", 
				 Storage::GetPartDisk(), option );
		    if( Storage::CheckBackupState("disk"))
			Storage::DisposeTargetBackup("disk");
		    Storage::CreateTargetBackup("disk");
		    Storage::ResetOndiskTarget();
		    Storage::SetPartDisk( (string)option );
		    Storage::SetCustomDisplay( false );
		    Storage::SetDoResize( "NO" );
		    }
		} // if (option)
	    else if( option!=nil )
		{
		y2milestone( "PartMode %1 %2", Storage::GetPartMode(), 
			     Storage::GetPartDisk() );
		Storage::CreateTargetBackup("disk");
		if( Storage::GetPartMode() != "USE_DISK" )
		    {
		    Storage::ResetOndiskTarget();
		    }
		Storage::SetCustomDisplay( true );
		}

	    } // if (ret == next)
	
	} until ( sym == `next || sym == `back || sym == `cancel );
    if( sym != `next )
	{
	Storage::SetPartMode( "SUGGESTION" );
	Storage::SetPartProposalActive( true );
	}
    Storage::SaveExitKey( sym );
    return sym;
}
