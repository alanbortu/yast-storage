/**
 * Module:		inst_prepdisk.ycp
 *
 * Authors:		Mathias Kettner (kettner@suse.de) (initial)
 *			Stefan Schubert (schubi@suse.de)
 *			Klaus Kaempf (kkaempf@suse.de)
 *
 * Purpose:
 * Displays a progress bar showing progress of disk preparation.
 * The user has the opportunity to cancel the installation. The
 * disks are partitioned. Swap is created and used. File systems
 * are created for the new partitions. Mount points are created
 * and mounted for the targets / and /boot.
 *
 *
 * SCR:	Write(.disk + scrpath + .partitions, targetpartitions)
 *	Execute (.target.mkdir, [ <mountpoint>, 0755] )
 *	Execute (.target.mount, [<device>, <mountpoint>] )
 *
 *
 * possible return values: `back, `abort `next

 *
 * $Id$
 */

 // TODO: - check for errors on non i386
 //       - lvm?

{
  textdomain "storage";
  import "Arch";
  import "Initrd";
  import "Installation";
  import "Mode";
  import "Wizard";
  import "Storage";
  import "FileSystems";
  import "Hotplug";
  import "Partitions";
  import "Report";  
  import "Label";  

  include "partitioning/partition_defines.ycp";
  include "partitioning/target_modify.ycp";
  include "partitioning/raid_lib.ycp";

  //integer loop_dev_nb	   = 0;
  boolean crypt_ok         = true;
  boolean reboot_necessary = false;

  map     modify_targets        = Storage::GetModifyTargets();
  boolean test_mode		= Mode::test;
  boolean immediate_prepdisk    = Storage::immediate_prepdisk;
  boolean this_is_for_real	= ! test_mode;

  SCR::Write( .target.ycp, Storage::SaveDumpPath("targetMap_ps"), 
              Storage::GetTargetMap() );

  // differ between installation and running system
  boolean installation		= Mode::initial;
  list    remountPartitions     = [];

  // we need to deactivate these in case of error
  list activatedswaps = [];
  list activatedLoopDevices = [];


    //switch swap off
    define doswapoff(list activatedswaps)
    ``{
	foreach (`swapdev,activatedswaps,
	``{
	   if (0 != SCR::Execute (.target.bash, "/sbin/swapoff "+swapdev))
	   {
	       Report::Error(sformat(
		  // popup text, %1 is replaced by partition name e.g. /dev/hda1
		  _("Deactivating swap device %1 failed. You may have to reboot."),
		  swapdev));
	   }
	 });
	 return;
    };

//detach loop devices
define losetup_d(list activatedLoopDevices)
    ``{
    foreach (`loopdev, activatedLoopDevices,
    ``{
       y2debug("detaching loop device %1",loopdev);
       if (0 != SCR::Execute (.target.bash, "/sbin/losetup -d "+loopdev))
       {
	 y2warning("detaching loop device %1 failed",loopdev);
	 Report::Warning (sformat(
	      // popup text, %1 is replaced by loop name e.g. /dev/loop0
	      _("Detaching loop device %1 failed. Nothing serious, but you may run out of loop devices."),
	      loopdev));
       }
     });
     return;
    };

    //backup target map, reread it from harddisk and restore mountpoints etc.
define restoretargetmap()
    ``{
    //bakup information a new map
    map baktargets=$[];
    foreach (`tdevice,`target, Storage::GetTargetMap(),
	``{
	list partitions = target["partitions"]:[];
	//map for partitions, referenced by number
	map bakpartitionmap=$[];
	foreach (`pentry, partitions,
	    ``{
	    //no backup for partitions marked for delete
	    if (pentry["delete"]:false)
		return;

	    integer fsid	= pentry["fsid"]:0;
	    string  mount	= pentry["mount"]:"";
	    boolean crypt_fs	= pentry["loop_fs"]:false;
	    string  crypt_key   = pentry["crypt_key"]:"";
	    string  cypher      = pentry["crypt"]:"";
	    symbol  used_fs 	= pentry["used_fs"]:`unknown;
	    boolean format	= pentry["format"]:false;
	    list region	= pentry["region"]:[];
	    map bakpentry=$[];
	    change(bakpentry,"fsid",fsid);
	    change(bakpentry,"mount",mount);
	    change(bakpentry,"loop_fs",crypt_fs);
	    change(bakpentry,"crypt_key",crypt_key);
	    change(bakpentry,"used_fs",used_fs);
	    change(bakpentry,"crypt",cypher);
	    change(bakpentry,"format",format);
	    change(bakpentry,"region",region);
	    change(bakpartitionmap,pentry["nr"]:0,bakpentry);
	    });
	change(baktargets,tdevice,$["partitions":bakpartitionmap]);
	});
//      SCR::Write(.target.ycp, "/tmp/targetMap_orig", targets );
//      SCR::Write(.target.ycp, "/tmp/targetMap_backup", baktargets );
    map targets = Storage::ReReadTargetMap();
//      SCR::Write(.target.ycp, "/tmp/targetMap_reread", targets );

    //see if theres info available in backupmap
    foreach (`tdevice,`target, targets,
	``{
	map bakpartitionmap = baktargets[tdevice, "partitions"]:$[];
	list partitions = target["partitions"]:[];

	list newpartitions = [];
	boolean usebackup=true;
	foreach (`pentry, partitions,
	    ``{
	    usebackup = true;

	    //do we have data for that partition?
	    map bakpentry=lookup(bakpartitionmap,pentry["nr"]:0,$[]);

	    // partition is (no longer) available
	    if( bakpentry == $[])
		usebackup=false;

	    integer fsid = lookup (pentry, "fsid",0);
	    integer bakfsid = lookup (bakpentry, "fsid",0);

	    //file system id has changed, better leave it
	    if( usebackup && fsid!=bakfsid)
		{
		y2warning("fsid changed, no bakup for %1%2",tdevice,nr);
		usebackup=false;
		}

	    list region = lookup (pentry, "region", []);
	    list bakregion = lookup (bakpentry, "region", []);

	    // different region is dangerous
	    if( usebackup && region != bakregion )
		{
		y2warning("region changed, no bakup for %1%2",tdevice,nr);
		usebackup=false;
		}

	    string  mount	= pentry["mount"]:"";
	    boolean crypt_fs	= pentry["loop_fs"]:false;
	    string  crypt_key   = pentry["crypt_key"]:"";
	    string  cypher      = pentry["crypt"]:"";
	    symbol  used_fs	= pentry["used_fs"]:`unknown;
	    boolean format	= pentry["format"]:false;

	    if( usebackup==true)
		{
		string  bakmount     = bakpentry["mount"]:"";
		boolean bakcrypt_fs  = bakpentry["loop_fs"]:false;
		string  bakcrypt_key = bakpentry["crypt_key"]:"";
		string  bakcypher    = bakpentry["crypt"]:"";
		symbol  bakused_fs   = bakpentry["used_fs"]:`unknown;
		boolean bakformat    = bakpentry["format"]:false;

		if (mount=="" && bakmount !="" )
		    change(pentry,"mount",bakmount);
		if (crypt_fs==false && bakcrypt_fs !=false )
		    change(pentry,"loop_fs",bakcrypt_fs);
		if (crypt_key=="" && bakcrypt_key !="" )
		    change(pentry,"crypt_key",bakcrypt_key);
		if (cypher=="" && bakcypher !="" )
		    change(pentry,"crypt",bakcypher);
		if (used_fs==`unknown && bakused_fs !=`unknown )
		    change(pentry,"used_fs",bakused_fs);
		if (format==false && bakformat !=false )
		    change(pentry,"format",bakformat);
		}

	    newpartitions = add (newpartitions, pentry);
	    });
	targets[tdevice] = target;
	targets[tdevice,"partitions"] = newpartitions;
	});
    Storage::SetTargetMap( targets );
    };

// Define macro that creates a dialog with progressbar
global define MakefsDialog()
    ``{
    // html-format
    // advise the user to wait for completion
    // part 1 of 2
    string helptext = _("<p>
Please wait while your hard disk is prepared for installation...
<br></p>");
    // rich-text format help text part 2 of 2
    helptext = helptext + _("\
<p>
Depending on the size of your hard disk and your processor speed, this action
might take some time.  5 minutes are not unusual for disks larger than 4 GB.
Often, the progress meter doesn't show a linear progress; even if it looks
slow near the end (\"95 %\"), please be patient: the formatting tool has to
perform various checks. <br></p>");
    // hard disk will be made ready for installing Linux
    Wizard::SetContents(_("Preparing Your Hard Disk"),
			`ProgressBar(`id(`progress), " ", 100),
			helptext, false, false);
    };

define boolean HandleFormatPartition( map partition )
    ``{
    boolean format = partition["format"]:false;
    boolean crypt_fs = partition["loop_fs"]:false &&
                       partition["crypt"]:""!="none";
    string mount = partition["mount"]:"";
    string device = "";
    boolean retry = false;
    boolean cancel = false;

    //retry loop
    do
	{
	device = partition["device"]:"";
	retry = false;

	y2milestone( "dev:%1 loop_dev %2", device, partition["loop_dev"]:"" );

	if( size(partition["loop_dev"]:"")>0 )
	    {
	    SCR::Execute( .target.bash, 
			  "/sbin/losetup -d " + partition["loop_dev"]:"" );
	    }
	///////////////////////////////
	// CRYPT ?
	if( crypt_fs || partition["type"]:`none==`loop )
	    {
	    cancel = !Storage::SetCryptLoop( partition );
	    if( !cancel )
		{
		if( !format && !partition["delete"]:false )
		    {
		    partition = FileSystems::GetFsysInfos( partition );
		    map tg = Storage::GetTargetMap();
		    tg = Storage::SetPartition( tg, partition );
		    Storage::SetTargetMap( tg );
		    y2milestone( "loop part info %1", partition );
		    }
		if( haskey( partition, "loop_dev" ))
		    {
		    device = partition["loop_dev"]:"";
		    activatedLoopDevices = add(activatedLoopDevices, device);
		    }
		}
	    }
	// announce partition to be formatted
	if( !cancel && format && mount != "swap")
	    {
	    string tmp = device;
	    if( partition["type"]:`none==`loop )
		{
		tmp = partition["fpath"]:"";
		}
	    string label = "";
	    if( size(mount)>0 )
		{
		// label text, example: "Formatting /dev/hda1 for /usr"
		label = sformat(_("Formatting %1 as %2"), tmp, mount);
		}
	    else
		{
		// label text, example: "Formatting /dev/hda1"
		label = sformat(_("Formatting %1"), tmp );
		}

	    UI::ChangeWidget(`id(`progress), `Label, label );
	    symbol ret = `ok;

	    if( this_is_for_real )
		{
		// Format partitions

		symbol used_fs = partition["used_fs"]:`unknown;

		y2milestone( "mkfs: used %1, crypt %2 ", used_fs, crypt_fs);

		list options = [];
		if( size(partition["format_opt"]:"")>0 )
		    {
		    list t = splitstring( partition["format_opt"]:"", " " );
		    options = merge( options, filter( `e, t, ``(size(e)>0)));
		    }
		if( partition["format"]:false && 
		    partition["fs_options"]:$[] != $[] )
		    {
		    options = convertFsOptionMapInList( partition );
		    }

		if( used_fs == `ext3 )
		    {
		    // add -j to options
		    options = add( options , "-j" );
		    }
		y2milestone( "Format options %1", options );

		string makefs_type = 
		    FileSystems::GetMakeFsType( used_fs, "ext2");

		DumpPartitionStart( device, crypt_fs );
		if( used_fs != `hfs )
		    {
		    ret = WFM::CallModule( "makefs", 
		                           ["UpdateProgressBar", makefs_type, 
					    device, options /*[ ]*/ ]);
		    y2milestone( "format ret = %1", ret );
		    }
		else
		    {
		    string cmd = sformat( "/usr/bin/hformat %1", device );
		    y2milestone( "cmd %1", cmd );
		    SCR::Execute (.target.bash, cmd );
		    ret = `ok;
		    }
		if( ret == `ok )
		    {
		    FileSystems::DoChangedFsDefaults( partition );
		    map info = FileSystems::GetUuidVolume( device, used_fs );
		    map tg = Storage::GetTargetMap();
		    if( size(info["uuid"]:"")>0 )
			{
			tg = Storage::SetPartitionData( tg, 
							partition["device"]:"",
							"uuid", 
							info["uuid"]:"" );
			}
		    tg = Storage::SetPartitionData( tg, partition["device"]:"",
						    "detected_fs", used_fs );
		    tg = Storage::DelPartitionData( tg, partition["device"]:"",
						    "create" );
		    Storage::SetTargetMap( tg );
		    }
		}
	    else
		{
		// Fake formatting
		integer progress = 0;

		while ( progress < 100 )
		    {
		    UI::UpdateProgressBar ( progress );
		    sleep ( 300 ); // millisec
		    progress = progress + 3;
		    }
		}

	    if( ret == `cancel )
		{
		cancel = true;
		}
	    else if( ret != `ok )
		{
		// report any formatting errors
		ret = Popup::AnyQuestion3(Popup::NoHeadline(),
			// popup text, %1 replaced by partition name e.g. /dev/hda1
			sformat(_("Could not format partition %1.
You can continue if you know what you are doing, but, to prevent damage to
your file systems, it is safer to cancel and reboot."),
			    device ),
			Label::ContinueButton(), Label::AbortButton(), 
			Label::RetryButton(), `focus_no);
		if (ret == `no)
		    {
		    cancel=true;
		    }
		else if (ret==`retry)
		    {
		    retry=true;
		    }
		}
	    }
	} 
    while( retry );
    string label = partition["label"]:"";
    if( !cancel && size(label)>0 &&
	(format || 
	 (haskey(partition,"ori_label") && partition["ori_label"]:""!=label)))
	{
	y2milestone( "set volume label %1", label );
	if( !FileSystems::SetVolumeLabel( device, partition ))
	    {
	    Popup::Error(
		// popup text, %1 replaced by arbitrary name
		// %2 replaced by partition name e.g. /dev/hda1
		sformat(_("Error setting the volume label on device %2 to %1"),
			partition["label"]:"", device ));
	    }
	else
	    {
	    map tg = Storage::GetTargetMap();
	    tg = Storage::DelPartitionData( tg, device, "ori_label" );
	    Storage::SetTargetMap( tg );
	    }
	}
    y2milestone( "device %1 ret %2", partition["device"]:"", cancel );
    return( !cancel );
    };

define void DumpPartitionStart( string device, boolean crypt_fs )
    ``{
    string dd_sblocks = "";
    string idev = crypt_fs ? "/dev/urandom" : "/dev/zero";
    dd_sblocks = sformat( "/bin/dd if=%1 of=%2 bs=1024 count=50", idev, 
                          device );
    if( !Arch::sparc || crypt_fs )
	{
	y2milestone( "dd_sblocks=%1", dd_sblocks );
	SCR::Execute (.target.bash, dd_sblocks );
	}
    }

define map DetermineMountPoints(string disk, map target, map mp )
    ``{
    foreach (`part, target["partitions"]:[],
	``{
	string device = part["device"]:0;
	string mount = part["mount"]:"";
	boolean running_system_create_part = 
	    !installation && part["create"]:false;
	boolean running_system_remount_part = 
	    !installation && contains( remountPartitions, device );

	if( installation || running_system_create_part || 
	    running_system_remount_part )
	    {
	    if( mount != "" && mount != "swap" && !part["delete"]:false &&
	        !part["noauto"]:false &&
		part["fsid"]:0 != 7 )         // ntfs is read-only anyway.
		{
		symbol used_fs = part["used_fs"]:`unknown;
		if( part["loop_fs"]:false )
		    device = part["loop_dev"]:"";
		mp[mount] = [device, used_fs, disk];
		}
	    }
	});  // foreach (partition)
    y2milestone( "disk %1 mp %2", disk, mp );
    return( mp );
    };

define boolean DoMountList( map mp )
    ``{
    boolean retry = false;
    boolean cancel = false;
    string source_partition = SCR::Read (.etc.install_inf.Partition);
    if (source_partition == nil) source_partition = "";

    y2milestone( "mp %1", mp );
    foreach( `mount, `mountData, mp,
	``{
	if (cancel)
	    {
	    return;
	    }
	symbol used_fs = select (mountData, 1, `ext2);

	/////////////////////////////////////////////
	// load filesystem modules
	FileSystems::LoadModule( used_fs );

	if( mount == "/" )
	    {
	    foreach( `modname, FileSystems::GetNeededModules(used_fs),
		``{
		Initrd::AddModule (modname, "");
		});
	    }

	// eg /mnt + /usr
	if( Installation::destdir != "/" )
	    {
	    mount = Installation::destdir + mount;
	    }

	do
	    {
	    retry = false;

	    // partition has a mount point
	    y2milestone("mkdir %1", mount );
	    SCR::Execute( .target.mkdir, mount, 0755 );
	    string device = select( mountData, 0, "/dev/null" );

	    y2milestone( "mountcmd: %1 target:%2 [-t <%3>]", device, mount, 
	                 used_fs );

	    string mount_type = FileSystems::GetMountString( used_fs, "");

	    if (mount_type != "")
		{
		mount_type = "-t " + mount_type;
		}

	    if( device == sformat("/dev/%1", source_partition) )
		break;

	    if( !SCR::Execute( .target.mount, [device, mount], mount_type ) )
		{
		symbol ret=`yes;
		// /bin/mount failed, report this to the user
		ret = Popup::AnyQuestion3(Popup::NoHeadline(),
			// popup text, %2 replaced by directory name e.g. /usr
			// %1 replaced by partition name e.g. /dev/hda1
			sformat(_("Could not mount partition %1 to %2.
You can continue if you know what you are doing, but, to prevent damage to
your file systems, it is safer to cancel and reboot."),
			    device, mount ),
			Label::ContinueButton(), Label::AbortButton(), 
			Label::RetryButton(), `focus_yes);
		if (ret == `retry)
		    {
		    retry=true;
		    }
		else if (ret == `no)
		    {
		    cancel=true;
		    }
		}
	    } while (retry==true);
	});
    y2milestone( "ret %1", !cancel );
    return( !cancel );
    };

define void DoUmountAndReset( list mounts )
    ``{
    y2milestone( "mounts %1", mounts );
    if( installation )
	{
	mounts = add( mounts, "/proc" );
	mounts = add( mounts, "/proc/bus/usb" );
	}
    integer num = size(mounts)-1;
    while( num>=0 )
	{
	y2milestone( "umount: %1", mounts[num]:"" );
	SCR::Execute( .target.umount, mounts[num]:"" );
	num = num-1;
	}
    doswapoff(activatedswaps);
    losetup_d(activatedLoopDevices);
    restoretargetmap();
    };

// define macros for the ui that is called by the package
// installer in order to update the progressbars.

UI::{
global define symbol UpdateProgressBar(integer percent)
``{
ChangeWidget(`id(`progress), `Value, percent);
any ret = PollInput();

    if ( ret == `abort && UI::ConfirmAbort(`unusable ) )
      return `cancel;
    return nil;
    }
};

  y2debug( "BEGINNING of inst_prepdisk" );

  if ( Mode::autoinst )
  {
      import "AutoinstStorage";
      AutoinstStorage::Initialize();
  }
  
  changeExtendedIdTo15();
  // check for ppc-PReP/CHRP system, they need a special boot partition
  // todo -> put this in a lib, we need it also in inst_custom_part ...

  if( !Mode::live_eval )
      MakefsDialog();

  // Begin with the actual work
  // 0.5 unmount all deleted or changed partitions ( only in running system )
  if( !installation )
      {
      list mounts = Partitions::CurMounted();
      list umounts = [];
      list targetMounts = [];

      foreach( `mounted_partition, mounts, 
	  ``{
	  y2debug( "mounted partition map : %1", mounted_partition );

	  map all_target_of_mounted_part = filter( `key, `target, Storage::GetTargetMap(), 
	                                           ``( issubstring( mounted_partition["spec"]:"", key ) ||
						       issubstring( mounted_partition["loop_on"]:"", key )));
	  y2debug( "all_target_of_mounted_part: %1 ", mounted_partition );

	  if( size( all_target_of_mounted_part ) > 0 )
	      {
	      map target_of_mounted_part = 
		  select( maplist(`k, `v, all_target_of_mounted_part, ``(v) ), 0, $[] );

	      y2debug( "target_of_mounted_part %1", select( maplist(`k, `v, all_target_of_mounted_part, ``(k) ), 0, "" ));
	      list all_partitions = filter( `part,
					    target_of_mounted_part["partitions"]:[],
					    ``( issubstring( mounted_partition["spec"]:"", sformat( "%1", part["nr"]:0 ) ) ||
					        issubstring( mounted_partition["loop_on"]:"", sformat( "%1", part["nr"]:0 ) )));

	      y2debug( " all partitions %1" , all_partitions );

	      boolean delete_found        = false;
	      boolean mount_changed_found = false;
	      boolean format_found	  = false;
	      boolean change_fsid         = false;


	      // mounted partition should be delete
	      delete_found =  size( filter( `part, all_partitions,
	                                    ``( part["delete"]:false &&
					        !part["create"]:false ))) > 0;

	      // mount point of mounted partition should be changed
	      mount_changed_found =
		  size( filter(`part, all_partitions,
	                       ``( !part["delete"]:false &&
				   (haskey(part,"ori_mount") &&
				    part["ori_mount"]:""!=part["mount"]:"") ||
				   (haskey(part,"ori_fstopt") &&
				    part["ori_fstopt"]:""!=part["fstopt"]:"") ||
				   (haskey(part,"ori_label") &&
				    !FileSystems::ChangeLabelMounted( part["used_fs"]:`unkown ) &&
				    part["ori_label"]:""!=part["label"]:""))))>0;

	      // mounted partition should formated
	      format_found = size( filter(`part, all_partitions, 
	                                  ``( !part["delete"]:false &&
					       part["format"]:false ))) > 0;

	      // change fsid of  mounted  partition
	      change_fsid = size( filter(`part, all_partitions, 
	                                 ``( !part["delete"]:false &&
					      part["change_fsid"]:false ))) > 0;

	      if( mount_changed_found || delete_found || format_found ||
	          change_fsid )
		  {
		  umounts = add( umounts, mounted_partition );
		  }

	      if( mount_changed_found || format_found || change_fsid )
		  {
		  remountPartitions = add( remountPartitions,
		                           mounted_partition["spec"]:"");
		  }
	      y2debug( "%5 delete:%1 changed:%2 format:%3 chfsid:%4",
	               delete_found, mount_changed_found,
	               format_found, change_fsid, 
		       mounted_partition["spec"]:"" );
	      }
	  });
      y2milestone( "remountPartitions=%1", remountPartitions );
      y2milestone( "umounts=%1", umounts );

      foreach( `key, `val, Storage::GetTargetMap(), 
	  ``{
          list new = filter( `v, val["partitions"]:[], ``(v["mount"]:""!=""));
	  y2milestone( "new:%1", new );
	  targetMounts = union( targetMounts, new );
	  });

      foreach( `val, targetMounts,
	  ``{
          string dev = val["device"]:"";
	  if( size( filter( `v, mounts, ``(v["spec"]:""==dev) ))==0 )
	      {
	      remountPartitions = add( remountPartitions, dev );
	      y2milestone( "remadd:%1 rem:%2", dev, remountPartitions );
	      }
	  });

      y2milestone( "remountPartitions=%1", remountPartitions );

      if( !this_is_for_real )
	  {
	  y2milestone( "All unmounted mount points : %1", 
		       maplist(`umount, umounts, ``(umount["file"]:"")));
	  }
      else
	  {
	  foreach( `umount, umounts,
	      ``{
	      string mount_point = umount["file"]:"";
	      if( mount_point != "swap")
		  SCR::Execute( .target.umount, mount_point );
	      else
		  SCR::Execute( .target.bash, 
		                "/sbin/swapoff " + umount["spec"]:"");
	      });
	  }
      }


  // 0. Prepare modify_target map
  // move first pv to vg_create

    map procMod = processModifyTargets( modify_targets, Storage::GetTargetMap() );
    Storage::SetTargetMap( procMod["targets"]:$[] );
    modify_targets  = lookup( procMod, "modify_targets", $[] );

    boolean cancel = false;
    boolean retry = false;
    boolean reboot = false;
    map tg = Storage::GetTargetMap();
    integer num_lvm_vg = size (filter (`dev,`disk, tg,
                                       ``(disk["is_lvm_vg"]:false)));
    boolean md_active = size(tg["/dev/md","partitions"]:[])>0;

  // 0b. Do any necessary lvm preparation

    if( size(modify_targets) > 0 )
	{
        // activate lvm
	SCR::Write( .md.activate, "" );
	SCR::Write( .lvm.activate, "" );
	do
	  {
	  retry=false;

	  integer n = 0;
	  boolean mod_ok = true;
	  map mod = filter( `num, `p, modify_targets,
	                    ``(p["type"]:""=="remove_lv") );
	  if( size(mod)>0 )
	    {
	    mod = mapmap( `num, `p, mod, ``{ n=n+1; return( [n, p] ); } );
	    y2milestone( "mod=%1", mod );
	    mod_ok = target_modify( mod, installation );
	    }
	  if( mod_ok )
	    {
	    mod = filter( `num, `p, modify_targets,
			  ``(p["type"]:""=="resize_lv") );
	    if( size(mod)>0 )
	      {
	      n = 0;
	      mod = mapmap( `num, `p, mod, ``{ n=n+1; return( [n, p] ); } );
	      y2milestone( "mod=%1", mod );
	      mod_ok = HandleResizeLvm( Storage::GetTargetMap(), mod, true );
	      }
	    }
	  if( mod_ok )
	    {
	    mod = filter( `num, `p, modify_targets,
			  ``(p["type"]:""=="remove_pv" ||
			     p["type"]:""=="remove_vg") );
	    if( size(mod)>0 )
	      {
	      n = 0;
	      mod = mapmap( `num, `p, mod, ``{ n=n+1; return( [n, p] ); } );
	      y2milestone( "mod=%1", mod );
	      mod_ok = target_modify( mod, installation );
	      }
	    }
	  y2milestone( "mod_ok=%1", mod_ok );

	  if ( !mod_ok )
	    {
	    symbol ret = `yes;
 
 	    // heading text
	    ret = Popup::AnyQuestion3(_("LVM setup 0 failed."),
		  // popup text
		  _("You can continue if you know what you are doing, but, to prevent
damage to your file systems, it is safer to cancel and reboot.
"),
		  Label::ContinueButton(), Label::AbortButton(), Label::RetryButton(), `focus_no);

	    if (ret == `retry)
	      {
	      retry = true;
	      }
	    else if (ret == `no)
	      {
	      return `back;
	      }
	    }
	  } while(retry);
	SCR::Write( .lvm.deactivate, "" );
        }

    if( md_active )
	{
	SCR::Write( .md.deactivate, "" );
	}

  // 1. Partitioning all disks

    // remember special devices for LILO
    string boot_device = "";
    list   swap_devices = [];
    string root_device = "";


    map running_swap = SCR::Read(.run.swapon_s);

    y2milestone("running_swap: %1", running_swap);

    foreach (`tdevice, `target, Storage::GetTargetMap(),
	``{
	if (cancel)
	    {
	    return;
	    };

	// every disk
	list partitions = target["partitions"]:[];

	y2debug("Target: %1", tdevice );

	if( Arch::s390 && target["dasdfmt"]:false )
	    {
	    boolean ok = true;
	    retry = false;
	    UI::ChangeWidget(`id(`progress), `Label,
			     // label text, %1 is replaced by disk name
			     sformat(_("dasdfmt disk %1"), tdevice ));
	    string cmd = sformat( "dasdfmt -y -v -b 4096 -d cdl -f %1", 
	                          tdevice );
	    do
		{
		y2milestone( "Executing cmd = %1", cmd );
		ok = SCR::Execute( .target.bash, cmd ) == 0; 	
		if( ok )
		    {
		    cmd = sformat( "fdasd -a %1", tdevice );
		    y2milestone( "Executing cmd = %1", cmd );
		    ok = SCR::Execute( .target.bash, cmd ) == 0; 
		    }
		if( !ok )
		    {
		    // heading text
		    symbol ret = Popup::AnyQuestion3( _("dasdfm failed."),
			// popup text, %1 is replaced by disk name
			sformat( _("dasdfmt failed on disk %1"), tdevice),
			Label::ContinueButton(),
			Label::AbortButton(),
			Label::RetryButton(), `focus_no);

		    if( ret == `retry )
			{
			retry = true;
			}
		    else if ( ret == `no )
			{
			cancel = true;
			//abort foreach run
			return;
			}
		    }
		}
	    while( !ok && retry );
	    }

	// Partitioning with fdisk agent  (s390 needs no partitioning)
	if( this_is_for_real && !Arch::s390 && 
	    Storage::IsRealDisk( tdevice, target ))
	    {
	    map bo = SCR::Execute( .target.bash_output, 
	                           "echo YAST_IS_RUNNING=$YAST_IS_RUNNING" );
	    y2milestone( "y2env %1", bo["stdout"]:"" );

            // handle all partitions resizings that decrease partition size
	    cancel = !HandleResizePartitions( tdevice, target, true );

	    boolean need_part = size( filter( `p, target["partitions"]:[],
	                                      ``( p["resize"]:false ||
	                                          p["create"]:false ||
	                                          p["delete"]:false ))) > 0;
	    y2milestone( "disk:%1 need_part:%2", tdevice, need_part );

	    if( !cancel && need_part )
		{
		path scrpath = 
		    target["scrpath"]:topath("."+substring(tdevice, 5));
		y2milestone( "partitioning %1 %2\n", 
		             .disk + scrpath + .partitions, partitions );
		if( Arch::ia64 )
		    {
		    partitions = 
			maplist( `p, partitions,
				 ``{
				 if( p["mount"]:"" == "/boot" )
				     p["fsid"] = Partitions::fsid_gpt_boot;
				 return( p );
				 });
		    }
		y2milestone( "write partitions %1", partitions );
		do
		    {
		    retry = false;
		    UI::ChangeWidget(`id(`progress), `Label,
		                     // label text, %1 is replaced by disk name e.g. /dev/hda
				     sformat(_("partitioning disk %1"), 
					     tdevice ));

		    map args = $[ "parted" : Partitions::UseParted(),
				  "label"  : target["label"]:"msdos" ];
		    y2milestone( "fdisk args %1", args );

		    /////////////////////////////////////////////////////
		    boolean result = SCR::Write(.disk + scrpath + .partitions,
						partitions, args );
		    /////////////////////////////////////////////////////

		    if( !result )
			{
			y2error("Oops, fdisk failed for device ", tdevice);

			symbol ret=`yes;
			// continue/cancel/retry during installation
			if( installation )
			    {
			    if( Storage::CheckSwapOn( tdevice ) )
				{
				reboot_necessary = true;
				}
			    else
				{
				ret = Popup::AnyQuestion3(
				    // heading text
				    _("fdisk failed."),
				    sformat (
					// popup text
					_("Partitioning failed for unknown reason.
Repartition disk %1.
    "),
					    tdevice),
				    Label::ContinueButton(),
				    Label::AbortButton(),
				    Label::RetryButton(), `focus_no);

				if( ret == `retry )
				    {
				    retry = true;
				    }
				else if ( ret == `no )
				    {
				    cancel = true;
				    //abort foreach run
				    return;
				    }
				}
			    }
			// offer reboot in running system
			else
			    {
			    // heading text
			    ret = Popup::AnyQuestion3(_("parted failed."),
				  // popup text
				  _("It is strongly advised to reboot now to prevent damage to your file systems."),
				  // button text
				  Label::ContinueButton(), Label::AbortButton(), _("Reboot"), `focus_retry);

				if( ret == `retry )
			    {
			      SCR::Execute (.target.bash,"/sbin/shutdown -r now");
			      reboot = true;
			      cancel = true;
			      //abort foreach run
			      return;
			    }
			    else if (ret == `no )
			    {
			      cancel = true;
			      //abort foreach run
			      return;
			    }
			  }
			    }
		    }
		while ( retry );
		}
	    if( !cancel && need_part && Storage::ZeroNewPartitions )
		{
		foreach( `p, filter( `e, partitions, ``(e["create"]:false)),
		    ``{
		    string dd_sblocks =
			sformat( "/bin/dd if=/dev/zero of=%1 bs=1024 count=200",
				 p["device"]:"" );
		    y2milestone( "ZeroPartitions %1", dd_sblocks );
		    SCR::Execute( .target.bash, dd_sblocks );
		    });
		}
	    if( !cancel )
		{
		foreach( `pentry, partitions,
		    ``{
		    /////////////////////////////////////////////////////
		    // look if we have to change an partition id

		    boolean change_fsid = pentry["change_fsid"]:false;
		    symbol type = pentry["type" ]:`unknown;

		    if( change_fsid )
			{
			integer ori_fsid = pentry["ori_fsid"]:0;
			integer fsid     = pentry["fsid"]:0;
			integer nr       = pentry["nr"]:0;

			y2milestone( "change_fsid disk:%1 readonly:%2", tdevice,
				     target["readonly"]:false );

			if( fsid!=ori_fsid && !target["readonly"]:false )
			    {
			    fdisk_change_id( tdevice, nr, fsid );
			    }
			}
		    });
		}

	    if( !cancel )
		cancel = !HandleResizePartitions( tdevice, target, false );
	    }  // partitioning

	if( !immediate_prepdisk )
	    {
	    // check all partitions and initialize
	    // boot_device, root_device, and swap_devices

	    foreach (`pentry, partitions,
		``{
		string device = pentry["device"]:"";
		string mountpoint = pentry["mount"]:"";
		boolean do_format = pentry["format"]:false;

		y2milestone( "device %1, mount %2, format %3", device, 
		             mountpoint, do_format );

		if( !pentry["delete"]:false)
		    {		// only those which aren't deleted
		    if( mountpoint == "/boot")
			{
			boot_device = device;
			}
			// only swaps which aren't running 
			// (yast2 did enable any swap yet!!)
		    else if( mountpoint=="swap" && 
			     (running_swap[substring(device, 4, size(device))]:"" == ""))
			{
			swap_devices = add( swap_devices, [device, do_format] );
			}
		    else if (mountpoint == "/")
			{
			root_device = device;
			}
		    }
		y2debug("Partition: %1",pentry );
		});
	    }

	if ( boot_device == "" )
	    boot_device = root_device;
	});	// foreach target

    //fdisk failed

    if( reboot )
	{
	return `abort;
	}
    if( cancel )
	{
	y2debug("fdisk failed");
	restoretargetmap();
	return `back;
	}

    if( reboot_necessary || immediate_prepdisk )
	{
	import "Misc";

        // popup text 
	Report::Message (_("Because swap needed to be activated while partitioning, rebooting
is required. After that, restart the installation.
"));
	Misc::WriteYaSTInf($["Root" : "reboot", "RebootMsg" : "0"]);
	return `abort;
	}

    if( Storage::CheckSwapConflicts() != "" )
	{
	import "Misc";

        // popup text %1 replaced by partition name e.g. /dev/hda1
	Report::Message (sformat(_("The swap partition %1 used during installation conflicts with the partitions needed for the system to be installed.\n
Please repeat the installation with another swap partition selected
"), swap_conflicts));
	Misc::WriteYaSTInf($["Root" : "reboot", "RebootMsg" : "0"]);
	return `abort;
	}

    y2milestone("boot_device: %1", boot_device );
    y2milestone("swap_devices: %1", swap_devices);
    y2milestone("root_device: %1", root_device );
    y2milestone("md_active: %1", md_active );

    //------------------------------------------------------------------
    // partitioner isn't needed any more

    SCR::UnmountAgent (.disk);

    if( md_active )
	{
	SCR::Write( .md.activate, "" );
	}

    // 2a. Do any necessary RAID preparation
    if( this_is_for_real && md_active )
	{
        map tg = Storage::GetTargetMap();
	y2milestone( "rd %1", tg["/dev/md","partitions"]:[] );
	list rem_l = filter( `p, tg["/dev/md","partitions"]:[],
	                     ``( p["delete"]:false && !p["create"]:false ));
	list add_l = filter( `p, tg["/dev/md","partitions"]:[],
	                     ``( !p["delete"]:false && p["create"]:false ));
	y2milestone( "rem %1", rem_l ); 
	y2milestone( "add %1", add_l );
	foreach( `p, rem_l,
	    ``{
	    y2milestone( "p %1", p );
	    string cmd = "/sbin/raidstop -c /dev/null " + p["device"]:"";
	    y2milestone( "cmd %1", cmd );
	    SCR::Execute( .target.bash, cmd );
	    });
	if( size( add_l )>0 || size( rem_l )>0)
	    {
	    y2milestone( "prepare raid" );
	    do
		{
		boolean raidtab_created = prepare_raid( tg, installation );
		retry = false;

		y2milestone ("raidtab_created: %1", raidtab_created);

		if (raidtab_created)
		    {
		    // remember to copy /etc/raidtab to target in inst_finish
		    Storage::SetRaidtabCreated( true );
		    }
		// prepare failed, ask user what to do
		else
		    {
		    symbol ret=`yes;
		    ret = Popup::AnyQuestion3(Popup::NoHeadline(),
						// popup text 
						_("Preparing the RAID system failed"),
						Label::ContinueButton(), Label::AbortButton(), Label::RetryButton(),`focus_no);


		    if (ret == `retry)
		    {
			retry=true;
		    }
		    else if (ret == `no)
		    {
			doswapoff(activatedswaps);
			losetup_d(activatedLoopDevices);
			restoretargetmap();
			return `back;
		    }
		    }
		} while(retry);
	    }
	}

    // 2b. Do any necessary lvm preparation
    // activate lvm, cause if I only use a existing LV, I need to activate it 
    // here
    if ( num_lvm_vg > 0 )
	{
	SCR::Write( .lvm.init, "" );
	SCR::Write( .lvm.activate, "" );
	}
    do
	{
	retry=false;
	integer n = 0;
	map mod = filter( `num, `p, modify_targets,
	                  ``(p["type"]:""!="remove_pv" &&
			     p["type"]:""!="remove_lv" &&
			     p["type"]:""!="remove_vg") );
        mod = mapmap( `num, `p, mod, ``{ n=n+1; return( [n, p] ); } );
	y2milestone( "mod=%1", mod );

	boolean ret = target_modify( mod, installation );
	if( ret )
	    {
	    mod = filter( `num, `p, modify_targets,
			  ``(p["type"]:""=="resize_lv") );
	    if( size(mod)>0 )
	      {
	      n = 0;
	      mod = mapmap( `num, `p, mod, ``{ n=n+1; return( [n, p] ); } );
	      y2milestone( "mod=%1", mod );
	      ret = HandleResizeLvm( Storage::GetTargetMap(), mod, false );
	      }
	    }

	if (ret == false)
	    {
	    symbol ret = `yes;

	    // heading text 
	    ret = Popup::AnyQuestion3(_("LVM setup 1 failed."),
		  // popup text 
		  _("You can continue if you know what you are doing, but, to prevent
damage to your file systems, it is safer to cancel and reboot.
"),
		  Label::ContinueButton(), Label::AbortButton(), Label::RetryButton(), `focus_no);

	    if( ret == `retry)
		{
	        retry = true;
		}
	    else if (ret == `no)
		{
	        doswapoff (activatedswaps);
	        losetup_d (activatedLoopDevices);
	        restoretargetmap();
	        return `back;
	        }
	    }
	} while(retry);

    if( this_is_for_real )
	{
	// 3. Create and use swap devices
	foreach (`swaplist, swap_devices,
	    ``{
	    y2milestone( "swap %1", swaplist );
	    string swapdev = select (swaplist, 0, "/dev/null");

	    if( !contains( Storage::SwappingPartitions(), swapdev ) )
		{
		boolean format_swap = swaplist[1]:false;
		string label = "";
		if( format_swap )
		    {
		    // label text %1 replaced by partition name e.g. /dev/hda1
		    label = sformat(_("Formatting %1 as swap"), swapdev );
		    }
		else
		    {
		    // label text %1 replaced by partition name e.g. /dev/hda1
		    label = sformat(_("Activating %1 for swap"), swapdev );
		    }
		UI::ChangeWidget(`id(`progress), `Label, label );

		if (swaplist[1]:false == true)		// format == yes ?
		   {
		   DumpPartitionStart( swapdev, false );
		   if( SCR::Execute (.target.bash, "/sbin/mkswap "+ swapdev) != 0 )
		      {
		      // popup text %1 replaced by partition name e.g. /dev/hda1
		      Report::Error(sformat(_("Could not set up swap partition %1"), swapdev));
		      }
		   else
		      {
		      map tg = Storage::GetTargetMap();
		      tg = Storage::DelPartitionData( tg, swapdev, "create" );
		      Storage::SetTargetMap(tg);
		      }
		   }
		if (0 != SCR::Execute (.target.bash, "/sbin/swapon "+swapdev))
		   {
		   // popup text %1 replaced by partition name e.g. /dev/hda1
		   Report::Error(sformat(_("Could not set up swap partition %1"), swapdev));
		   }
		else
		   {
		   activatedswaps = add (activatedswaps, swapdev);
		   }
		}
	    });
	}
    y2milestone( "Swap created and activated %1", this_is_for_real);

    // 4. Create filesystems
    cancel = false;
    retry = false;

    foreach( `tdevice, `target, 
             filter( `k, `e, Storage::GetTargetMap(), ``(k!="/dev/loop")),
	``{
	// every disk
	list partitions = target["partitions"]:[];
	y2milestone( "tdevice %1", tdevice );
	foreach(`partition, filter( `p, partitions, ``(!p["delete"]:false)),
	    ``{
	    if( !cancel && 
	        (size(partition["mount"]:"")>0 ||
	         size(partition["label"]:"")>0 || 
	         partition["format"]:false))
		{
		cancel = !HandleFormatPartition( partition );
		y2milestone( "after HandleFormatPartition cancel %1", cancel );
		}
	    });
	});

    // some mkfs failed, go back
    if( cancel )
	{
	doswapoff(activatedswaps);
	losetup_d(activatedLoopDevices);
	restoretargetmap();
	return `back;
	}


    // 5. Mount all targets with mountpoints

    // now select all native partitions with a mountpoint
    // and put them in a map. This ensures lexical ordering.
    map mountPoints = $[];
    map tg = Storage::GetTargetMap();

    foreach( `tdevice, `target, filter( `k, `e, tg, ``(k!="/dev/loop")),
	``{
	mountPoints = DetermineMountPoints( tdevice, target, mountPoints );
	}); // foreach (tdevice)

    y2milestone("MountPoints: %1",mountPoints);
    //Popup::Message("mount " );

    y2milestone( "Enable automatic module loading for mount");
    if( installation )
	SCR::Execute( .target.bash, 
	              "/bin/echo /sbin/modprobe >/proc/sys/kernel/modprobe");

    if( this_is_for_real )
	{
	cancel = !DoMountList( mountPoints );

	// some mount failed, try to umount all already mounted partitions
	if( cancel )
	    {
	    list mlist = maplist( `k, `e, mountPoints, ``(k) );
	    DoUmountAndReset( mlist );
	    return `back;
	    }
	}

    if( size( tg["/dev/loop","partitions"]:[] )>0 && this_is_for_real )
	{
	map loop = tg["/dev/loop"]:$[];
	list mlist = maplist( `k, `e, mountPoints, ``(k) );
	foreach( `p, loop["partitions"]:[],
	    ``{
	    string fpath = Storage::PathToDestdir( p["fpath"]:"" );
	    if( !cancel && p["create"]:false )
		{
		integer size_k = loop["cyl_size"]:0 * p["region",1]:0 / 1024;
		integer max_ur = 10*1024;
		if( size_k<max_ur )
		    {
		    max_ur = size_k;
		    }
		string cmd = 
		    sformat( "dd if=/dev/urandom of=%1 bs=1k count=%2", fpath,
			     max_ur );
		size_k = size_k-max_ur;
		if( size_k>0 )
		    {
		    cmd = cmd + "; dd if=/dev/zero ";
		    cmd = cmd + sformat( "of=%1 bs=1k count=%2 seek=%3",
				         fpath, size_k, max_ur );
		    cmd = cmd + " conv=notrunc";
		    }
		if( SCR::Read( .target.size, fpath )>=0 )
		    {
		    SCR::Execute( .target.remove, fpath  );
		    }
		fpath = substring( fpath, 0, findlastof( fpath, "/" ));
		y2milestone( "dir %1", fpath );
		if( SCR::Read( .target.size, fpath )<=0 )
		    {
		    SCR::Execute( .target.mkdir, fpath  );
		    }
		y2milestone( "cmd %1", cmd );
		UI::ChangeWidget( `id(`progress), `Value, 0 );
		UI::ChangeWidget( `id(`progress), `Label, 
				  // label text %1 replaced by pathname 
				  sformat( _("Creating crypt file %1"), 
					   p["fpath"]:"" ));
		if( SCR::Execute (.target.bash, cmd ) != 0 )
		    {
		    // popup text %1 replaced by pathname 
		    Report::Error(sformat(_("Could not create crypt file %1"), p["fpath"]:"" ));
		    cancel = true;
		    }
		}
	    if( !cancel && p["delete"]:false )
		{
		if( size(p["loop_dev"]:"")>0 )
		    {
		    SCR::Execute( .target.bash, 
				  "/sbin/losetup -d " + p["loop_dev"]:"" );
		    }
		if( size(p["fpath"]:"")>0 && p["fpath_remove"]:false )
		    {
		    if( SCR::Read( .target.size, fpath )>=0 )
			{
			SCR::Execute( .target.remove, fpath  );
			}
		    }
		}
	    if( !cancel && !p["delete"]:false )
		{
		cancel = !HandleFormatPartition( p );
		}
	    });
	if( !cancel )
	    {
	    map loop_mp = DetermineMountPoints( "/dev/loop", loop, $[] );
	    cancel = !DoMountList( loop_mp );
	    if( cancel )
		{
		mlist = union( mlist, maplist( `k, `e, loop_mp, ``(k) ));
		}
	    }
	if( cancel )
	    {
	    DoUmountAndReset( mlist );
	    return `back;
	    }
	}

    y2milestone( "installation=%1", installation );

    if( this_is_for_real )
	{
	if( num_lvm_vg > 0 )
	    {
	    SCR::Execute (.target.mkdir, 
			  Installation::destdir + "/etc/lvmtab.d", 0755);
	    }

	//mount proc and usbdevfs during installation
	if (installation)
	    {
	    string destproc = Installation::destdir+"/proc";
	    SCR::Execute (.target.mkdir, destproc, 0755);
	    SCR::Execute (.target.mount, ["proc", destproc], "-t proc");
	    if (Hotplug::haveUSB)
		{
		SCR::Execute( .target.mount, ["usbdevfs", destproc +"/bus/usb"],
			      "-t usbdevfs" );
		}
	    }
	Storage::WriteFstab( Storage::GetTargetMap() );
	}

    y2milestone( "Disable automatic module loading");
    if( installation )
	SCR::Execute( .target.bash, 
	              "/bin/echo /etc/nothing >/proc/sys/kernel/modprobe");

    // remove all possibly remaining occurences of entries causing changes
    // in targetmap 
    tg = Storage::GetTargetMap();
    foreach( `device, `disk, tg,
	``{
	list remove_keys = [ "format", "ori_mount", "ori_label", "ori_fstopt", 
	                     "ori_mountby", "create", "resize", "ori_fsid", 
			     "ori_nr", "change_fsid", "ori_length", 
			     "ori_fstype" ];
	list new = [];
	foreach( `part, disk["partitions"]:[],
	    ``{
	    if( !part["delete"]:false )
		{
		part = filter( `k, `v, part, ``(!contains( remove_keys, k )));
		new = add( new, part );
		}
	    });
	tg[device,"partitions"] = new;
	});
    tg = filter( `device, `disk, tg, ``(!disk["delete"]:false));
    Storage::SetTargetMap( tg );

    SCR::Write( .target.ycp, Storage::SaveDumpPath("targetMap_pe"), 
                Storage::GetTargetMap() );

    Storage::SetModifyTargets( $[] );

    y2debug("END inst_prepdisk.ycp");

//XXX
  //Popup::Message("finish");
//  return `back;

    return `next;
}
