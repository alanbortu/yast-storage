/**
 * File:	inst_custem_part.ycp
 * Package:	yast2-storage
 * Summary:	Entry Point for Expert Partitioner
 * Authors:	Michael Hager <mike@suse.de>
 *		Arvin Schnell <aschnell@suse.de>
 */
{
    textdomain "storage";


    include "partitioning/ep-main.ycp";


    return ExpertPartitioner();




     /**
      * Dialog: "Resize a partition Dialog"
      * @parm cur_val  map that contains a partition
      * @parm device   device name of the resized partition
      * @parm cyl_size size of a cylinder on the disk
      * @return map modified partition or nil by cancel
      */
define map ResizePartDlg( map cur_val, string device, map disk, map possible )
    ``{
    integer cyl_size = disk["cyl_size"]:0;
    boolean test_simple_ui = false;
    boolean win = Partitions::IsDosWinNtPartition( cur_val["fsid"]:0 );
    boolean swap = !win && cur_val["fsid"]:0==Partitions::fsid_swap;
    boolean simple_ui = false;
    integer cyl_after = 0;
    if( possible["extend"]:false )
	{
	// cyl_after = Storage::FreeCylAfter( disk, cur_val );
	}
    integer av_space = cyl_after*cyl_size;

    y2milestone( "ResizePartDlg dev:%1 cyl:%2 map:%3 win:%4 swap:%5",
		 device, cyl_size, cur_val, win, swap );
    y2milestone( "ResizePartDlg cyl_after:%1 av_space:%2",
		 cyl_after, av_space );

    integer min_free = 0;
    integer new_size = 0;
    integer shrink_size = 0;
    integer new_min = 0;

    map df = $[];

    if( !swap && !cur_val["format"]:false )
	{
	df = Storage::GetFreeSpace( device, 0, cur_val["used_fs"]:`none, true );
	if( size(df)==0 || !df["ok"]:false )
	    {
	    y2error( "failed GetFreeSpace %1 fs:%2", device,
		     cur_val["used_fs"]:`none );
	    string tmp = sformat(
_("Partition %1 cannot be resized
because the file system seems to be inconsistent.
"), device );
	    Popup::Error( tmp );
	    return( nil );
	    }
	}
    else
	{
	df["used"] = 0;
	if( haskey( cur_val, "orig_size_k" ) && cur_val["resize"]:false )
	    {
	    df["df_free"] = cur_val["orig_size_k"]:0 * 1024;
	    }
	else
	    {
	    df["df_free"] = cur_val["region",1]:0 * cyl_size;
	    }
	df["free"] = df["df_free"]:0;
	}

    // label text
    string  unit = _("MB");
    integer factor = 1024*1024;

    if( df["df_free"]:0 > 15*1024*factor )
	{
	factor = factor * 1024;
	unit = _("GB");
	}
    y2milestone( "ResizePartDlg factor:%1", factor );

    if( haskey( cur_val, "win_max_length" ) && cur_val["resize"]:false )
	{
	new_min = cur_val["orig_size_k"]:0*1024/cyl_size - cur_val["win_max_length"]:0;
	new_min = new_min*cyl_size / factor;
	}

    y2milestone( "ResizePartDlg min_lin:%1 df:%2", new_min, df );

    integer used = df["used"]:0 / factor;
    integer free = df["df_free"]:0 / factor;
    integer not_shrink_free = 0;

    // Labels for bar graph. "%1" will be replace with a numeric value.
    string bargraph_label_used  = "";
    string bargraph_label_free  = "";
    string bargraph_label_new   = "";
    if( win )
	{
	// label text %1 is replaced by a number
	bargraph_label_used  = _("Windows\nUsed\n%1 ") + unit;
	// label text %1 is replaced by a number
	bargraph_label_free  = _("Windows\nFree\n%1 ") + unit;
	// label text %1 is replaced by a number
	bargraph_label_new   = _("Linux\nSize\n%1 ") + unit;
	}
    else
	{
	// label text %1 is replaced by a number
	bargraph_label_used  = _("Space\nUsed\n%1 ") + unit;
	if( swap )
	    {
	    // label text %1 is replaced by a number
	    bargraph_label_free  = _("Swap\nSpace\n%1 ") + unit;
	    }
	else
	    {
	    // label text %1 is replaced by a number
	    bargraph_label_free  = _("Space\nFree\n%1 ") + unit;
	    }
	// label text, %1 is replaced by a number
	bargraph_label_new   = _("Unused\nDisk\n%1 ") + unit;
	}

    // Labels for input fields. "%1" will be replaced with the current unit (MB)
    string field_label_free = "";
    string field_label_new  = "";
    if( win )
	{
	// label text, %1 is replaced by a unit value ("MB")
	field_label_free = sformat( _("Windows Free (%1)"), unit);
	// label text, %1 is replaced by a unit value ("MB")
	field_label_new  = sformat( _("Linux Size (%1)"), unit);
	}
    else
	{
	// label text, %1 is replaced by a unit value ("MB")
	field_label_new  = sformat( _("Unused Disk (%1)"), unit);
	if( swap )
	    {
	    // label text, %1 is replaced by a unit value ("MB")
	    field_label_free = sformat( _("Swap Space (%1) "), unit);
	    }
	else
	    {
	    // label text, %1 is replaced by a unit value ("MB")
	    field_label_free = sformat( _("Space Free (%1)"), unit);
	    }
	}

    if( win )
	{
	min_free = (factor==1024*1024)?200:1;
	if( df["df_free"]:0 != df["free"]:0 )
	    {
	    not_shrink_free = df["df_free"]:0 - df["free"]:0;
	    not_shrink_free = (not_shrink_free + factor - 1) / factor;
	    if( not_shrink_free > min_free )
		{
		min_free = not_shrink_free;
		}
	    }
	}
    else
	{
	min_free = (factor==1024*1024)?5:1;
	}

    if( cur_val["used_fs"]:`none == `ntfs &&
        not_shrink_free > df["free"]:0/factor/5 )
        {
	    //Message text.  %1 and %2 are numbers. %3 is the unit.
	string ptext = sformat( _("Your NTFS file system has %1 %3 free space available. Due to limitations in
the NTFS resizer, the file system can only be shrunk by up to %2 %3.
To be able to shrink the file system more, boot your Windows
system and run a disk defragmentation program under Windows to move
the used blocks of the file system towards the start of the partition.
"),
                                free, df["free"]:0/factor, unit );
        Popup::Message( ptext );
	}
    if( haskey( cur_val, "orig_size_k" ) && cur_val["resize"]:false )
	{
	shrink_size = (df["used"]:0+df["df_free"]:0)/factor -
		      cur_val["region",1]:0*cyl_size/factor;
	y2milestone( "ResizePartDlg new_size_k:%1 shrink_size:%2",
	             cur_val["region,1"]:0*cyl_size/factor, shrink_size );
	if( shrink_size>df["free"]:0/factor )
	    {
	    shrink_size = df["free"]:0/factor;
	    }
	y2milestone( "ResizePartDlg shrink_size:%1", shrink_size );
	}
    av_space = av_space/factor;

    y2milestone( "ResizePartDlg min_free:%1 free:%2 used:%3 shrink_size:%4 unit:%5",
                 min_free, free, used, shrink_size, unit );

    string windows = "";
    if( win )
	{
	// label text
	windows = _("Windows");
	}

    // Help text for partition resizing -
    // common part for both graphical mode (with bar graphs)
    // and non-graphical mode (text only).
    // %1 is OS label, such as Windows
    string helptext = sformat( _("<p>
Choose the new size for your %1 partition.
</p>"), windows );

    // help text (common to both modes), continued
    // %1 is OS label, such as Windows
    helptext = helptext + sformat( _("
<p>
The actual resizing is performed only after you confirm all your
settings in the last installation dialog. Until then, your %1
partition will remain untouched.
</p>"), windows );

    // help text (common to both modes), continued
    helptext = helptext + _("
<p>
If you decide not to resize your partition, press
<b>Do Not Resize</b>. This resets the values to the original
size of the partition.
</p>
");

    if( UI::HasSpecialWidget(`Slider   ) &&
	UI::HasSpecialWidget(`BarGraph ) && !test_simple_ui )
	{
	// help text, continued - graphical mode only
	// this text will be appended to the help text common to both modes.
	helptext = helptext + _("
<p>
The upper bar graph displays the current situation.
The lower bar graph displays the situation after the installation (after
the partition resize).
</p>");
	// help text (graphical mode), continued
	helptext = helptext + _("
<p>
Drag the slider or enter a numeric value in either
input field to adjust the suggested value.
</p>");

	////////////////////////////////////////////////////////////////////////////////////////////
	// Open main dialog for resizing of partitions
	////////////////////////////////////////////////////////////////////////////////////////////
	term graph = nil;
	if( win || cyl_after==0 )
	    {
	    graph = `BarGraph( [ used, free ],
			       [ bargraph_label_used, bargraph_label_free ] );
	    }
	else
	    {
	    graph = `BarGraph( [ used, free, av_space ],
			       [ bargraph_label_used, bargraph_label_free,
				 bargraph_label_new ] );
	    }
	y2milestone( "ResizePartDlg graph=%1", graph );

	UI::OpenDialog( `opt(`decorated  ),
		    `HBox(
			  `HWeight(30, `RichText( helptext )),
			  `HStretch(),
			  `HSpacing(1),
			  `HWeight(70,`VBox(
			      `HSpacing(50),
			      `VStretch(),
			      `VSpacing(1),
			      // Headline above bar graph that displays current partition size
			      `Left( `Label( _("Now")) ),
			      graph,
			      `VSpacing(1),
			      `VStretch(),
			      // Headline above bar graph that displays future partitions
			      `Left( `Label( _("After Installation") ) ),
			      `PartitionSplitter( `id(`linux_size),
						  used, free+av_space,
						  shrink_size+av_space, new_min, min_free,
						  bargraph_label_used,
						  bargraph_label_free,
						  bargraph_label_new,
						  field_label_free,
						  field_label_new ),
			      // Button text
			      `HBox( `PushButton(`id(`rem_resize), _("&Do Not Resize") )),
			      `VSpacing(1),
			      `HBox(
				   `PushButton(`id(`ok), `opt(`default),  Label::OKButton()   ),
				   `PushButton(`id(`cancel),  Label::CancelButton() ))
			      ))));
	}
    else
	{
	simple_ui = true;
	// help text, continued - non-graphical mode only
	// this help text will be appended to the help text common to both modes.
	//%1 is OS label, such as Windows
	helptext = helptext + sformat( _("
<p>Enter a value for the size to which to shrink the %1 partition.
</p>"), windows );

	string used_label = "";
	if( win )
	    {
	    // Label text
	    used_label = _("Windows Used");
	    }
	else
	    {
	    // Label text
	    used_label = _("Used");
	    }
	// help text (non-graphical mode), continued
	//%1 is label text, such as Used. %2 is OS, such as Windows.
	helptext = helptext + sformat(_("
<p>
<b>%1<b> is the size of the used part of your %2 partition.
</p>"), used_label, windows );

	// help text (non-graphical mode), continued
	helptext = helptext + _("
<p><b>Free</b> indicates the current free space (before shrinking)
of the partition.
</p>");

	UI::OpenDialog( `opt(`decorated  ),
		    `HBox(
			`HWeight(30, `RichText( helptext )),
			`HStretch(),
			`HSpacing(1),
			`HWeight(70,
			  `VBox(
			    `HBox(
				// Label for used part of the partition in non-graphical mode
				`HWeight(3, `Right(`Label(used_label))),
				`HWeight(2, `Label(`opt(`outputField), sformat("%1", used ))),
				`HWeight(3, `Left(`Label( unit )))),
			    `VSpacing(0.5),
			    `HBox(
				// Label for free part of the partition in non-graphical mode
				`HWeight(3, `Right(`Label(_("Free")))),
				`HWeight(2, `Label(`opt(`outputField), sformat("%1", free ))),
				`HWeight(3, `Left(`Label( unit )))),
			    `VSpacing(0.5),
			    `HBox(
				 // Edit field label for linux partition size in non-graphical mode
				`HWeight(3, `Right(`Bottom(`Label(_("New Size"))))),
				`HWeight(2, `IntField( `id(`linux_size), "",
						       used+min_free, used+free+av_space,
						       used+free-shrink_size)),
				`HWeight(3, `Left(`Bottom(`Label( unit ))))),
			    // Button text
			    `HBox( `PushButton( `id(`rem_resize),
			                        _("&Do Not Resize") )),
			    `VSpacing(1),
			    `HBox(
				 `PushButton( `id(`ok), `opt(`default),
				              Label::OKButton() ),
				 `PushButton( `id(`cancel),
				              Label::CancelButton() ))
			   ))));
	}

    map retval = cur_val;
    any ret = `ok;

    repeat
	{
	/////////////////////////////////////////////////////////////
	// Check the User input
	ret = UI::UserInput();

	y2milestone( "ResizePartDlg ret=%1", ret );

	if( ret == `rem_resize )
	    {
	    if( simple_ui )
		UI::ChangeWidget( `id(`linux_size), `Value,  used+free );
	    else
		UI::ChangeWidget( `id(`linux_size), `Value,  av_space );
	    }

	if( ret == `ok )
	    {
	    // Get the value the user adjusted. If s/he entered a value
	    // too big or too small this is automatically adjusted to the
	    // biggest/smallest value possible (by Qt).
	    shrink_size = (integer)UI::QueryWidget(`id(`linux_size), `Value);
	    y2milestone( "ResizePartDlg shrink_size %1", shrink_size );
	    if( simple_ui )
		{
		new_size = shrink_size;
		}
	    else
		{
		new_size = used + free + av_space - shrink_size;
		}
	    y2milestone( "ResizePartDlg Value:%1 New size:%2", shrink_size, new_size);
	    }
        if( ret == `ok )
	    {
	    if( (!simple_ui && shrink_size != av_space) ||
	        (simple_ui && shrink_size != used+free) )
		{
		retval["resize"] = true;
		list new_reg = [ retval["region",0]:0,
				 PartedSizeToCly( (tofloat(new_size*factor)), cyl_size ) ];
		retval["region"] = new_reg;
		}
	    else
		{
		retval["resize"] = false;
		}
	    }
	if( ret == `ok && !cur_val["format"]:false && retval["resize"]:false )
	    {
	    integer diff = 0;
	    if( haskey( retval, "orig_size_k" ))
		diff = retval["region",1]:0 - retval["orig_size_k"]:0*1024/cyl_size;
	    else
		diff = retval["region",1]:0 - cur_val["region",1]:0;
	    string mp = cur_val["inactive"]:false ? "" : cur_val["mount"]:"";
	    y2milestone( "ResizePartDlg diff %1 mp %2", diff, mp );
	    if( !CheckResizePossible( false, false, diff,
				      cur_val["used_fs"]:`unknown, mp ))
		{
		ret = `again;
		}
	    }
	y2milestone("ResizePartDlg ret = %1", retval );
	}
    until( ret == `ok || ret == `cancel );

    UI::CloseDialog();

    if( ret == `cancel )
	{
	return( nil );
	}
    else
	{
	return( retval );
	}
    }


define string FormatCauseLine( symbol cause )
    ``{
    if( cause == `no_ext )
	// complete sentence, appended after other complete sentences.
	return( _("No extended partition exists."));
    if( cause == `dev_full )
	// complete sentence, appended after other complete sentences.
	return( _("There are already four primary and extended partitions."));
    if( cause == `no_extsp )
	// complete sentence, appended after other complete sentences.
	return( _("No space is left in the extended partition."));
    if( cause == `to_many )
	// complete sentence, appended after other complete sentences.
	return( _("Too many logical drives already exist."));
    if ( cause == `no_space )
	// complete sentence, appended after other complete sentences.
	return( _("No space remains."));
    if ( cause == `already )
	// complete sentence, appended after other complete sentences.
	return( _("An extended partition already exists."));
    return( "---" );
    };


    /*---------------------------------------------------------------------
     * Make a output string for "you can not create a partition, because: "
     *---------------------------------------------------------------------
     */

define string FormatYouCannotCause( boolean primary_is_possible,
				    boolean extended_is_possible,
				    boolean logical_is_possible,
				    symbol  no_primary_cause,
				    symbol  no_extended_cause,
				    symbol  no_logical_cause )
    ``{
    string pri_line = "";
    string ext_line = "";
    string log_line = "";

    y2milestone( "prim:%1 ext:%2 log:%3 (%4 %5 %6)", primary_is_possible,
                 extended_is_possible, logical_is_possible, no_primary_cause,
		 no_extended_cause, no_logical_cause );

    if( primary_is_possible )
	// complete sentence. gets combined with other sentences.
	pri_line = _("A primary partition can be created.\n");
    else
	// complete sentence. gets combined with other sentences.
	pri_line = _("A primary partition cannot be created.") + " " +
	           FormatCauseLine( no_primary_cause ) + "\n";

    if( logical_is_possible )
	// complete sentence. gets combined with other sentences.
	log_line = _("A logical partition can be created.\n");
    else
	if( no_logical_cause != `impossible )
	    // complete sentence. gets combined with other sentences.
	    log_line = _("A logical partition cannot be created.") + " " +
		       FormatCauseLine( no_logical_cause ) +"\n" ;

    if ( extended_is_possible )
	// complete sentence. gets combined with other sentences.
	ext_line = _("An extended partition can be created.\n");
    else
	if( no_logical_cause != `impossible )
	    // complete sentence. gets combined with other sentences.
	    ext_line = _("An extended partition cannot be created.") + " " +
		       FormatCauseLine( no_extended_cause ) +"\n";

    return ( pri_line + ext_line + log_line );
    };


    symbol ret = nil;


	map<string,map> tg =  Storage::GetTargetMap();

        ret = (symbol)Wizard::UserInput();


        /////////////////////////////////////////////////////////////
        // RESIZE
        /////////////////////////////////////////////////////////////
        if (ret == `resize)
	    {
	    string id = (string)UI::QueryWidget(`id(`table), `CurrentItem);
	    map part = $[];
	    map disk = Storage::GetDisk( tg, id );
	    if( !haskey( tg, id ) )
		part = Storage::GetPartition( tg, id );

	    if( disk["readonly"]:false )
		{
		Popup::Error( Partitions::RdonlyText( disk["device"]:"", true ));
		ret = `again;
		}

	    y2milestone( "disk=%1", disk );
	    y2milestone( "RESIZE id=%1 part=%2", id, part );
	    map possible = Storage::IsResizable( part );
	    if( size(part)==0 ||
		part["used_by_type"]:`UB_NONE == `UB_LVM ||
		part["used_by_type"]:`UB_NONE == `UB_MD ||
	        part["type"]:`unknown == `sw_raid ||
	        part["type"]:`unknown == `nfs ||
	        part["type"]:`unknown == `loop ||
	        part["type"]:`unknown == `dm )
		{
                // popup text
		Popup::Message(_("
You cannot resize a disk device, LVM volume group, LVM physical volume,
NFS mount, or MD device.
"));
		}
	    else if( !part["format"]:false &&
	        !possible["extend"]:false && !possible["shrink"]:false )
		{
                // popup text
		Popup::Message(_("
You cannot resize the selected partition because the file system
on this partition does not support resizing.
"));
                }
	    else if( part["type"]:`unknown == `lvm )
		{
		    // HandleEditLv( tg, id );
		}
	    else
		{
		map new_val = part;
		if( Mode::normal() && new_val["used_fs"]:`none == `ntfs )
		    {
		    Package::InstallAll( ["ntfsprogs"] );
		    }
		string dev = new_val["device"]:"";
		if( new_val["ori_nr"]:0 > 0 &&
		    new_val["ori_nr"]:0 != new_val["nr"]:0 )
		    {
		    dev = Storage::GetDeviceName( disk["device"]:"", new_val["ori_nr"]:0 );
		    }
		new_val = ResizePartDlg( new_val, dev, disk, possible );
		if( new_val != nil )
		    {
		    integer size_change = part["region",1]:0 -
			                  new_val["region",1]:0;
		    y2milestone( "region old=%1 new:%2", part["region"]:[],
		                 new_val["region"]:[] );
		    y2milestone( "size_change=%1", size_change );
		    tg = Storage::SetPartition( tg, new_val );
		    Storage::SetTargetMap(tg);
		    if( size_change != 0 &&
		        Storage::CheckNextCreated( disk,
			                           part["region"]:[0,0] ))
			{
			if( size_change < 0 )
			    {
			    // popup text
			    Popup::Message( _("
You decreased the size available for Linux partitions.
Linux partition sizes have been adapted accordingly.
Check the new sizes in the partition list.
"));
                            Storage::AdaptResize( disk["device"]:"",
			                          part["region"]:[0,0],
						  size_change );
			    }
			// popup text
			else if( Popup::YesNo( _("
You decreased a partition that is followed by a newly-created partition.
Should the newly-created partition be automatically increased to use the
freed disk space?
")) )
			    {
                            Storage::AdaptResize( disk["device"]:"",
			                          part["region"]:[0,0],
						  size_change );
			    }
			}
		    }
		}
	    }

}
