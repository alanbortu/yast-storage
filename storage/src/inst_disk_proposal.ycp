/*
 * Copyright (c) 2012 Novell, Inc.
 *
 * All Rights Reserved.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as published
 * by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
 * more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, contact Novell, Inc.
 *
 * To contact Novell about this file by physical or electronic mail, you may
 * find current contact information at www.novell.com.
 */

/*
 *************************************************************
 *
 *     YaST2      SuSE Labs                        -o)
 *     --------------------                        /\\
 *                                                _\_v
 *           www.suse.de / www.suse.com
 * ----------------------------------------------------------
 *
 * Author:        Michael Hager <mike@suse.de>
 *
 * Description:   Create a proposal for partitioning
 *
 *
 *
 *
 *
 *************************************************************

 $Id: inst_part_proposal.ycp 43636 2008-01-15 17:25:46Z fehr $

*/

{
  textdomain "storage";

  import "Arch";
  import "Wizard";
  import "Mode";
  import "Popup";
  import "Storage";
  import "Sequencer";
  import "StorageProposal";
  import "Stage";
  

    include "partitioning/custom_part_dialogs.ycp";
    include "partitioning/ep-import.ycp";

boolean CouldNotDoSeparateHome( map<string,map> prop )
    {
    boolean ret = false;
    if( StorageProposal::GetProposalHome() )
	{
	list<map> ls = [];
	foreach( string k, map d, prop,
	    ``{
	    ls = (list<map>)union( ls, filter( map p, d["partitions"]:[], 
					       ``(!p["delete"]:false&&size(p["mount"]:"")>0) ));
	    });
	ret = size(filter( map p, ls, ``(p["mount"]:""=="/home")))==0;
	y2milestone( "CouldNotDoSeparateHome ls:%1", ls );
	}
    y2milestone( "CouldNotDoSeparateHome ret:%1", ret );
    return( ret );
    }


boolean AskOverwriteChanges()
    {
    boolean ret = true;
    string target_is = Storage::GetPartMode();
    y2milestone( "AskOverwriteChanges target_is %1", target_is );
    if( target_is=="USE_DISK" || target_is=="CUSTOM" ||
        target_is=="PROP_MODIFY" )
	{
	ret = Popup::YesNo(
_("Computing this proposal will overwrite manual changes 
done so far. Continue with computing proposal?"));
	}
    y2milestone( "AskOverwriteChanges ret:%1", ret );
    return( ret );
    }


void execSubscreens(symbol mode)
    {
    y2milestone( "execSubscreens mode:%1", mode );

    if (Mode::autoinst())
	{
	Storage::SetPartMode("PROP_MODIFY");
	}
    else
	{
    map aliases =
	$[ "disk" :
		``(WFM::CallFunction("inst_disk", [true, true])),
	   "target_sel" :
		``(WFM::CallFunction("inst_target_selection", [true, true])),
	   "target_part" :
		``(WFM::CallFunction("inst_target_part", [true, true])),
	   "resize_ui" :
		``(WFM::CallFunction("inst_resize_ui", [true, true])),
	  ];

    map seq = $[];
    seq["disk"] = $[ `abort : `abort, `cancel: `cancel, `next: `next ];

	    switch (mode)
	    {
		case `modify:
		case `detailed:
		{
	y2milestone( "ProposalActive %1 ProposalMode %2 PartMode %3",
		     Storage::GetPartProposalActive(),
		     Storage::GetPartProposalMode(), Storage::GetPartMode() );
	seq["target_sel"] = $[ `abort : `abort, `cancel: `cancel,
			       `next : "target_part" ];
	seq["target_part"] = $[ `abort : `abort, `cancel: `cancel,
				`next : "disk" ];
	if( Arch::i386() )
	    {
	    seq["resize_ui"] = $[ `abort : `abort, `cancel: `cancel,
				  `next : "disk" ];
	    seq["target_part",`next] = "resize_ui";
	    }
	seq["disk"] = $[ `abort : `abort, `cancel: `cancel, `next : `next ];
	y2milestone( "execSubscreens GetPartMode %1", Storage::GetPartMode() );
	if( mode == `detailed && Storage::GetPartMode()!="CUSTOM" )
	    seq["ws_start"] = "target_sel";
	else
	    seq["ws_start"] = "disk";
	if( Storage::CheckBackupState("disk"))
	    Storage::DisposeTargetBackup("disk");
	y2milestone( "execSubscreens sequence %1", seq );
	Wizard::OpenNextBackDialog();
	symbol result = Sequencer::Run(aliases, seq);
	Wizard::CloseDialog();
		}
		break;

		case `import:
		{
		    ImportMountPoints();
		}
		break;
	    }

	Storage::HandleProposalPackages();    
	}
    }

map<string,map> targetMap       = Storage::GetTargetMap();

if( Mode::test() && size(targetMap)==0 )
    {
    y2warning("***** Demo mode active - using fake demo values *****");
    targetMap = (map<string,map>)SCR::Read(.target.yast2, "demo_target_map.ycp");
    Storage::SetTargetMap( targetMap );
    }


// Title for dialogue
string title = _("Suggested Partitioning");
// Radiobutton for partition dialog
string modify_str   = _("&Edit Partition Setup...");
// Radiobutton for partition dialog
string detailed_str = _("&Create Partition Setup...");
// Radiobutton for partition dialog
string import_str = _("&Import Partition Setup...");

string target_is = "";

string changes = "";
if( Storage::GetPartProposalFirst() )
    {
    map prop = StorageProposal::get_inst_prop(Storage::GetTargetMap());
    y2milestone( "prop ok:%1", prop["ok"]:false );

    if( prop["ok"]:false )
        {
	if( CouldNotDoSeparateHome( prop["target"]:$[] ))
	    {
	    StorageProposal::SetProposalHome(false);
            if( UI::WidgetExists(`id(`home)))
                UI::ChangeWidget(`id(`home), `Value, false);
	    }
	Storage::SetTargetMap( prop["target"]:$[] );
	targetMap = prop["target"]:$[];
	Storage::SetPartProposalMode( "accept" );
	changes = Storage::ChangeText();
	Storage::HandleProposalPackages();
	target_is = "SUGGESTION";
	Storage::SetPartMode( target_is );
	Storage::SetPartProposalFirst( false );
	Storage::SetPartProposalActive( true );
	}
    else
        {
	Storage::SetPartProposalMode( "impossible" );
	}
    }
else
    changes = Storage::ChangeText();

if( Storage::GetPartProposalMode() == "impossible" )
    {
    changes = "<font color=red>";
    changes = changes + _("No automatic proposal possible.
Specify mount points manually in the 'Partitioner' dialog.");
    changes = changes + "</font>";
    }

y2milestone( "current proposal: %1", changes );

term rframe =
    `HBox( `HSpacing(20), 
           StorageProposal::AddCommonWidgets(),
	   `HSpacing(3) );

term bframe = 
    `VBox(
	`PushButton( `id(`detailed), detailed_str ),
	`VSpacing(0.2),
	`PushButton( `id(`import), import_str ),
	`VSpacing(0.2),
	`PushButton( `id(`modify), modify_str )
	);

float space = StorageProposal::SaveHeight()?1:2;

term contents =
    `MarginBox(2, 0.4,
	    `VBox(
		 `MinHeight(8, `RichText(`id(`richtext), changes)),
		 rframe,
		 `VSpacing(space),
		 bframe,
		 `VStretch()
		 )
	);


// help on suggested partitioning
string help_text =  _("<p>
Your hard disks have been checked. The partition setup
displayed is proposed for your hard drive.</p>");

// help text continued
// %1 is replaced by button text
help_text =  help_text + sformat(_("<p>
To make only small adjustments to the proposed
setup (like changing filesystem types), choose
<b>%1</b> and modify the settings in the expert
partitioner dialog.</p>
"), deletechars(modify_str,"&"));

// help text continued
// %1 is replaced by button text
help_text = help_text + sformat(_("<p>
To import the mount points from an existing Linux
system choose <b>%1</b>. You can still make modification
afterwards in the expert partitioner dialog.</p>
"), deletechars(import_str, "&"));

// help text continued
help_text =  help_text + sformat(_("<p>
If the suggestion does not fit your needs, create
your own partition setup starting with the partitions 
currently present on the disks. Select
<b>%1</b>.
This is also the option to choose for
advanced configurations like RAID and encryption.</p>
"), deletechars(detailed_str,"&"));

// help text continued
// %1 is replaced by button text
help_text =  help_text + _("<p>
To create an LVM-based proposal, choose the corresponding button.</p>
");


symbol ret = nil;

// Attention! besides the testsuite, AutoYaST is using this to turn off
// the proposal screen too. See inst_autosetup.ycp
//
if( !Storage::GetTestsuite() )
    {
    StorageProposal::SetCreateVg( false );
    map enab = (map)WFM::Args(0);
    Wizard::SetContents( title, contents, help_text,
			 enab["enable_back"]:false, enab["enable_next"]:false );
    if( Stage::initial () )
	Wizard::SetTitleIcon( "yast-partitioning" );

    UI::ChangeWidget(`id(`encrypt), `Enabled, StorageProposal::GetProposalLvm());

    repeat
	{
	boolean val = false;
	Wizard::SetFocusToNextButton();
	ret = (symbol)Wizard::UserInput();
	y2milestone( "USERINPUT %1", ret );

	if( ret == `abort && Popup::ReallyAbort(true) )
	    return `abort;

	if( contains( [ `lvm, `home, `btrfs, `encrypt ], ret ) )
	    {
	    val = (boolean) UI::QueryWidget(`id(ret), `Value);
	    if( AskOverwriteChanges() )
		{
		target_is = "SUGGESTION";
		StorageProposal::HandleCommonWidgets( ret );
		Storage::ResetOndiskTarget();
		Storage::AddMountPointsForWin(Storage::GetTargetMap());
		map prop = StorageProposal::get_inst_prop(Storage::GetTargetMap());
		if( !prop["ok"]:false )
		    {
		    Popup::Error( _("Impossible to create the requested proposal.") );
		    Storage::SetPartProposalMode( "impossible" );
		    }
		else
		    {
		    if( CouldNotDoSeparateHome( prop["target"]:$[] ))
			{
			string reason = _("Not enough space available to propose separate /home.");
			Popup::Error( reason );
			StorageProposal::SetProposalHome(false);
                        if( UI::WidgetExists(`id(`home)))
                            UI::ChangeWidget(`id(`home), `Value, false);
			}
		    targetMap = prop["target"]:$[];
		    Storage::SetPartProposalMode( "accept" );
		    Storage::SetPartProposalActive( true );
		    }
		Storage::SetPartMode( target_is );
		Storage::SetTargetMap( targetMap );
		changes = Storage::ChangeText();
		UI::ChangeWidget(`id(`richtext), `Value, changes);
		}
	    else
		UI::ChangeWidget(`id(ret), `Value, !val);
	    }
	else if (contains([ `modify, `detailed, `import ], ret))
	    {
	    Storage::SetPartProposalFirst( false );
	    Storage::SetPartProposalActive( false );

	    switch (ret)
	    {
		case `modify:
		{
		target_is = "PROP_MODIFY";
		Storage::SetPartProposalMode( "modify" );
		}
		break;
		
		case `detailed:
		{
	        if( Storage::GetPartMode()!="CUSTOM" )
		    {
		    target_is = "NORMAL";
		    }
		else
		    {
		    target_is = "CUSTOM";
		    }
		Storage::SetPartDisk( "" );
		Storage::SetPartProposalMode( "detailed" );
		}
		break;

		case `import:
		{
		    target_is = "PROP_MODIFY";
		    Storage::SetPartProposalMode("modify");
		}
		break;
	    }

	    Storage::SetPartMode( target_is );
	    execSubscreens( ret );
	    changes = Storage::ChangeText();
	    UI::ChangeWidget(`id(`richtext), `Value, changes);
	    val = StorageProposal::GetProposalLvm();
	    UI::ChangeWidget(`id(`lvm), `Value, val );
	    UI::ChangeWidget(`id(`encrypt), `Enabled, val );
	    UI::ChangeWidget( `id(`encrypt), `Value, 
	                      val && StorageProposal::GetProposalEncrypt() );
	    UI::ChangeWidget(`id(`home), `Value, 
	                      StorageProposal::GetProposalHome() );
	    UI::ChangeWidget(`id(`btrfs), `Value, 
	                      StorageProposal::GetProposalBtrfs() );
	    }

	} until ( ret == `next || ret == `back || ret == `cancel );
    }
Storage::SaveExitKey( ret );

return ret;
}
