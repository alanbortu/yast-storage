/**
 * File:        ep-main.ycp
 * Package:     yast2-storage
 * Summary:     Expert Partitioner
 * Authors:     Arvin Schnell <aschnell@suse.de>
 */
{
    textdomain "storage";


    import "Mode";
    import "Stage";
    import "Label";
    import "Hostname";
    import "TabPanel";
    import "TreePanel";
    import "Popup";
    import "Storage";
    import "StorageFields";
    import "StorageSettings";
    import "Wizard";
    import "MiniWorkflow";
    import "Greasemonkey";
    import "Partitions";
    import "FileSystems";
    import "DevicesSelectionBox";
    import "Integer";
    import "String";
    import "Region";


    include "partitioning/lvm_ui_dialogs.ycp";
    include "partitioning/raid_lib.ycp";
    include "partitioning/custom_part_check_generated.ycp";


    void Debug(string text, any value)
    {
	return;

	import "ValueBrowser";
	UI::OpenDialog(`MinSize(50, 20,
				`VBox(
				    `Label(text),
				    `Tree(`opt(`hstretch, `vstretch), "&Variable",
					  [ ValueBrowser::BrowseTreeHelper(value, "") ]),
				    `PushButton (Label::OKButton())
				    )
			   )
	    );
	UI::UserInput();
	UI::CloseDialog();
    }


    void UpdateNavigationTree(any new_focus);


    void UpdateTableFocus(string device)
    {
	if (UI::WidgetExists(`id(`table)))
	    UI::ChangeWidget(`id(`table), `CurrentItem, device);
    }


    include "partitioning/icons.ycp";

    include "partitioning/ep-lib.ycp";
    include "partitioning/ep-dialogs.ycp";

    include "partitioning/ep-settings.ycp";
    include "partitioning/ep-log.ycp";

    include "partitioning/ep-all.ycp";
    include "partitioning/ep-hd.ycp";
    include "partitioning/ep-lvm.ycp";
    include "partitioning/ep-raid.ycp";
    include "partitioning/ep-loop.ycp";
    include "partitioning/ep-dm.ycp";
    include "partitioning/ep-nfs.ycp";
    include "partitioning/ep-unused.ycp";


    void MakeNavigationTree(map open_items, list<term>& tree, map<any, map>& data)
    {
	// TODO: somehow use AlwaysHideDisk

	data = $[ `all : $[ `create : CreateAllPanel ],
		  `hd : $[ `create : CreateHdMainPanel, `handle : HandleHdMainPanel ],
		  `lvm : $[ `create : CreateLvmMainPanel, `handle : HandleLvmMainPanel ],
		  `md : $[ `create : CreateRaidMainPanel, `handle : HandleRaidMainPanel ],
		  `loop : $[ `create : CreateLoopMainPanel, `handle : HandleLoopMainPanel ],
		  `dm : $[ `create : CreateDmMainPanel ],
		  `nfs : $[ `create : CreateNfsMainPanel, `handle : HandleNfsMainPanel ],
		  `unused : $[ `create : CreateUnusedPanel, `handle: HandleUnusedPanel ],
		  `settings : $[ `create : CreateSettingsPanel, `handle : HandleSettingsPanel, `destroy : DestroySettingsPanel ],
		  `log : $[ `create : CreateLogPanel, `handle : HandleLogPanel, `destroy : DestroyLogPanel ] ];

	map<symbol, list> subtree = $[];

	map<string, map> target_map = Storage::GetTargetMap();


	boolean open(any id)
	{
	    return open_items[id]:"" == "ID";
	}


	void huhu(map disk, symbol type, map a, map b)
	{
	    string disk_device = disk["device"]:"";

	    list<map> partitions = disk["partitions"]:[];
	    partitions = filter(map partition, partitions, {
		return !StorageFields::AlwaysHidePartition(target_map, disk, partition);
	    });

	    list<term> tmp = [];
	    foreach(map partition, partitions, {
		string part_device = partition["device"]:"";
		string part_displayname = StorageSettings::DisplayName(partition);
		tmp = add(tmp, `item(`id(part_device), part_displayname, open(part_device)));
		data = add(data, part_device, union(a, $[ `user_data : part_device ]));
	    });

	    if (b != nil)
	    {
		string disk_displayname = StorageSettings::DisplayName(disk);
		subtree[type] = add(subtree[type]:[], `item(`id(disk_device), disk_displayname, open(disk_device), tmp));
		data = add(data, disk_device, union(b, $[ `user_data : disk_device ]));
	    }
	    else
	    {
		subtree[type] = merge(subtree[type]:[], tmp);
	    }
	}


	void callback(map<string, map> target_map, map disk)
	{
	    symbol type = disk["type"]:`CT_UNKNOWN;

	    switch(type)
	    {
		case `CT_DISK:
		case `CT_DMRAID:
		case `CT_DMMULTIPATH:
		    huhu(disk, `hd, $[ `create : CreateHdPartitionPanel, `handle : HandleHdPartitionPanel ],
			 $[ `create : CreateHdDiskPanel, `handle : HandleHdDiskPanel ]);
		    break;
		case `CT_LVM:
		    huhu(disk, `lvm, $[ `create : CreateLvmLvPanel, `handle : HandleLvmLvPanel ],
			 $[ `create : CreateLvmVgPanel, `handle : HandleLvmVgPanel ]);
		    break;
		case `CT_MD:
		    huhu(disk, `md, $[ `create : CreateRaidPanel, `handle : HandleRaidPanel ], nil);
		    break;
		case `CT_LOOP:
		    huhu(disk, `loop, $[ `create : CreateLoopPanel, `handle : HandleLoopPanel ], nil);
		    break;
		case `CT_DM:
		    huhu(disk, `dm, $[ `create : CreateDmPanel, `handle : HandleDmPanel ], nil);
		    break;
		case `CT_NFS:
		    huhu(disk, `nfs, $[ `create : CreateNfsPanel, `handle: HandleNfsMainPanel ], nil);
		    break;
	    }
	}


	StorageFields::IterateTargetMap(target_map, callback);

	string short_hostname = Hostname::CurrentHostname();

	// TODO: same ordering as with IterateTargetMap
	tree = [ `item(`id(`all), `icon(all_icon), short_hostname, open(`all), [
			   // tree node label
			   `item(`id(`hd), `icon(hd_icon), _("Hard Disks"), open(`hd), subtree[`hd]:[]),
			   // tree node label
			   `item(`id(`md), `icon(raid_icon), _("RAID"), open(`md), subtree[`md]:[]),
			   // tree node label
			   `item(`id(`lvm), `icon(lvm_icon), _("Volume Management"), open(`lvm), subtree[`lvm]:[]),
			   // tree node label
			   `item(`id(`loop), `icon(loop_icon), _("Crypt Files"), open(`loop), subtree[`loop]:[]),
			   // tree node label
			   `item(`id(`dm), `icon(dm_icon), _("Device Mapper"), open(`dm), subtree[`dm]:[]),
			   // tree node label
			   `item(`id(`nfs), `icon(nfs_icon), _("NFS"), open(`nfs)),
			   // tree node label
			   `item(`id(`unused), `icon(unused_icon), _("Unused Devices"), open(`unused))
			   ]),
		 // tree node label
		 `item(`id(`settings), `icon(settings_icon), _("Settings"), open(`settings)) ];

	if (Mode::normal())
	    // tree node label
	    tree = add(tree, `item(`id(`log), `icon(log_icon), _("Log"), open(`log)));
    }


    void UpdateNavigationTree(any new_focus)
    {
	list<term> tree = [];
	map<any, map> data = $[];
	map open_items = (map) UI::QueryWidget(`id(`tree), `OpenItems);
	MakeNavigationTree(open_items, tree, data);
	TreePanel::Update(data, tree, new_focus);
    }


    /**
     * apply changes in running system
     */
    symbol DoApply()
    {
	symbol ret1 = ReallyInstPrepdisk();

	if (ret1 == `back)
	{
	    return `back;
	}
	else if (ret1 == `apply || ret1 == `finish)
	{
	    Wizard::CreateDialog();
	    Wizard::SetDesktopIcon("disk");
	    symbol ret2 = (symbol) WFM::CallFunction("inst_prepdisk", [true, true]);
	    StorageSettings::Save();
	    Wizard::CloseDialog();

	    Storage::CreateTargetBackup("expert-partitioner");

	    if (ret2 != `next)
		return `back;

	    if (ret1 == `apply)
		return `back;
	    else
		return `next;
	}
    }


    any ExpertPartitioner()
    {
	SCR::Write(.target.ycp, Storage::SaveDumpPath("targetmap-ep-start"), Storage::GetTargetMap());

	Storage::CreateTargetBackup("expert-partitioner");

	list<term> tree = [];
	map<any, map> data = $[];
	MakeNavigationTree($[`all : "ID"], tree, data);

	string back_label = Label::BackButton();
	string next_label = Label::AcceptButton();

	term contents = `MarginBox(0.5, 0.5,
				  `HBox(
				      `HWeight(30,
					       // tree node label
					       `Tree(`id(`tree), `opt(`notify), _("System View"), tree)
					  ),
				      `HWeight(70,
					       `ReplacePoint(`id(`tree_panel), TreePanel::empty_panel)
					  )
				      )
	    );

	// heading text
	Wizard::SetContentsButtons(_("Expert Partitioner"), contents, "", back_label, next_label);

	TreePanel::Init(data);

	symbol widget = nil;

	repeat
	{
	    widget = (symbol) Wizard::UserInput();

	    TreePanel::Handle(widget);

	    switch (widget)
	    {
		case `back:
		case `abort: {
		    if (!Storage::EqualBackupStates("expert-partitioner", "", true))
		    {
			// popup text, %1 will be replaces with button text
			string text = sformat(_("You have changed the partitioning.
These changes are lost if you exit the main dialog with %1.
Really quit the main dialog?
"), deletechars(back_label, "&"));

			if (!Popup::YesNo(text))
			{
			    widget = `again;
			}
		    }
		} break;

		case `next: {
		    list<any> retval = check_created_partition_table(Storage::GetTargetMap(), true,
								     Stage::initial() && !Mode::repair());
		    Storage::SetTargetMap(retval[0]:$[]);

		    if (retval[1]:`next != `next)
		    {
			widget = `again;
		    }
		    else
		    {
			if (Mode::normal())
			{
			    if (DoApply() == `back)
				widget = `again;
			}
		    }
		} break;

		case `table: {
		    any citem = UI::QueryWidget(`id(`table), `CurrentItem);
		    TreePanel::SwitchToNew(citem);
		    UI::SetFocus(`tree);
		} break;
	    }
	}
	until (widget == `back || widget == `abort || widget == `next);

	TreePanel::Destroy();

	switch (widget)
	{
	    case `back:
	    case `abort:

		if (Storage::GetPartMode() == "NORMAL")
		    Storage::SetPartMode("CUSTOM");

		break;

	    case `next:

		if (!Storage::EqualBackupStates("expert-partitioner", "", true))
		{
		    Storage::SetPartMode("CUSTOM");
		    Storage::UpdateChangeTime();
		}

		break;
	}

	Storage::DisposeTargetBackup("expert-partitioner");

	return widget;
    }
}
