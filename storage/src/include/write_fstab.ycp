/**
 * File:
 *   write_fstab.ycp
 *
 * Module:
 *   Partitioning
 *
 * Summary:
 *   Write fstab and cryptotab defines
 *
 * Authors:
 *   Michael Hager <mike@suse.de>
 *   Johannes Buchhold <jbuch@suse.de>
 *
 * $Id$
 *
 *
 */
{
    import "Arch";
    import "Hotplug";
    import "StorageDevices";
    import "Storage";
    import "FileSystems";
    import "Partitions";
    import "Installation";
    import "AsciiFile";
    
    textdomain "storage";

    include "partitioning/partition_defines.ycp";

//-----------------------------------------------------
// convert partitions to fstab entries
// return map (might be empty)
global define onepartition2fstab (map part)
    ``{
    y2milestone( "part=%1", part );
    if (part["delete"]:false || 
	part["type"]:`unknown == `extended ||
	part["crypt_fs"]:false ||
	part["lvm_group"]:"" != "" ||
	part["raid_name"]:"" != "" ||
	part["fsid"]:0 == Partitions::fsid_prep_chrp_boot ||
	(part["fsid"]:0 == Partitions::fsid_lvm && is( part["nr"]:"", integer)) )
	{
	return $[];
	}

    string spec = part["device"]:""; 
    if( part["mountby"]:`device == `label && size(part["label"]:"")>0 )
	{
	spec = sformat("LABEL=%1", part["label"]:"" );
	}
    else if( part["mountby"]:`device == `uuid && size(part["uuid"]:"")>0 )
	{
	spec = sformat("UUID=%1", part["uuid"]:"" );
	}
    y2debug( "spec=%1", spec );
    string  mount_point = part["mount"]:"";
    integer fsid = part["fsid"]:0;

    symbol  used_fs = part["used_fs"]:`ext2;
    boolean format  = part["format"]:false;

    string  vfstype = "unknown";	// keep "unknown", used again below
    integer freq    = 0;
    integer passno  = 0;
    string  mntops  = part["fstopt"]:"defaults";

    if (fsid == Partitions::fsid_swap)
	{
	// Only use our new swap partition
	if (mount_point == "") return $[];
	vfstype = "swap";
	if( mntops == "defaults" )
	    {
	    mntops = "pri=42";
	    }
	passno = 0;
	}
    else if( fsid==Partitions::fsid_native || fsid==Partitions::fsid_lvm )
	{
	vfstype = FileSystems::GetMountString( used_fs, 
	                                       (format ? "ext2" : "auto"));

	freq = 1;
	if( mount_point == "/" )
	    {
	    passno = 1;
	    }
	else if( mount_point != "" )
	    {
	    passno = 2;
	    }
	else if( Mode::initial )
	    {
	    mount_point = "/data" + other_nr;
	    // Don't mount and fsck this filesystem during boot, its
	    // state is unknown.
	    mntops = "noauto,user";
	    vfstype = "auto";
	    freq = 0;
	    passno = 0;
	    other_nr = other_nr + 1;
	    y2milestone( "TT add MountPoint %1", mount_point );
	    }
	}
    else if( (Arch::i386||Arch::ia64||Arch::x86_64) && size(mount_point)>0 &&
             (used_fs==`fat32 || used_fs==`ntfs) &&
             contains(union(union(Partitions::fsid_dostypes, 
				  Partitions::fsid_ntfstypes),
			    Partitions::fsid_wintypes), fsid ))
	{
	freq = 0;
	passno = 0;
	string lower_point = tolower( mount_point );
	// extra symlink for star office (-> #8310)
	if( mntops == "defaults" )
	    {
	    mntops = "gid=users,umask=0002";
	    if( contains (Partitions::fsid_readonly, fsid))
		mntops = "ro," + mntops;
	    }
	if( lower_point != "" && mount_point != lower_point)
	    {
	    SCR::Execute(.target.symlink, mount_point, lower_point);
	    }
	if( contains (Partitions::fsid_dostypes, fsid))
	    {
	    vfstype = "auto";
	    }
	else if( contains (Partitions::fsid_ntfstypes, fsid))
	    {
	    vfstype = "ntfs";
	    }
	else if (contains (Partitions::fsid_wintypes, fsid))
	    {
	    vfstype = "vfat";
	    }
	}
    else if( (Arch::sparc || Arch::alpha) &&
	     contains (Partitions::fsid_skip, fsid))
	{
	return $[];		// skip "whole disk" partition
	}
    else
	{
	return $[];	        // unknown type
	}

    map ret = $[ "spec":spec, 
                 "mount":mount_point, 
		 "vfstype":vfstype,
                 "mntops":mntops, 
		 "freq":freq, 
		 "device":part["device"]:"", 
		 "passno":passno ];

    if( part["fstabline"]:0 != 0 )
	{
	ret["line"] = part["fstabline"]:0;
	}
    y2milestone( "ret=%1", ret );
    return( ret );
    };


//-----------------------------------------------------

// needs "map fstab" globally

global define void allpartitions2fstab( map fstab, list partitions ) 
    ``{
    foreach (`partition, partitions, 
	``{
	map fstabentry = onepartition2fstab(partition);

	if (size(fstabentry)>0 && size(fstabentry["mount"]:"")>0)
	    {
	    string mount_point = fstabentry["mount"]:"";
	    // mount_point not enough !! ( two swap mount points )!!
	    if( mount_point=="swap" )
		{
		mount_point = mount_point + fstabentry["spec"]:"";
		}
	    // add to map, key is mount point
	    fstab[mount_point] = fstabentry;
	    }
	});
    };


    //-----------------------------------------------------
    //
    // construct and write complete fstab
    // return: string foreign_primary
    //

global define void write_fstab( map targetMap, map zipdrives, list cddevices )
    ``{
    map tg = targetMap;
    if( !Mode::initial )
	{
	tg = AddFstabInfo( tg, true );
	}
    SCR::Write(.dumpto.tmp.targetMap_wfs, tg );
    map fstab = $[];
    list dellines = [];
    string dir = "";

    integer other_nr = 1;		// count other mounts

    foreach (`tdevice, `tdata, tg,
	``{
	list partitions = tdata["partitions"]:[];
	allpartitions2fstab (fstab, partitions);
	list delpart = filter( `p, partitions, 
			       ``( p["fstabline"]:0>0 &&
				   ( p["delete"]:false ||
				     p["crypt_fs"]:false ||
				     size(p["mount"]:"")==0 )));
	y2milestone( "partitions:%1", partitions );
	y2milestone( "delpart:%1", delpart );
	dellines = union( dellines, 
			  maplist( `p, delpart, ``(p["fstabline"]:0 )));
	});

    list fstablist = maplist (`k, `v, fstab, ``(v));
    fstab = $[];

    if( Mode::initial )
	{
	// proc
	fstab["/proc"] = $["spec":"proc", "mount":"/proc", "vfstype":"proc",
			   "mntops":"defaults", "freq":0, "passno":0];

	// usbdevfs added with noauto
	if (Hotplug::haveUSB)
	    {
	    fstab["/proc/bus/usb"] = $["spec":"usbdevfs", "mount":"/proc/bus/usb", 
				       "vfstype":"usbdevfs", "mntops":"noauto", 
				       "freq":0, "passno":0];
	    }

	// devpts
	fstab["/dev/pts"] = $["spec":"devpts", "mount":"/dev/pts", 
	                      "vfstype":"devpts", "mntops":"mode=0620,gid=5", 
			      "freq":0, "passno":0];
	fstablist = union( fstablist, maplist(`k, `v, fstab, ``(v)));
	fstab = $[];

	y2milestone( "zipdrives=%1", zipdrives );
	integer zipnum = 0;
	foreach (`tdevice, `tdata, zipdrives, 
	    ``{
	    string zfile = "";
	    if (zipnum > 0)
		zfile = "/zip" + zipnum;
	    else
		zfile = "/zip";

	    string media = "/media"+zfile;
	    //SCR::Execute(.target.mkdir, media);
	    if( Installation::destdir != "/" )
		{
		zfile = Installation::destdir + zfile;
		}
	    SCR::Execute(.target.symlink, media, zfile);

	    fstab[zfile] = $["spec":""+tdevice+"4", "mount":media, 
			     "vfstype":"auto", "mntops":"noauto,user", 
			     "freq":0, "passno":0];
	    zipnum = zipnum + 1;
	    });
	fstablist = union( fstablist, maplist (`k, `v, fstab, ``(v)));
	fstab = $[];

	// add all cd-drives to fstab
	// cddevices is a list of symlinked names starting with "/dev/"

	y2milestone( "cddevices=%1", cddevices );

	foreach (`cd, cddevices, ``{
	    y2milestone( "cd %1", cd );
	    // /dev/dvd -> /media/dvd, /dev/cdrom -> /media/cdrom, ...
	    string cdmount = "/" + substring(cd, 5);
	    string media = "/media"+cdmount;

	    if( Installation::destdir != "/" )
		{
		cdmount = Installation::destdir + cdmount;
		}
	    // symlink /xxx -> /media/xxx
	    y2milestone( "symlink media %1 cdmount %2", media, cdmount );
	    SCR::Execute(.target.symlink, media, cdmount);

	    fstab[cdmount] = $["spec":cd, "mount":media, "vfstype":"auto",
			  "mntops":"ro,noauto,user,exec", "freq":0, "passno":0];
	    if( Storage::SaneConsoleEncoding() != "iso8859-1" )
		{
		fstab[cdmount,"mntops"] = fstab[cdmount,"mntops"]:"" +
		                          ",iocharset=" + 
					  Storage::SaneConsoleEncoding();
		}
	    });
	fstablist = union( fstablist, maplist (`k, `v, fstab, ``(v)));
	fstab = $[];

	// handle all drives with /dev/fdX

	y2milestone( "FloppyDrives=%1", StorageDevices::FloppyDrives );

	integer fdnum = 0;
	foreach (`drive, StorageDevices::FloppyDrives,
	    ``{
	    string dev_name = drive["dev_name"]:"";
	    if (find(dev_name, "/dev/fd")==0 )
		{
		string fdname = "/floppy";
		if (fdnum > 0)
		    fdname = fdname + fdnum;
		string medianame = "/media"+fdname;
                if( Installation::destdir != "/" )
		    {
		    fdname = Installation::destdir + fdname;
		    }
		SCR::Execute(.target.symlink, medianame, fdname);
		fstab[medianame] = $[ "spec":dev_name, "mount":medianame, 
				      "vfstype":"auto", 
				      "mntops":"noauto,user,sync", 
				      "freq":0, "passno":0 ];
		fdnum = fdnum + 1;
		}
	    });
	fstablist = union( fstablist, maplist (`k, `v, fstab, ``(v)));
	fstab = $[];
	}

    string tabpath = "/etc/fstab";
    if( Installation::destdir != "/" )
	{
	tabpath = Installation::destdir + tabpath;
	if( SCR::Read( .target.size, tabpath )>= 0 )
	    SCR::Execute( .target.remove, tabpath );
	}
    fstab = Partitions::GetFstab( tabpath );

    // fstab is sorted by mountpoint
    y2milestone( "dellist=%1", dellines );
    y2milestone( "fstablist=%1", fstablist );

    foreach( `entry, fstablist,
	``{
	list fstlist = [ entry["spec"]:"", entry["mount"]:"", 
	                 entry["vfstype"]:"", entry["mntops"]:"", 
			 sformat("%1",entry["freq"]:0),
			 sformat("%1",entry["passno"]:0) ];
	if( entry["line"]:0 > 0 )
	    {
	    map part = Storage::GetPartition( tg, entry["device"]:(entry["spec"]:"") );
	    if( part["format"]:false || 
	        (haskey(part,"ori_mountby") &&
	         part["mountby"]:`device!=part["ori_mountby"]:`device) ||
		(haskey(part,"ori_mount") && 
		 part["ori_mount"]:""!=part["mount"]:"") ||
		(haskey(part,"ori_fstopt") && 
	         part["ori_fstopt"]:""!=part["fstopt"]:"") ||
		(haskey(part,"ori_nr") &&
	         part["ori_nr"]:""!=part["nr"]:"") ||
	        (part["mountby"]:`device==`label && haskey(part,"ori_label") &&
		 part["ori_label"]:"" != part["label"]:""))
		{
		integer field = 0;
		while( field<4 )
		    {
		    AsciiFile::ChangeLineField( fstab, entry["line"]:0, field, 
		                                fstlist[field]:"" );
		    field = field+1;
		    }
		}
	    }
	else
	    {
	    AsciiFile::AppendLine( fstab, fstlist );
	    }
	dir = entry["mount"]:"";
	if( substring( dir, 0, 1 )== "/" )
	    {
	    if( Installation::destdir != "/" )
		dir = Installation::destdir + dir;
	    if( SCR::Read( .target.size, dir )<=0 )
		{
		SCR::Execute( .target.mkdir, dir );
		}
	    }
	});

    AsciiFile::RemoveLines( fstab, dellines );
    if( Installation::destdir != "/" )
	{
	dir = Installation::destdir + "/etc";
	if( SCR::Read( .target.size, dir )<=0 )
	    {
	    SCR::Execute( .target.mkdir, dir );
	    }
	}
    AsciiFile::RewriteFile( fstab, tabpath );

    write_cryptotab( tg );
    };


global define map onepartition2cryptotab( map partition )
    ``{
    string  partitionName = partition["device"]:"";
    string  mountPoint    = partition["mount"]:"";
    symbol  used_fs       = partition["used_fs"]:`unknown;
    boolean crypt_fs      = partition["crypt_fs"]:false;
    string  loop_dev      = partition["loop_dev"]:"";


    if( Mode::test && loop_dev == "")
	loop_dev = "/dev/loop1";

    if( partition["delete"]:false || 
	partition["type"]:`unknown == `extended ||
        !partition["crypt_fs"]:false ||
	mountPoint == "" || 
	mountPoint == "swap" )
	{
	return $[];
	}

    string used_fs_str = FileSystems::GetMountString( used_fs, "auto" );

    map ret = $[ "device"  : partitionName,
		 "loop"    : loop_dev,
		 "mount"   : mountPoint,
		 "vfstype" : used_fs_str,
		 "opt1"    : "twofish",
		 "opt2"    : partition["fsopts"]:"noatime" ];

    if( partition["crtabline"]:0 != 0 )
	{
	ret["line"] = part["crtabline"]:0;
	}
    y2milestone( "ret=%1" );
    return( ret );
    };


global define void write_cryptotab (map targets)
    ``{
    map crtab = $[];
    list dellines = [];
    list cryptotab = [];

    foreach( `targetdevice, `target, targets,
	``{
	list partitions = target["partitions"]:[];
	foreach (`partition, partitions,
	    ``{
	    map cryptotabentry = onepartition2cryptotab( partition );

	    if( size(cryptotabentry)>0 )
		{
		crtab[partition["mount"]:""] = cryptotabentry;
		}
	    });
	list delpart = filter( `p, partitions, 
			       ``( p["crtabline"]:0>0 &&
				   ( p["delete"]:false ||
				     !p["crypt_fs"]:false ||
				     size(p["mount"]:"")==0 )));
	dellines = union( dellines, maplist( `p, delpart, ``(p["crtabline"]:0 )));
	});

    list crtablist = maplist (`k, `v, crtab, ``(v));

    string tabpath = "/etc/cryptotab";
    if( Installation::destdir != "/" )
	{
	tabpath = Installation::destdir + tabpath;
	if( SCR::Read( .target.size, tabpath )>=0 )
	    SCR::Execute( .target.remove, tabpath );
	}
    crtab = Partitions::GetCrypto( tabpath );

    // crtab is sorted by mountpoint
    y2milestone( "dellist=%1", dellines );
    y2milestone( "crtablist=%1", crtablist );


    foreach( `entry, crtablist,
	``{
	list fstlist = [ entry["loop"]:"", entry["device"]:"", 
	                 entry["mount"]:"", entry["vfstype"]:"", 
			 entry["opt1"]:"", entry["opt2"]:"" ];
	if( entry["line"]:0 > 0 )
	    {
	    map part = Storage::GetPartition( tg, entry["device"]:"" );
	    if( part["format"]:false ||
		(haskey(part,"ori_mount") && 
		 part["ori_mount"]:""!=part["mount"]:"") ||
		(haskey(part,"ori_fstopt") && 
	         part["ori_fstopt"]:""!=part["fstopt"]:"") ||
		(haskey(part,"ori_nr") &&
	         part["ori_nr"]:""!=part["nr"]:"") ||
	        (part["mountby"]:`device==`label && haskey(part,"ori_label") &&
		 part["ori_label"]:"" != part["label"]:""))
		{
		integer field = 0;
		while( field<6 )
		    {
		    AsciiFile::ChangeLineField( crtab, entry["line"]:0, field, 
						fstlist[field]:"" );
		    field = field+1;
		    }
		}
	    }
	else
	    {
	    AsciiFile::AppendLine( crtab, fstlist );
	    }
	string dir = entry["mount"]:"";
	if( substring( dir, 0, 1 )== "/" )
	    {
	    if( Installation::destdir != "/" )
		dir = Installation::destdir + dir;
	    if( SCR::Read( .target.size, dir )<=0 )
		{
		SCR::Execute( .target.mkdir, dir );
		}
	    }
	});

    AsciiFile::RemoveLines( crtab, dellines );
    AsciiFile::RewriteFile( crtab, tabpath );
    };

}	
