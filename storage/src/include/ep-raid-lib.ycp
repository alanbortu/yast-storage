/*
 * Copyright (c) 2012 Novell, Inc.
 *
 * All Rights Reserved.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as published
 * by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
 * more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, contact Novell, Inc.
 *
 * To contact Novell about this file by physical or electronic mail, you may
 * find current contact information at www.novell.com.
 */

/**
 * File:	ep-raid-lib.ycp
 * Package:	yast2-storage
 * Summary:	Expert Partitioner
 * Authors:	Arvin Schnell <aschnell@suse.de>
 *
 * This file must only be included in other Expert Partitioner files ("ep-*.ycp").
 */
{
    textdomain "storage";


    boolean AddDevices(integer raid_nr, list<string> devs)
    {
	boolean ret = true;

	foreach(string dev, devs, {
	    Storage::SetPartitionId(dev, Partitions::fsid_raid);
	    Storage::SetPartitionFormat(dev, false, `none);
	});
        if (!Storage::ExtendMd(raid_nr, devs))
            ret = false;

	return ret;
    }


    boolean RemoveDevices(integer raid_nr, list<string> devs)
    {
	boolean ret = true;

	foreach(string dev, devs, {
	    Storage::UnchangePartitionId(dev);
	    if (!Storage::ShrinkMd(raid_nr, [ dev ]))
		ret = false;
	});

	return ret;
    }

    boolean ReplaceDevices(integer raid_nr, list<string> devs)
    {
	boolean ret = true;

	foreach(string dev, devs, {
	    Storage::SetPartitionId(dev, Partitions::fsid_raid);
	    Storage::SetPartitionFormat(dev, false, `none);
	});
        if (!Storage::ReplaceMd(raid_nr, devs))
            ret = false;

	return ret;
    }


    void EpCreateRaid()
    {
	map<string, map> target_map = Storage::GetTargetMap();
	list<map> unused_devices = filter(map dev, get_possible_rds(target_map), { return !Storage::IsUsedBy(dev); });

	if (size(unused_devices) < 2)
	{
	    // error popup
	    Popup::Error(_("There are not enough suitable unused devices to create a RAID."));
	    return;
	}

	map<string, any> data = $[ "new" : true,
	                           "type" : `sw_raid,
				   "create" : true ];

	map r = Storage::NextMd();
	data["device"] = r["device"]:"";
	data["nr"] = r["nr"]:0;

	if (DlgCreateRaidNew(data))
	{
	    integer nr = data["nr"]:0;
	    symbol raid_type = tosymbol(data["raid_type"]:"raid0");

	    if (Storage::CreateMdWithDevs(nr, raid_type, []))
	    {
		list<string> devices = data["devices"]:[];
		AddDevices(nr, devices);

		integer chunk_size_k = data["chunk_size_k"]:4;
		Storage::ChangeMdChunk(nr, chunk_size_k);

		if( haskey( data, "parity_algorithm" ))
		    {
		    symbol parity_algorithm = data["parity_algorithm"]:`par_default;
		    Storage::ChangeMdParitySymbol(nr, parity_algorithm);
		    }

		Storage::ChangeVolumeProperties(data);

		UpdateMainStatus();
		UpdateNavigationTree(nil);
		TreePanel::Create();
		UpdateTableFocus(data["device"]:"error");
	    }
	}
    }


    void EpEditRaid(string device)
    {
	if (device == nil)
	{
	    // error popup
	    Popup::Error(_("No RAID selected."));
	    return;
	}

	map<string, map> target_map = Storage::GetTargetMap();
	map<string, any> data = Storage::GetPartition(target_map, device);

	if (Storage::IsUsedBy(data))
	{
	    // error popup, %1 is replaced by device name e.g. /dev/md1
	    Popup::Error(sformat(_("The RAID %1 is in use. It cannot be
edited. To edit %1, make sure it is not used."), device));
	    return;
	}

	if (DlgEditRaid(data))
	{
	    Storage::ChangeVolumeProperties(data);

	    UpdateMainStatus();
	    UpdateNavigationTree(nil);
	    TreePanel::Create();
	    UpdateTableFocus(device);
	}
    }


    void EpResizeRaid(string device)
    {
	if (device == nil)
	{
	    // error popup
	    Popup::Error(_("No RAID selected."));
	    return;
	}

	map<string, map> target_map = Storage::GetTargetMap();
	map<string, any> data = Storage::GetPartition(target_map, device);

	if (!data["create"]:false)
	{
	    // error popup, %1 is replaced by device name e.g. /dev/md1
	    Popup::Error(sformat(_("The RAID %1 is already created on disk. It cannot be
resized. To resize %1, remove it and create it again."), device));
	    return;
	}

	if (Storage::IsUsedBy(data))
	{
	    // error popup, %1 is replaced by device name e.g. /dev/md1
	    Popup::Error(sformat(_("The RAID %1 is in use. It cannot be
resized. To resize %1, make sure it is not used."), device));
	    return;
	}

	if (DlgResizeRaid(data))
	{
	    integer raid_nr = data["nr"]:0;

	    list<string> devices_new = data["devices_new"]:[];
            y2milestone( "devices_new:%1", devices_new );
	    if (size(devices_new) > 0 )
	    {
		ReplaceDevices(raid_nr, devices_new);
		UpdateMainStatus();
		UpdateNavigationTree(nil);
		TreePanel::Create();
	    }
	}
    }


    void EpDeleteRaid(string device)
    {
	if (device == nil)
	{
	    // error popup
	    Popup::Error(_("No RAID selected."));
	    return;
	}

	if (EpDeleteDevice(device))
	{
	    any new_focus = nil;
	    if (UI::QueryWidget(`tree, `CurrentItem) == device)
		new_focus = `md;

	    UpdateMainStatus();
	    UpdateNavigationTree(new_focus);
	    TreePanel::Create();
	}
    }
}
