/*
 *************************************************************
 *
 *     YaST2      SuSE Labs                        -o)
 *     --------------------                        /\\
 *                                                _\_v
 *           www.suse.de / www.suse.com
 * ----------------------------------------------------------
 *
 * Author:        Michael Hager <mike@suse.de>
 *
 * Description:   utility part. proposal
 *                slot handling
 *
 *************************************************************

 $Id$


*/
{
  import "Partitions";


  //////////////////////////////////////////////////////////////////////
  // get all the possible boot slots
  // ------------------------------------------------------------------
  //////////////////////////////////////////////////////////////////////

  global define get_boot_slot_list( list base_slots )
  ``{

      // todo: a free slot, which start_cyl +3 <1024 are also a start cyl!
      list boot_slots = filter( `slot, base_slots, ``(    (lookup( slot, "start_cyl", 0) + min_nb_boot_cyl) < 1024
							  && lookup( slot, "size", 1)    > Partitions::minimal_needed_bootsize ));

      list boot_slots_win        = filter( `slot, boot_slots, ``(    lookup( slot, "type", "") == "free"
								     || lookup( slot, "type", "") == "win_resize" ));
      list boot_slots_reuse      = filter( `slot, boot_slots, ``(    lookup( slot, "type", "") == "free"
								     || lookup( slot, "type", "") == "linux" ));
      list boot_slots_reuse_only = filter( `slot, boot_slots, ``(    lookup( slot, "type", "") == "linux" ));
      list boot_slots_free       = filter( `slot, boot_slots, ``(    lookup( slot, "type", "") == "free" ));

	      
      return ( $[ "use_free":boot_slots_free,  "use_win"    :boot_slots_win,
	     	  "reuse"   :boot_slots_reuse, "reuse_only" : boot_slots_reuse_only ] );
  };



  //////////////////////////////////////////////////////////////////////
  // get the slots from the partition list
  // ------------------------------------------------------------------
  // for further comment see:  see Step 2 in inst_part_proposal.ycp
  //////////////////////////////////////////////////////////////////////

  global define GetSlots( list    part_list,
                          integer start_cyl,
                          integer end_cyl,
                          integer cyl_size )
  ``{
      integer last_border = 0;  // first not "slotted" cylinder.
      list    slot_list    = [];

      last_border = start_cyl;

      // for every partition of this disk do ...
      foreach( `part, part_list, ``{

	  integer old_last_border = last_border;
          integer begin_of_part =  select(lookup(part, "region", []), 0,0);
          integer end_of_part   =  begin_of_part + select(lookup(part, "region", []), 1,1) - 1;

	  y2debug( "last_border %1, begin %2, end %3 ", last_border, begin_of_part, end_of_part );


          //////////////////////////////////////////////////////////////
          // is there a gap between partitions -> create free slot
          //////////////////////////////////////////////////////////////
          if ( last_border < begin_of_part )
          {
              // create freeslot
              // example: last = 1 begin = 10 -> free = 1..9     size = 10 - 1 * cylsize

              slot_list = add( slot_list, $[ "type"    :    "free",
                                           "dev"       :     dev,
                                           "end_cyl"   :     begin_of_part-1,
                                           "start_cyl" :     last_border,
                                           "size":       ((begin_of_part - last_border )*cyl_size) ]);
              last_border = begin_of_part;
          }


          //////////////////////////////////////////////////////////////
          // create the slot for the current partition
          //////////////////////////////////////////////////////////////
          if ( last_border == begin_of_part )
          {
              integer nr         = lookup(part, "nr", 0);
              string  type       = "other";
              integer psize      =  ((end_of_part - begin_of_part +1)*cyl_size);
              integer pstart     =  begin_of_part;
              integer win_length = -1;
              integer win_max_length = -1;
	      map     win_dat    = $[];

              integer fsid = lookup( part, "fsid", 0 );
              if ( Partitions::IsDosPartition( fsid ) )
              {
                  win_dat = Partitions::GetFreeSpace( get_device_name( dev, lookup( part, "nr", 0 )), psize );
                  if ( win_dat != nil  )
                  {
                      type       =  "win_resize";
                      psize      = lookup( win_dat, "linux_size", -1 );
                      win_length = PartedSizeToCly( tofloat(lookup(win_dat,"new_size", 0)), cyl_size );
                      win_max_length = PartedSizeToCly( tofloat(lookup(win_dat,"max_win_size", 0)), cyl_size );
                      pstart     = begin_of_part + win_length;
                  }
                  else
                  {
                      // error: to other -> not useable
                      y2error("Storage::GetFreeSpace -> nil from %1", get_device_name( dev, lookup( part, "nr", 0 )) );
                  }
              }
              if ( fsid == Partitions::fsid_native )       type =  "linux";
              if ( fsid == Partitions::fsid_swap )         type =  "swap";
              if ( fsid == Partitions::fsid_extended )     type =  "extended";
              if ( fsid == Partitions::fsid_extended_win ) type =  "extended";

              // for now, this auto mode does not handle raid/lvm

              map slot =  $[ "type"    :     type,
                           "dev"       :     dev,
                           "nr"        :     nr,
                           "end_cyl"   :     end_of_part,
                           "start_cyl" :     pstart,
                           "size"      :     psize ];

              if ( type == "win_resize" )
              {
                  slot = add( slot, "win_size",   lookup(win_dat,"new_size", 0));
                  slot = add( slot, "win_length", win_length);
		  slot = add( slot, "win_max_length", win_max_length );
              }
              slot_list = add( slot_list, slot );

              last_border = end_of_part +1;
          }

          if ( old_last_border > begin_of_part )
          {
              y2error( "Partition order ? %1 %2", last_border, begin_of_part );
	      y2error( "slot_list %1", slot_list);
	      y2error( "part_list %1", part_list);
          }
      });

      //////////////////////////////////////////////////////////////
      // is there a gap between partitions -> create free slot
      //////////////////////////////////////////////////////////////
      if ( last_border < end_cyl )
      {
          // create freeslot
          // example: last = 1 end = 10 -> free = 1..10     size = 10 - 1 +1 * cylsize

          slot_list = add( slot_list, $[ "type" :     "free",
                                       "dev"       :     dev,
                                       "end_cyl":       end_cyl,
                                       "start_cyl":     last_border,
                                       "size"   :       ((end_cyl - last_border +1)*cyl_size) ]);

      }

      return( slot_list );
  };



  //////////////////////////////////////////////////////////////////////
  // Look if there is a boot slot
  // type:: "p_or_l", "primary", "logical"

  global define HaveBootSlot( string type, integer curr_slotnb, string mode, map boot_slot_list )
  ``{
      // delete curr slot from boot slot if it is in there
      list slots = [];

      if ( mode == "use_free" )  slots = lookup( boot_slot_list, "use_free", []);
      if ( mode == "use_win" )   slots = lookup( boot_slot_list, "use_win", []);
      if ( mode == "reuse" )     slots = lookup( boot_slot_list, "reuse", []);

      if ( type == "reuse")
      {
	  type = "p_or_l";
	  slots = lookup( boot_slot_list, "reuse_only", []);
      }

      // y2debug( "Have bootSlots: %1, %2", slots, filter( `slot, slots, ``(curr_slotnb!= lookup( slot, "slotnb"))));
      
      if ( type == "p_or_l" )
      {
          return ( size( filter( `slot, slots, ``(curr_slotnb!= lookup( slot, "slotnb", -1) ))) > 0);
      }
      else
      {
          return ( size( filter( `slot, slots, ``( curr_slotnb!=lookup( slot, "slotnb", -1)
                                                   && (lookup( slot, "p_or_l", "") == type )))) > 0   );
      }
  };



  //////////////////////////////////////////////////////////////////////
  // search for the smallest boot slot

  global define GetBootSlot( string type, integer curr_slotnb, string mode, map boot_slot_list  )
  ``{
      // delete curr slot from boot slot if it is in there
      list slots = [];

      if ( mode == "use_free" )  slots = lookup( boot_slot_list, "use_free", []);
      if ( mode == "use_win" )   slots = lookup( boot_slot_list, "use_win", []);
      if ( mode == "reuse" )     slots = lookup( boot_slot_list, "reuse", []);

      if ( type == "reuse")
      {
	  type = "p_or_l";
	  slots = lookup( boot_slot_list, "reuse_only", []);
      }
      
      if ( type == "p_or_l" )
      {
          slots = filter( `slot, slots, ``(curr_slotnb!= lookup( slot, "slotnb", -1)   ));
      }
      else
      {
          slots = filter( `slot, slots, ``( curr_slotnb!= lookup( slot, "slotnb", -1)
                                            && (lookup( slot, "p_or_l", "") == type )));
      }


      slots = sort(`slot_x, `slot_y, slots, ``(lookup(slot_x, "size", 0) <= lookup(slot_y, "size", 0)));

      return( select( slots, 0, $[]));
  };

  
  
	  
}
