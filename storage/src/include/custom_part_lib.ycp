/*
 * Copyright (c) 2012 Novell, Inc.
 *
 * All Rights Reserved.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as published
 * by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
 * more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, contact Novell, Inc.
 *
 * To contact Novell about this file by physical or electronic mail, you may
 * find current contact information at www.novell.com.
 */

/*************************************************************
 *
 *     YaST2      SuSE Labs                        -o)
 *     --------------------                        /\\
 *                                                _\_v
 *           www.suse.de / www.suse.com
 * ----------------------------------------------------------
 *
 * Author:        Johannes Buchhold <jbuch@suse.de>
 *
 * Description:   lib
 *
 *
 *************************************************************
 *
 $Id$
 *
*/

{
  textdomain "storage";
  import "Mode";
  import "Arch";
  import "Partitions";
  import "Product";
  import "FileSystems";
  import "Greasemonkey";

  include "partitioning/partition_defines.ycp";


  /**
   * Check lvm mount points
   * @param mount mount point
   * @return boolean
   */
    boolean check_lvm_mount_points(string mount)
    {
	list<string> not_allowed_lvm_mount_points  = [ Partitions::BootMount() ];
	y2milestone("check lvm mount");
	if (contains(not_allowed_lvm_mount_points, mount))
        {
	    // error popup text
	    Popup::Error(sformat(_("You cannot use the mount point \"%1\" for LVM.\n"), Partitions::BootMount()));
	    return false;
	}
	return true;
    }


  /**
   * Check raid mount points
   * @param mount mount point
   * @return boolean
   **/
    boolean check_raid_mount_points(string mount)
    {
        list<string> not_allowed_raid_mount_points  = [];
	if (Arch::ppc() || Arch::s390())
	{
	    not_allowed_raid_mount_points = add(not_allowed_raid_mount_points, Partitions::BootMount());
	}
	y2milestone("check raid mount");
	if (contains( not_allowed_raid_mount_points, mount))
	{
	    // error popup text
	    Popup::Error(sformat(_("You cannot use the mount point %1 for RAID."), Partitions::BootMount()));
	    return false;
	}
	return true;
    }


  /**
   * Check if the noauto option is permitted for this mount point.
   * @param mount mount point
   * @return boolean
   **/
define boolean check_noauto_mount( string mount )
    ``{
    boolean ret = true;
    if( FileSystems::IsSystemMp( mount, true ) )
	{
        // error popup text
	ret = Popup::YesNo(
_("You have selected to not automatically mount at start-up a file system
that may contain files that the system needs to work properly.

This may cause problems.

Really do this?
"));
	y2milestone( "ret %1", ret );
	}
    return ret;
    };

  /**
   * Check crypted mount points and return true if the mount point is ok.
   * @param mount mount point
   * @param crypt_fs boolean
   * @return boolean
   **/
define boolean check_crypt_fs_mount_points( string mount, boolean crypt_fs )
    ``{
    if( crypt_fs && FileSystems::IsCryptMp( mount, false ))
	{
        // error popup text
	Popup::Error(
_("You have assigned an encrypted file system to a partition
with one of the following mount points: \"/\", \"/usr\", \"/boot\",
\/var\".  This is not possible. Change the mount point or use a
nonloopbacked file system.
"));
	    return false;
	}
    return true;
    };


    /**
     * Check all label and return true if the label is unique.
     * @param targetMap the TargetMap
     * @param part      partition to check
     * @return boolean
     **/
define boolean check_unique_label( map<string,map> targetMap, map part )
    ``{
    boolean unique = true;

    // check if the label is already in use
    foreach( string disk, map diskinfo, targetMap, ``{
	foreach( map p, diskinfo["partitions"]:[], ``{
	    if ( p["device"]:"" != part["device"]:"" )
		{
		// all valid partitions
		if ( p["label"]:"" == part["label"]:"" ) unique = false;
		}
	    });
	});
    return( unique );
    };

define boolean CheckFstabOptions( map part )
    ``{
    boolean ret = true;
    if( FileSystems::IsSystemMp( part["mount"]:"", true ) &&
        FileSystems::HasFstabOption( part, "user", false ) )
	{
        // error popup text
	ret = Popup::YesNo(
_("You have set a file system as mountable by users. The file system
may contain files that need to be executable.

This usually causes problems.

Really do this?
"));
	y2milestone( "system mp user ret %1", ret );
	}
    if( ret && part["noauto"]:false )
	{
	ret = check_noauto_mount( part["mount"]:"" ) && ret;
	}
    y2milestone( "CheckFstabOptions ret %1 part %2", ret, part );
    return( ret );
    }

    /**
     * Check all mount points and return true if the mount point is ok.
     * @param targetMap the TargetMap
     * @param mount mount point
     * @return boolean
     **/
    boolean check_mount_point(map<string,map> targetMap, string dev, map part)
    {
    string mount = part["mount"]:"";
    symbol used_fs = part["used_fs"]:`unknown;
    y2milestone( "check_mount_point part:%1", part );

    boolean allowed = true;

    list<string> not_allowed_system_mount_points = [ "/proc", "/sys",
	"/dev", "/mnt", "/var/adm/mnt", "/lost+found", "/lib", "/lib64",
	"/bin", "/etc", "/sbin" ];

    if (isempty(mount))
    {
	Popup::Error(_("Mount point must not be empty."));
	allowed = false;
    }
    else if (used_fs == `swap && mount != "swap")
    {
	allowed = false;
	// error popup
	Popup::Error(_("Swap devices must have swap as mount point."));
    }
    else if (used_fs != `swap && mount == "swap")
    {
	allowed = false;
	// error popup
	Popup::Error(_("Only swap devices may have swap as mount point."));
    }
    else if (mount != "swap") // || part["type"]:`unknown == `loop)
	{
	// check if the mount point is already in use
	foreach( string disk, map diskinfo, targetMap, ``{
	    foreach( map part, diskinfo["partitions"]:[], ``{
		if( part["device"]:"" != dev )
		    {
		    // all valid partitions
		    if ( part["mount"]:"" == mount ) allowed = false;
		    }
		});
	    });

	if (allowed == false) // && mount!="swap" )
	    {
	    // error popup text
	    Popup::Error(_("This mount point is already in use. Select a different one."));
	    }
	// check if a dos filesystem is used for system purposes
	else if( used_fs == `vfat &&
		 (mount == "/" || mount == "/usr" || mount == "/opt" ||
		  mount == "/var" || mount == "/home"))
	    {
	    allowed = false;
	    // error popup text
	    Popup::Error(_("FAT filesystem used for system mount point (/, /usr, /opt, /var, /home).\nThis is not possible."));
	    }
	// check if the mount countains chars making trouble
	else if( findfirstof( mount, " `'!\"%#" ) != nil )
	    {
	    allowed = false;
	    // error popup text
	    Popup::Error(_("Invalid character in mount point. Do not use \"`'!\"%#\" in a mount point."));
	    }

	// check if the mount point is a system mount point
	else if ( contains( not_allowed_system_mount_points , mount) )
	    {
	    allowed = false;
	    // error popup text
	    Popup::Error(_("You cannot use any of the following mount points:
/bin, /dev, /etc, /lib, /lib64, /lost+found, /mnt, /proc, /sbin, /sys,
/var/adm/mnt
"));
	    }
	else if ( substring( mount, 0, 1 ) != "/"  )
	    {
	    allowed = false;
	    // error popup text
	    Popup::Error(_("Your mount point must start with a \"/\" "));
	    }
	}
    else if( !part["format"]:false && part["detected_fs"]:`none != `swap )
	{
	allowed = false;
	}

    if( allowed )
	{
	allowed = CheckFstabOptions( part );
	}
    return allowed;
}


boolean
check_ok_fssize(integer size_k, map volume)
{
    boolean ret = true;

    symbol fs = volume["used_fs"]:`unknown;
    integer min_size_k = FileSystems::MinFsSizeK(fs);
    y2milestone("check_ok_fssize fs:%1 size_k:%2 min_size_k:%3", fs, size_k, min_size_k);

    if (size_k < min_size_k)
    {
	// warning message, %1 is replaced by fs name (e.g. Ext3)
	// %2 is prelaced by a size (e.g. 10 MB)
	Popup::Warning(sformat(_("Your partition is too small to use %1.
The minimum size for this file system is %2.
"), FileSystems::GetName(fs, ""), Storage::KByteToHumanString(min_size_k)));

	ret = false;
    }

    return ret;
}


    /**
     * Do all checks concerning mount points, uuid, volume labels and
     * fstab options
     * @param targetMap the TargetMap
     * @param mount mount point
     * @return map
     **/
define map CheckOkMount( string dev, map old, map<string,any> new )
    ``{
    y2milestone( "CheckOkMount old:%1 new:%2", old, new );
    map ret = $[];
    ret["ok"] = true;
    new["mount"] = UI::QueryWidget(`id(`mount_point), `Value);
    if( old["mount"]:"" != new["mount"]:"" )
	new["inactive"] = true;
    if( ret["ok"]:false )
	{
	boolean crypt_fs = false;
	if( !check_mount_point( Storage::GetTargetMap(), dev, new ))
	    {
	    ret["ok"] = false;
	    ret["field"] = `mount_point;
	    }
	if( UI::WidgetExists( `id(`crypt_fs) ))
	    {
	    crypt_fs = (boolean)UI::QueryWidget(`id(`crypt_fs), `Value );
	    }
	if( !check_crypt_fs_mount_points(new["mount"]:"", crypt_fs ))
	    {
	    ret["ok"] = false;
	    ret["field"] = `mount_point;
	    }
	if( new["noauto"]:false && !check_noauto_mount( new["mount"]:"" ))
	    {
	    ret["ok"] = false;
	    ret["field"] = `mount_point;
	    }
	if( new["type"]:`primary == `sw_raid )
	    {
	    if( !check_raid_mount_points(new["mount"]:""))
		{
		ret["ok"] = false;
		ret["field"] = `mount_point;
		}
	    }
	else if( new["type"]:`primary == `lvm )
	    {
	    if( !check_lvm_mount_points(new["mount"]:""))
		{
		ret["ok"] = false;
		ret["field"] = `mount_point;
		}
	    }
	if( !new["format"]:false && !crypt_fs &&
	    contains( [`unknown, `none], new["detected_fs"]:`unknown ))
	    {
	    // error popup text
	    Popup::Error(_("It is not allowed to assign a mount point
to a device with nonexistent or unknown file system."));
	    ret["ok"] = false;
	    ret["field"] = `mount_point;
	    }
	}
    if( !new["format"]:false )
	{
	new = filter(string key, any value, new, ``(key != "fs_options"));
	}
    y2milestone( "ret:%1 new:%2", ret, new );
    ret["map"] = new;
    return( ret );
    };

define boolean EmptyCryptPwdAllowed( map p )
    {
    boolean ret = p["format"]:false && 
	contains(union(FileSystems::tmp_m_points, FileSystems::swap_m_points), p["mount"]:"");
    ret = ret && Storage::IsPersistent( p );
    y2milestone( "EmptyCryptPwdAllowed ret:%1", ret );
    return( ret );
    }

define term SubvolPart( boolean can_do_subvol )
    {
    term subvol = `Empty();
    if( can_do_subvol )
	subvol = `FrameWithMarginBox("", `PushButton( `id(`subvol), `opt(`hstretch),
	                                              // button text 
						      _("Subvolume Handling")));
    return( Greasemonkey::Transform(subvol) );
    }

map<string,any> HandleSubvol( map<string,any> data )
    {
    map<string,any> ret = data;
    if( ret["mount"]:""=="/" )
	{
	y2milestone( "before HandleSubvol fs:%1", ret["used_fs"]:`unknown );
	y2milestone( "before HandleSubvol subvol:%1", ret["subvol"]:[] );
	if( ret["used_fs"]:`unknown==`btrfs )
	    {
	    if( ret["format"]:false )
		{
                ret = (map<string,any>)Storage::AddSubvolRoot( ret );
                y2milestone( "HandleSubvol AddSubvolRoot subvol:%1", ret["subvol"]:[] );
		}
	    else
		ret["subvol"] = filter( map s, ret["subvol"]:[],
		                        ``(!s["create"]:false&&!s["delete"]:false));
	    }
	else
	    ret["subvol"] = [];
	y2milestone( "after  HandleSubvol subvol:%1", ret["subvol"]:[] );
	}
    else
	ret["subvol"] = [];
    return( ret );
    }

map pkg_for_fs = $[
    `ext2 : [ "e2fsprogs" ],
    `ext3 : [ "e2fsprogs" ],
    `ext4 : [ "e2fsprogs" ],
    `btrfs : [ "btrfsprogs" ],
    `reiser : [ "reiserfs" ],
    `vfat : [ "dosfstools" ],
    `ntfs : [ "ntfsprogs" ],
    `jfs : [ "jfsutils" ],
    `xfs : [ "xfsprogs" ] ];

define map<string,any> HandleFsChanged( boolean init, map<string,any> new, 
                                        symbol old_fs, map file_systems )
    ``{
    boolean apply_change = true;
    list<string> not_used_mp = [];
    symbol used_fs = new["used_fs"]:`unknown;
    map selected_fs = file_systems[used_fs]:$[];
    y2milestone( "HandleFsChanged init:%1 used_fs:%2 old_fs:%3 new:%4",
                 init, used_fs, old_fs, new );

    if( !init && used_fs != old_fs )
	{
	y2milestone( "HandleFsChanged IsUnsupported:%1", 
	             FileSystems::IsUnsupported( used_fs ));
	if( FileSystems::IsUnsupported( new["used_fs"]:`unknown ))
	    {
	    // warning message, %1 is replaced by fs name (e.g. Ext3)
	    string message = sformat(_("
WARNING:

This file system is not supported in %1;.
It is completely untested and might not be well-integrated 
in the system.  Do not report bugs against this file system 
if it does not work properly or at all.

Really use this file system?
"), Product::name );

	    apply_change = Popup::YesNo(message);
	    }
	if( apply_change && !Stage::initial() )
	    {
	    if( size(pkg_for_fs[used_fs]:[])>0 )
		{
		boolean r = Package::InstallAll( pkg_for_fs[used_fs]:[] );
		y2milestone( "HandleFsChanged install %1 ret:%2", 
		             pkg_for_fs[used_fs]:[], r );
		if( !r )
		    apply_change = false;
		}
	    }
	if( !apply_change )
	    {
	    new["used_fs"] = old_fs;
	    UI::ChangeWidget(`id(`fs), `Value, old_fs );
	    }
	}

    if( apply_change && UI::WidgetExists( `id(`crypt_fs)) )
	{
	boolean cr = selected_fs[`crypt]:true && 
	             new["used_fs"]:`unknown!=`btrfs &&
		     !new["pool"]:false;
	y2milestone( "HandleFsChanged cr:%1", cr );

	UI::ChangeWidget( `id(`crypt_fs), `Enabled, cr );
	if( !cr )
	    {
	    y2milestone( "HandleFsChanged crypt set to false" );
	    UI::ChangeWidget(`id(`crypt_fs), `Value, false );
	    }
	}

    if( !init && apply_change && UI::WidgetExists( `id(`subvol_rp)) )
	{
	boolean sv = new["used_fs"]:`unknown==`btrfs;
	y2milestone( "HandleFsChanged sv:%1", sv );
	UI::ReplaceWidget( `id(`subvol_rp), SubvolPart(sv) );
	if( UI::WidgetExists( `id(`subvol)) )
	    UI::ChangeWidget( `id(`subvol), `Enabled, sv );
	}

    if( apply_change )
	{
	////////////////////////////////////////////////
	// switch between swap and other mountpoints
	string mount = (string)UI::QueryWidget( `id(`mount_point), `Value);
	new["mount"] = mount;
	if( used_fs == `swap )
	    {
	    not_used_mp = selected_fs[`mountpoints]:[];
	    if( mount != "swap" && (new["type"]:`primary!=`lvm || mount!=""))
		{
		new["mount"] = "swap";
		new["inactive"] = true;
		}
	    }
	else
	    {
	    not_used_mp =
		notUsedMountpoints( Storage::GetTargetMap(),
				    selected_fs[`mountpoints]:[] );
	    if( new["type"]:`primary == `lvm ||
		(new["type"]:`primary == `sw_raid&&
		 new["raid_type"]:"raid0"!="raid1") )
		{
		not_used_mp = filter( string mp, not_used_mp,
				      ``( mp != Partitions::BootMount() ));
		}
	    else if( new["type"]:`primary == `loop )
		{
		not_used_mp =
		    filter( string mp, not_used_mp,
			    ``(!contains(FileSystems::system_m_points(), mp)));
		}
	    if(mount == "swap")
		new["mount"] = "";
	    }
	// UI::ReplaceWidget(`id(`mount_dlg_rp), MountDlg( new, not_used_mp));
	UI::ChangeWidget( `id(`mount_point), `Value, new["mount"]:"" );
	if( !init )
	    UI::ChangeWidget( `id(`fstab_options), `Enabled, 
			      size(new["mount"]:"")>0 );
	if( UI::WidgetExists( `id(`fs_options) ))
	    UI::ChangeWidget(`id(`fs_options), `Enabled,
			     new["format"]:false && selected_fs[`options]:[]!=[] );
	string fstopt = FileSystems::DefaultFstabOptions( new );
	if( size(fstopt)>0 && size(new["fstopt"]:"")==0 )
	    new["fstopt"] = fstopt;
	if( !init )
	    {
	    new["fs_options"] = FileSystems::DefaultFormatOptions(new);
	    new["fstopt"] = fstopt;
	    y2milestone( "HandleFsChanged fstopt:%1 new[\"fstopt\"]:%2", 
			 fstopt, new["fstopt"]:"" );

	    integer max_len = FileSystems::LabelLength( used_fs );
	    if( size(new["label"]:"") > max_len )
		{
		new["label"] = substring( new["label"]:"", 0, max_len );
		}
	    symbol mountby = new["mountby"]:`device;
	    if( (mountby == `uuid && !FileSystems::MountUuid( used_fs )) ||
		(mountby == `label && !FileSystems::MountLabel( used_fs )) )
		{
		new["mountby"] = `device;
		}
	    if( !FileSystems::MountLabel( used_fs ) && size(new["label"]:"")>0 )
		{
		new["label"] = "";
		}
	    if( used_fs!=`btrfs )
		new["subvol"] = [];
	    }
	}
    y2milestone( "HandleFsChanged new %1", new );
    return( new );
    };


define map<string,any> HandlePartWidgetChanges( boolean init, any ret,
                                                map file_systems,
						map<string,any> old,
						map<string,any> new )
    {
    y2milestone( "HandlePartWidgetChanges init:%1 ret:%2 new:%3",
                 init, ret, new );
    symbol used_fs = new["used_fs"]:`unknown;
    map selected_fs = file_systems[used_fs]:$[];
    if( init && !isempty(old["mount"]:"") && old["ignore_fstab"]:false )
	UI::ChangeWidget( `id(`fstab_options), `Enabled, false);
    /////////////////////////////////////////////////////////
    // configure main dialog and modify map new
    if( !init && new["mount"]:"" != old["mount"]:"" )
	{
	if( Arch::ia64 () && new["mount"]:"" == Partitions::BootMount() )
	    {
	    new = filter(string key, any value, new, ``( key != "fstopt"));
	    }
	}
    if( !init && ret==`mount_point )
	{
	string mp = (string)UI::QueryWidget(`id(`mount_point), `Value);
	if( new["mount"]:""!=mp )
	    {
            string oldfst = FileSystems::DefaultFstabOptions(new);
	    new["mount"] = mp;
            string newfst = FileSystems::DefaultFstabOptions(new);
            if( oldfst!=newfst )
                {
                /* Default fstab options have changed, set new default, bnc#774499 */
                new["fstopt"] = newfst;
                }
	    new = HandleSubvol( new );
	    }
	if( UI::WidgetExists( `id(`fstab_options) ))
	    UI::ChangeWidget( `id(`fstab_options), `Enabled, !isempty(mp) );
	}
    if( (init && UI::WidgetExists( `id(`format))) ||
        ret == `do_format || ret == `do_not_format)
	{
	boolean format = UI::QueryWidget(`id(`format), `Value) == `do_format;

	boolean old_format = new["format"]:false;

	////////////////////////////////////////////////
	// format partition
	new["format"] = format;

	if( old_format != format )
	    {
	    symbol dfs = `unknown;
	    if( format )
		{
		dfs = (symbol)UI::QueryWidget(`id(`fs), `Value);
		}
	    else
		{
		if( new["detected_fs"]:`unknown != `unknown )
		    {
		    dfs = new["detected_fs"]:Partitions::DefaultFs();
		    }
		else
		    {
		    dfs = new["used_fs"]:Partitions::DefaultFs();
		    }
		UI::ChangeWidget( `id(`fs), `Value, dfs );
		}
	    map selected_fs = file_systems[dfs]:$[];
	    new["used_fs"] = dfs;
	    y2milestone( "HandlePartWidgetChanges used_fs %1", dfs );
	    if( new["used_fs"]:`unknown != old["used_fs"]:`unknown )
		new = HandleFsChanged( init, new, old["used_fs"]:`unknown,
		                       file_systems );
	    new = HandleSubvol( new );
	    if( format )
		{
		new["fs_options"] = FileSystems::DefaultFormatOptions(new);
		if( !contains( selected_fs[`alt_fsid]:[], new["fsid"]:0 ))
		    new["fsid"] = selected_fs[`fsid]:Partitions::fsid_native;
		}
	    else
		{
		if( haskey( new, "ori_fsid" ) )
		    {
		    new["fsid"] = new["ori_fsid"]:0;
		    }
		else
		    {
		    new["fsid"] = old["fsid"]:0;
		    }
		}
	    if( UI::WidgetExists( `id(`fsid_point) ))
		{
		if( size(selected_fs)>0 &&
		    new["fsid"]:0 != selected_fs[`fsid]:0 &&
		    !contains( selected_fs[`alt_fsid]:[], new["fsid"]:0 ))
		    {
		    UI::ChangeWidget( `id(`fsid_point), `Value,
				      selected_fs[`fsid_item]:"" );
		    }
		}
	    if( !format )
		{
		new["fs_options"] = $[];
		}
	    new["fstopt"] = FileSystems::DefaultFstabOptions( new );
	    }
	}
    if( init || ret == `fs )
	{
	symbol new_fs = used_fs;
	if( UI::WidgetExists( `id(`fs) ))
	    new_fs = (symbol)UI::QueryWidget(`id(`fs), `Value);
	if( init )
	    {
	    if( !new["format"]:false && new["detected_fs"]:`unknown != `unknown )
		new_fs = new["detected_fs"]:`unknown;
	    else if( new["fsid"]:0 == Partitions::fsid_gpt_boot )
		new_fs = `vfat;
	    if( used_fs != new_fs )
		UI::ChangeWidget(`id(`fs), `Value, new_fs );
	    }
	y2milestone( "HandlePartWidgetChanges init=%1 used_fs:%2 new_fs:%3",
	             init, used_fs, new_fs );
	if( init || used_fs != new_fs )
	    {
	    map selected_fs = file_systems[new_fs]:$[];
	    new["used_fs"] = new_fs;

	    new = HandleFsChanged( init, new, used_fs, file_systems );

	    if( !init )
		{
		if( !contains( selected_fs[`alt_fsid]:[], new["fsid"]:0 ))
		    new["fsid"] = selected_fs[`fsid]:Partitions::fsid_native;
		y2milestone( "HandlePartWidgetChanges fsid %1", new["fsid"]:0 );
		if( UI::WidgetExists( `id(`fsid_point) ))
		    {
		    UI::ChangeWidget( `id(`fsid_point), `Value,
				      selected_fs[`fsid_item]:"");
		    }
		new = HandleSubvol( new );
		}
	    }
	}
    if( (init && UI::WidgetExists(`id(`fsid_point))) || ret == `fsid_point )
	{
	////////////////////////////////////////////////
	// modify map new
	string fs_string = (string) UI::QueryWidget(`id(`fsid_point), `Value);
	y2milestone("HandlePartWidgetChanges fs_string:%1", fs_string );
	integer fs_int = FileSystems::FindFsid(fs_string);
	integer old_id = new["fsid"]:0;
	y2milestone( "HandlePartWidgetChanges fs_int:%1 old_id:%2", fs_int, old_id );
	if (fs_int != nil && fs_int != old_id)
	    {
	    new["fsid"] = fs_int;
	    boolean no_fs = contains( [ Partitions::fsid_lvm,
	                                Partitions::fsid_raid,
					Partitions::fsid_hibernation,
					Partitions::fsid_bios_grub,
					Partitions::fsid_prep_chrp_boot ],
				      fs_int );

	    UI::ChangeWidget( `id(`fstab_options), `Enabled, !no_fs );
	    UI::ChangeWidget( `id(`do_format), `Enabled, !no_fs );
	    UI::ChangeWidget(`id(`do_mount_attachment), `Enabled, !no_fs);
	    UI::ChangeWidget(`id(`mount), `Enabled, !no_fs);
	    if( no_fs )
		{
		UI::ChangeWidget( `id(`do_not_mount), `Value, true);
		ChangeExistingSymbolsState( [ `fs_options, `fs ], false );
		ChangeExistingSymbolsState( [ `crypt_fs ], (fs_int==Partitions::fsid_lvm) );
		}
	    else if( fs_int == Partitions::fsid_native )
		{
		new["used_fs"] = Partitions::DefaultFs();
		UI::ChangeWidget( `id(`fs), `Value, new["used_fs"]:`unknown );
		new = HandleFsChanged( init, new, Partitions::DefaultFs(),
		                       file_systems );
		}
	    else if( fs_int == Partitions::fsid_swap )
		{
		new["used_fs"] = `swap;
		UI::ChangeWidget( `id(`fs), `Value, new["used_fs"]:`unknown );
		new = HandleFsChanged( init, new, `swap, file_systems );
		}
	    else if( contains( Partitions::fsid_wintypes, fs_int ) ||
	             fs_int==Partitions::fsid_gpt_boot )
		{
		new["mount"] = "";
		new["used_fs"] = `vfat;
		UI::ChangeWidget( `id(`fs), `Value, new["used_fs"]:`unknown );
		new = HandleFsChanged( init, new, `vfat, file_systems );
		}
	    else if( fs_int == Partitions::fsid_mac_hfs )
		{
		new["mount"] = "";
		new["used_fs"] = `hfs;
		UI::ChangeWidget( `id(`fs), `Value, new["used_fs"]:`unknown );
		new = HandleFsChanged( init, new, `hfs, file_systems );
		}
	    }
	}
    if( ret == `fstab_options )
	{
	new = FstabOptions( old, new );
	}
    if( ret == `subvol )
	{
	new = SubvolHandling( old, new );
	}
    if( ret == `crypt_fs )
	{
	boolean val = (boolean)UI::QueryWidget( `id(`crypt_fs), `Value );
	new["enc_type"] = val?(new["format"]:false?`luks:`twofish):`none;
	if( val )
	    {
	    new["mountby"] = `device;
	    new["label"] = "";
	    new["ori_label"] = "";
	    if( !Stage::initial() )
		Package::InstallAll( ["cryptsetup", "cryptsetup-mkinitrd", "pam_mount"] );
	    }
	else
	    {
	    new = remove( new, "mountby" );
	    }
	}
    if( ret == `fs_options )
	{
	new["fs_options"] = FileSystemOptions( new["fs_options"]:$[],
	                                       selected_fs );
	}
    if( Mode::repair () )
        {
	UI::ChangeWidget(`id(`do_mount), `Enabled, false);
	UI::ChangeWidget(`id(`do_not_mount), `Enabled, false);
	UI::ChangeWidget(`id(`do_mount_attachment), `Enabled, false);
        UI::ChangeWidget(`id(`fstab_options), `Enabled, false);
        UI::ChangeWidget(`id(`crypt_fs) ,     `Enabled, false);
        }
    y2milestone( "HandlePartWidgetChanges old:%1", old );
    y2milestone( "HandlePartWidgetChanges new:%1", new );
    return( new );
    }


boolean TryUmount(string device, string text, boolean allow_ignore)
{
    while (true)
    {
	string mountpoint = Storage::DeviceMounted(device);
	if (isempty(mountpoint))
	    return true;

	if (allow_ignore)
	{
	    string full_text = sformat(_("The file system is currently mounted on %1."), mountpoint) + "\n\n" +
		_("You can try to unmount it now, continue without unmounting or cancel.
Click Cancel unless you know exactly what you are doing.");

	    symbol ret = Popup::AnyQuestion3(Label::WarningMsg(), full_text,
					     Label::ContinueButton(),
					     Label::CancelButton(),
					     // button text
					     _("Unmount"),
					     `focus_no);

	    if (ret == `no)
		return false;

	    if (ret == `yes)
		return true;
	}
	else
	{
	    string full_text = sformat(_("The file system is currently mounted on %1."), mountpoint) + "\n\n" +
		_("You can try to unmount it now or cancel.
Click Cancel unless you know exactly what you are doing.");

	    boolean ret = Popup::AnyQuestion(Label::WarningMsg(), full_text,
					     // button text
					     _("Unmount"),
					     Label::CancelButton(), `focus_no);

	    if (ret == false)
		return false;
	}

	if (Storage::Umount(device,true))
	    return true;
    }
}


boolean CheckResizePossible(string device, boolean ask, boolean lvm, integer resize,
			    symbol fsys)
{
    map<string, boolean> poss = FileSystems::IsResizable(fsys);
    string mountpoint = Storage::DeviceMounted(device);

    boolean ret = true;

    y2milestone("CheckResizePossible device:%1 ask:%2 lvm:%3 resize:%4 fsys:%5",
		device, ask, lvm, resize, fsys);

    if( !isempty(mountpoint) && !Stage::initial() && resize < 0 &&
        !poss["mount_shrink"]:false && poss["shrink"]:false )
        {
	if (!TryUmount(device, _("It is not possible to shrink the file system while it is mounted."), true))
	    ret = false;
	}
    else if( !isempty(mountpoint) && !Stage::initial() && resize > 0 &&
             !poss["mount_extend"]:false && poss["extend"]:false )
        {
	if (!TryUmount(device, _("It is not possible to extend the file system while it is mounted."), true))
	    ret = false;
	}
    else if( !isempty(mountpoint) && !Stage::initial() && resize != 0 && !lvm )
        {
	if (!TryUmount(device, _("It is not possible to resize the file system while it is mounted."), true))
	    ret = false;
	}
    else if( resize < 0 && !poss["shrink"]:false )
	{
	ret = FsysCannotShrinkPopup( ask, lvm );
	}
    else if( resize < 0 && fsys==`reiser )
	{
	ret = FsysShrinkReiserWarning( lvm );
	}
    else if( resize>0 && !poss["extend"]:false )
	{
	ret = FsysCannotGrowPopup( ask, lvm );
	}
    y2milestone( "ret %1", ret );
    return ret;
}

}
