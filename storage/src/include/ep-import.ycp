/**
 * File:	ep-import.ycp
 * Package:	yast2-storage
 * Summary:	Expert Partitioner
 * Authors:	Michael Hager <mike@suse.de>
 *		Johannes Buchhold <jbuch@suse.de>
 *		Arvin Schnell <aschnell@suse.de>
 *
 * This file must only be included in other Expert Partitioner files ("ep-*.ycp").
 */
{
    textdomain "storage";


    /**
     * Find and read fstab by installation. Scan existing partitions.
     * @parm targetMap all targets
     * @parm search_point mount point where partitions can be mounted
     * @return list list with fstab data found
     */
    list<list> findExistingFstab(map<string, map> targetMap, string search_point)
    {
    /////////////////////////////////////////////////////////////////
    // foreach partition on each target
    list<list> fstab = [];
    list<symbol> skip_fs = [ `unknown, `swap, `vfat, `ntfs ];

    foreach( string dev, map disk, targetMap,
	``{
	foreach( map part,
	         filter( map p, disk["partitions"]:[],
				``(!contains( skip_fs,
				              p["detected_fs"]:`unknown) )),
	    ``{
	    /////////////////////////////////////////////////////
	    // try to mount
	    boolean mount_success = Storage::Mount( part["device"]:"",
	                                            search_point );

	    if( mount_success &&
		SCR::Read(.target.size, search_point+"/etc/fstab") > 0 )
		{
		list<map> tmp =
		    (list<map>)Storage::ReadFstab( search_point+"/etc" );
		y2milestone( "findExistingFstab fstab %1", tmp );
		if( size(tmp)>0 )
		    {
		    if( find( map p, tmp, ``(p["size_k"]:0==0 ))!=nil )
			{
			string vardev = "";
			map var = find( map p, tmp, ``(p["mount"]:""=="/var"));
			map root = find( map p, tmp, ``(p["mount"]:""=="/"));
			y2milestone( "findExistingFstab var %1", var );
			if( var != nil )
			    {
			    vardev = mountVar( var, root, part["device"]:"",
			                       search_point+"/var", targetMap );
			    y2milestone( "findExistingFstab vardev %1",
			                 vardev );
			    }
			map dmap = Storage::BuildDiskmap( $[] );
			if( size(dmap)>0 )
			    {
			    y2milestone( "findExistingFstab dmap %1", dmap );
			    y2milestone( "findExistingFstab tmp %1", tmp );
			    tmp = maplist( map p, tmp,
				``{
				if( p["size_k"]:0 == 0 )
				    p["device"] = Storage::HdDiskMap( p["device"]:"", dmap );
				return( p );
				});
			    y2milestone( "findExistingFstab tmp %1", tmp );
			    }
			integer s = size(tmp);
			tmp = filter( map p, tmp, ``(Storage::CanEdit(p,false)));
			if( s!=size(tmp) )
			    y2milestone( "findExistingFstab tmp %1", tmp );
			if( size(vardev)>0 )
			    Storage::Umount( vardev );
			}
		    fstab = add( fstab, tmp );
		    }
		}

	    /////////////////////////////////////////////////////
	    // unmount
	    if( mount_success )
		Storage::Umount( part["device"]:"" );
	    });
	});
    y2milestone( "findExistingFstab count_fstab_found %1", size(fstab) );
    y2milestone( "findExistingFstab fstab %1", fstab );
    return fstab;
    }


    /**
     * Scan and Read and return fstab.
     * @parm targetMap all targets
     * @parm file_systems filesystem map
     * @return list list with fstab
     */
    list<list> scanAndReadExistingFstab(map<string, map> targetMap)
    {
    string search_point = "/mnt";

    if( SCR::Execute(.target.bash, "/usr/bin/test -d " + search_point ) != 0)
	{
	SCR::Execute(.target.mkdir, search_point );
	}

    list<list> fstab = findExistingFstab( targetMap, search_point );

    return fstab;
    }


    /**
     * Merge readed list fstab with targetMap
     * @parm targetMap all targets
     * @parm fstab readed fstab list
     * @return return ( [ targetMap, table_input ]
     *
     */
    list AddFstabToData(map<string, map> targetMap, list<map> fstab, boolean format_sys)
    {
    if( fstab == nil )
	return [ targetMap ];

    y2milestone( "AddFstabToData fstab:%1", fstab );

    map new_targetMap = targetMap;
    map table_input = $["tbl":[]];

    foreach( string dev, map disk, targetMap,
	``{
	list new_partitions = [];
	map target = disk;
	foreach( map partition, disk["partitions"]:[],
	    ``{
	    map new_partition = partition;

	    string device = partition["device"]:"";

	    foreach( map fstab_entry, fstab,
		``{
		string dev_fstab   = fstab_entry["device"]:"";
		string mount_fstab = fstab_entry["mount"]:"";

		if (dev_fstab == device && !Storage::IsInstallationSource(device))
		{
		    new_partition["mount"] = mount_fstab;
		    if (format_sys && FileSystems::IsSystemMp(mount_fstab, false))
			new_partition["format"] = true;
		    if( !isempty(fstab_entry["fstopt"]:"") &&
			fstab_entry["fstopt"]:"" != "default" )
			{
			new_partition["fstopt"] = fstab_entry["fstopt"]:"";
			}
		    if( fstab_entry["mountby"]:`device != `device )
			new_partition["mountby"] = fstab_entry["mountby"]:`device;
		    if( fstab_entry["enc_type"]:`none != `none )
			new_partition["enc_type"] = fstab_entry["enc_type"]:`none;

		    /////////////////////////////////////////////
		    // entries for table
		    if( mount_fstab=="/" )
			{
			table_input["root"] = dev_fstab;
			}
		    table_input["tbl"] = add(table_input["tbl"]:[],
					     `item(`id(dev_fstab), dev_fstab, mount_fstab));
		    }
		});
	    new_partitions = add( new_partitions, new_partition);
	    });
	target["partitions"] = new_partitions;
	new_targetMap[dev] = target;
	});

    y2milestone( "AddFstabToData table_input:%1", table_input );
    y2milestone( "AddFstabToData tbl:%1", table_input["tbl"]:[] );

    if( size( table_input["tbl"]:[] )>1 )
	{
	table_input["tbl"] = sort( term a, term b, table_input["tbl"]:[],
	                           ``(a[2]:""<b[2]:""));
	}
    y2milestone( "AddFstabToData ret:%1", [ new_targetMap, table_input ] );

    return [ new_targetMap, table_input ];
    }


    /**
     * Scan exiting partitions for fstab files and if one found read the mountpoints
     * from the fstab file and build a new targetMap.
     * Ask the user if he like to use the new or old targetMap
     * (with or without found mountpoints)
     *------------------------------------
     * @parm targetMap all targets
     * @parm installation !!
     * @parm file_systems  filesystems definition map
     * @return targetMap new or unmodified targetMap
     *---------------------------------------------------------------------
     */
    integer FstabAddDialog(list table_input, boolean& format_sys)
    {
    y2milestone( "FstabAddDialog start %1", table_input );
    if( table_input == [] || table_input == nil )
	{
	// popup text
	Popup::Message(_("No previous system with mount points was detected."));
	return -1;
	}

    // heading text
    term header = `header(_("Device"), _("Mount Point"));

    // help text, richtext format
    string help_text = _("<P><B><BIG>Attention:</BIG></B><BR>YaST2 has scanned your hard disks and found an old Linux system
with mount points. On the right, see a list with the mount points found. </P>
")+
    // help text, richtext format
_("<P>To use these mount points, <BR>press <B>Yes</B>.</P>")+
    // help text, richtext format
_("<P>To ignore these mount points, <BR> press <B>No</B>.</P>");

    UI::OpenDialog(
	`opt(`decorated),
	    `VBox( `VSpacing(1),
		   `ReplacePoint( `id(`heading), `Empty() ),
		   `HBox(
		       `HSpacing(3.0),
		       `VSpacing(8),
		       `VBox( `VSpacing(1),
			      `Table(`id(`table), `opt(`keepSorting), header, [])
			    ),
		       `HSpacing(3.0)
		       ),
		   `ReplacePoint(`id(`select), `Empty()),
		   `VSpacing(1),
		   `Left(`CheckBox(`id(`format_sys), _("Format system volumes"), true)),
		   `VSpacing(1),
		   // popup text
		   `Heading(_("Would you like to use these mount points
for your new installation?")),
		   `VSpacing(1),
		   `ButtonBox(
		       `PushButton(`id(`help), `opt(`helpButton), Label::HelpButton()),
		       `PushButton(`id(`ok), `opt(`default), Label::YesButton()),
		       `PushButton(`id(`cancel), Label::NoButton())
		       )
		 )
	     );

    UI::ChangeWidget(`help, `HelpText, help_text);

    if (size(table_input) > 1)
    {
	UI::ReplaceWidget(`id(`select), `HBox(
			      `PushButton(`id(`show_prev), _("Show &Previous")),
			      `PushButton(`id(`show_next), _("Show &Next"))
			      ));
    }

    symbol userinput = `none;
    integer idx = 0;
    repeat
	{
	// popup text %1 is replaced by a device name (e.g. /dev/hda1)
	string tmp = sformat(
_("A previous system with the following mount points was detected:
/etc/fstab found on %1"), table_input[idx,"root"]:"/dev/emil" );
	UI::ReplaceWidget( `id(`heading), `Heading( tmp ) );

	UI::ChangeWidget(`id(`table), `Items, table_input[idx, "tbl"]:[]);
	UI::ChangeWidget(`id(`table), `CurrentItem, nil);

	if (size(table_input) > 1)
	{
	    UI::ChangeWidget(`id(`show_prev), `Enabled, idx > 0);
	    UI::ChangeWidget(`id(`show_next), `Enabled, idx < size(table_input) - 1);
	}

	userinput = (symbol) UI::UserInput();
	y2milestone("userinput %1", userinput);

	switch (userinput)
	{
	    case `show_next:
		idx = idx + 1;
		break;

	    case `show_prev:
		idx = idx - 1;
		break;
	}
	y2milestone( "idx %1", idx );
	}
    until( userinput == `ok || userinput == `cancel );

    format_sys = (boolean) UI::QueryWidget(`id(`format_sys), `Value);

    UI::CloseDialog();

    integer ret = userinput == `ok ? idx : -1;
    y2milestone( "ret %1", ret );
    return ret;
    }


    void ImportMountPoints()
    {
	Storage::CreateTargetBackup("import");
	Storage::ResetOndiskTarget();

	map<string, map> target_map = Storage::GetOndiskTarget();
	list<list> fstabs = scanAndReadExistingFstab(target_map);
	y2milestone("adapt_mp fstabs %1", fstabs);
	list ti = maplist(list fstab, fstabs, ``(AddFstabToData(target_map, (list<map>) fstab, false)[1]:$[]));
	y2milestone( "adapt_mp ti %1", ti );

	boolean format_sys = true;
	integer idx = FstabAddDialog(ti, format_sys);
	if( idx>=0 )
	{
	    y2milestone( "adapt_mp use fstab idx %1", idx );
	    list<map> fstab = (list<map>) fstabs[idx]:[];

	    ti = AddFstabToData(target_map, fstab, format_sys);
	    foreach( string d, map disk, ti[0]:$[],
		     ``{
			 foreach( map p, disk["partitions"]:[],
				  ``{
				      if( size(p["mount"]:"")>0 && p["enc_type"]:`none!=`none &&
					  !p["tmpcrypt"]:false )
				      {
					  string pwd = DlgCreateCryptFs( p["device"]:"", 1, false, false );
					  if( pwd != nil && size(pwd)>0 )
					      Storage::SetCryptPwd( p["device"]:"", pwd );
				      }
				  });
		     });

	    Storage::SetTargetMap(ti[0]:$[]);
	}
	else
	{
	    Storage::RestoreTargetBackup("import");
	}

	Storage::DisposeTargetBackup("import");
    }

}
