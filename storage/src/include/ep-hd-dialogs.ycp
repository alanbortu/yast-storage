/**
 * File:	ep-hd-dialogs.ycp
 * Package:	yast2-storage
 * Summary:	Expert Partitioner
 * Authors:	Arvin Schnell <aschnell@suse.de>
 */
{
    textdomain "storage";


    string MiniWorkflowStepPartitionTypeHelptext()
    {
	// helptext
	string helptext = _("<p>Choose the partition type for the new partition.</p>");

	return helptext;
    }


    symbol MiniWorkflowStepPartitionType(map<string, any> &data)
    {
	y2milestone("MiniWorkflowStepPartitionType data:%1", data);

	symbol type = data["type"]:`unknown;
	map slots = data["slots"]:$[];

	term tmp = `VBox();

	if (haskey(slots, `primary))
	    // radio button text
	    tmp = add(tmp, `LeftRadioButton(`id(`primary), _("&Primary Partition"), type == `primary));

	if (haskey(slots, `extended))
	    // radio button text
	    tmp = add(tmp, `LeftRadioButton(`id(`extended), _("&Extended Partition"), type == `extended));

	if (haskey(slots, `logical))
	    // radio button text
	    tmp = add(tmp, `LeftRadioButton(`id(`logical), _("&Logical Partition"), type == `logical));

	// heading for a frame in a dialog
	term contents = `HVSquash(
			    `FrameWithMarginBox(_("New Partition Type"),
				`RadioButtonGroup(`id(`partition_type), tmp)));

	MiniWorkflow::SetContents(Greasemonkey::Transform(contents), MiniWorkflowStepPartitionTypeHelptext());
	MiniWorkflow::SetLastStep(false);

	symbol widget = nil;

	repeat
	{
	    widget = MiniWorkflow::UserInput();

	    switch (widget)
	    {
		case `next:
		    type = (symbol) UI::QueryWidget(`id(`partition_type), `Value);
		    break;
	    }
	}
	until (widget == `abort || widget == `back || widget == `next);

	if (widget == `next)
	{
	    data["type"] = type;

	    map r = Storage::NextPartition(data["disk_device"]:"", data["type"]:`none);
	    data["device"] = r["device"]:"";

	    if (data["type"]:`unknown == `extended)
	    {
		data["fsid"] = Partitions::fsid_extended_win;
		data["used_fs"] = `unknown;
	    }
	}

	y2milestone("MiniWorkflowStepPartitionType data:%1 ret:%2", data, widget);

	return widget;
    }


    string MiniWorkflowStepPartitionSizeHelptext()
    {
	// helptext
	string helptext = _("<p>Choose the size for the new partition.</p>");

	return helptext;
    }


    symbol MiniWorkflowStepPartitionSize(map<string, any> &data)
    {
	y2milestone("MiniWorkflowStepPartitionSize data:%1", data);

	integer cyl_size = data["cyl_size"]:0;
	integer cyl_count = data["cyl_count"]:0;
	list< list<integer> > slots = data["slots", data["type"]:`unknown]:[];
	list<integer> slot = slots[0]:[];

	list<integer> region = data["region"]:slot;
	integer size_k = (region[1]:0 * cyl_size) / 1024;

	integer min_size_k = tointeger(float::ceil(cyl_size / 1024.0));
	integer max_size_k = (slot[1]:0 * cyl_size) / 1024;

	symbol what = (region == slot) ? `max_size : `manual_region;

	term contents = `HVSquash(
	    // frame heading
	    `FrameWithMarginBox(_("New Partition Size"),
		   `RadioButtonGroup(`id(`size),
				     `VBox(
					 `LeftRadioButton(`id(`max_size), `opt(`notify),
							  // radio button text, %1 is replaced by size
							  sformat(_("Maximum Size (%1)"), Storage::KByteToHumanString(max_size_k))),
					 // radio button text
					 `LeftRadioButtonWithAttachment(`id(`manual_size), `opt(`notify), _("Custom Size"),
									`VBox(`id(`manual_size_attachment),
									      `MinWidth(15, `InputField(`id(`size_input), 
													`opt(`shrinkable), _("Size")))
									    )),
					 // radio button text
					 `LeftRadioButtonWithAttachment(`id(`manual_region), `opt(`notify), _("Custom Region"),
									`VBox(`id(`manual_region_attachment),
									      `MinWidth(10, `IntField(`id(`start_cyl), _("Start Cylinder"),
												      1, cyl_count, Region::Start(region))),
									      `MinWidth(10, `IntField(`id(`end_cyl), _("End Cylinder"),
												      1, cyl_count, Region::End(region)))
									    ))
					 )
				)
		       ));

	MiniWorkflow::SetContents(Greasemonkey::Transform(contents), MiniWorkflowStepPartitionSizeHelptext());
	MiniWorkflow::SetLastStep(data["type"]:`unknown == `extended);

	UI::ChangeWidget(`id(`size), `Value, what);
	UI::ChangeWidget(`id(`manual_size_attachment), `Enabled, what == `manual_size);
	UI::ChangeWidget(`id(`size_input), `Value, Storage::KByteToHumanString(size_k));
	UI::ChangeWidget(`id(`manual_region_attachment), `Enabled, what == `manual_region);

	symbol widget = nil;

	repeat
	{
	    widget = MiniWorkflow::UserInput();

	    switch (widget)
	    {
		case `max_size:
		    UI::ChangeWidget(`id(`manual_size_attachment), `Enabled, false);
		    UI::ChangeWidget(`id(`manual_region_attachment), `Enabled, false);
		    break;

		case `manual_size:
		    UI::ChangeWidget(`id(`manual_size_attachment), `Enabled, true);
		    UI::ChangeWidget(`id(`manual_region_attachment), `Enabled, false);
		    break;

		case `manual_region:
		    UI::ChangeWidget(`id(`manual_size_attachment), `Enabled, false);
		    UI::ChangeWidget(`id(`manual_region_attachment), `Enabled, true);
		    break;

		case `next:
		    what = (symbol) UI::QueryWidget(`id(`size), `Value);

		    switch (what)
		    {
			case `manual_size:
			{
			    string tmp = (string) UI::QueryWidget(`id(`size_input), `Value);
			    if (!Storage::HumanStringToKByte(tmp, size_k))
			    {
				// error popup, %1 and %2 are replaced by sizes
				Popup::Error(sformat(_("The size entered is invalid. Enter a value like \"%1\" or \"%2\"."),
						     Storage::KByteToHumanString(500*1024),
						     Storage::KByteToHumanString(1024*1024)));
				widget = `again;
				continue;
			    }
			    else if (size_k < min_size_k || size_k > max_size_k)
			    {
				// error popup, %1 and %2 are replaced by sizes
				Popup::Error(sformat(_("The size entered is invalid. Enter a size between %1 and %2."),
						     Storage::KByteToHumanString(min_size_k),
						     Storage::KByteToHumanString(max_size_k)));
				widget = `again;
				continue;
			    }
			    break;
			}

			case `manual_region:
			{
			    integer s = (integer) UI::QueryWidget(`id(`start_cyl), `Value);
			    integer e = (integer) UI::QueryWidget(`id(`end_cyl), `Value);
			    region = [ s, e - s + 1 ];

			    boolean valid = Region::Length(region) > 0 && find(list<integer> slot, slots, {
				return Region::Inside(slot, region);
			    }) != nil;

			    if (!valid)
			    {
				// error popup
				Popup::Error(_("The region entered is invalid."));
				widget = `again;
				continue;
			    }

			    break;
			}
		    }

		    break;
	    }
	}
	until (widget == `abort || widget == `back || widget == `next);

	if (widget == `next)
	{
	    switch ((symbol) UI::QueryWidget(`id(`size), `Value))
	    {
		case `max_size:
		{
		    data["region"] = slot;
		    break;
		}

		case `manual_size:
		{
		    integer num_cyl = size_k * 1024 / cyl_size;
		    data["region"] = [ slot[0]:0, num_cyl ];
		    break;
		}

		case `manual_region:
		{
		    data["region"] = region;
		    break;
		}
	    }

	    data["size_k"] = Region::Length(data["region"]:[0, 0]) * cyl_size / 1024;

	    if (data["type"]:`unknown == `extended)
	    {
		widget = `finish;
	    }
	}

	y2milestone("MiniWorkflowStepPartitionSize data:%1 ret:%2", data, widget);

	return widget;
    }


    boolean DlgCreatePartition(map<string, any> &data)
    {
	map<string, any> aliases = $[
	    "Type"        : ``(MiniWorkflowStepPartitionType(data)),
	    "Size"        : ``(MiniWorkflowStepPartitionSize(data)),
	    "FormatMount" : ``(MiniWorkflowStepFormatMount(data)),
	    "Password"	  : ``(MiniWorkflowStepPassword(data))
	];

	map<string, any> sequence = $[
	    "Type"        : $[ `next : "Size" ],
	    "Size"        : $[ `next : "FormatMount",
			       `finish : `finish ],
	    "FormatMount" : $[ `next : "Password",
			       `finish : `finish ],
	    "Password"    : $[ `finish : `finish ]
	];

	map slots = data["slots"]:$[];

	if (haskey(slots, `primary))
	    data["type"] = `primary;
	else if (haskey(slots, `extended))
	    data["type"] = `extended;
	else if (haskey(slots, `logical))
	    data["type"] = `logical;

	string start = size(slots) == 1 ? "Size" : "Type";

	if (start == "Size")
	{
	    map r = Storage::NextPartition(data["disk_device"]:"", data["type"]:`none);
	    data["device"] = r["device"]:"";
	}

	// dialog title
	string title = sformat(_("Add Partition on %1"), data["disk_device"]:"error");

	symbol widget = MiniWorkflow::Run(title, hd_part_icon, aliases, sequence, start);

	return widget == `finish;
    }


    boolean DlgEditPartition(map<string, any> &data)
    {
	string device = data["device"]:"error";

	map<string, any> aliases = $[
	    "FormatMount" : ``(MiniWorkflowStepFormatMount(data)),
	    "Password"	  : ``(MiniWorkflowStepPassword(data))
	];

	map<string, any> sequence = $[
	    "FormatMount" : $[ `next : "Password",
			       `finish : `finish ],
	    "Password"    : $[ `finish : `finish ]
	];

	// dialog title
	string title = sformat(_("Edit Partition %1"), device);

	symbol widget = MiniWorkflow::Run(title, hd_part_icon, aliases, sequence, "FormatMount");

	return widget == `finish;
    }


    boolean DlgResizePartition(map<string, any> &data, map <string, any> disk)
    {
	return DlgResize(data, disk);
    }
}
