/**
 * File:	ep-hd-lib.ycp
 * Package:	yast2-storage
 * Summary:	Expert Partitioner
 * Authors:	Arvin Schnell <aschnell@suse.de>
 */
{
    textdomain "storage";

    import "Map";
    import "HTML";

    void EpCreatePartitionTable(string disk_device)
    {
	if (disk_device == nil)
	{
	    // error popup
	    Popup::Error(_("No hard disk selected."));
	    return;
	}

	map<string, map> target_map = Storage::GetTargetMap();
	map disk = target_map[disk_device]:$[];

	if (disk["used_by_device"]:"" != "")
	{
	    // error popup
	    Popup::Error(_("The disk is in use and cannot be modified."));
	    return;
	}

	string default_label = Storage::DefaultDiskLabel(target_map[disk_device, "size_k"]:0);

	list<string> labels = [ default_label ];
	if (!contains(labels, "gpt"))
	    labels = add(labels, "gpt");

	string label = default_label;
	if (size(labels) > 1)
	{
	    term tmp = list::reduce(term t, string l, `VBox(), labels, {
		return add(t, `LeftRadioButton(`id(l), toupper(l), l == default_label));
	    });

	    UI::OpenDialog(`opt(`decorated),
			   Greasemonkey::Transform(
			       `VBox(
				   // dialog heading
				   `Label(sformat(_("Select new partition table type for %1."), disk_device)),
				   `MarginBox(2, 0.4, `RadioButtonGroup(`id(`labels), tmp)),
				   `ButtonBox(
				       `PushButton(`id(`ok), `opt(`default), Label::OKButton()),
				       `PushButton(`id(`cancel), Label::CancelButton())
				       )
				   )
			       )
		);

	    symbol widget = (symbol) UI::UserInput();

	    label = (string) UI::QueryWidget(`id(`labels), `Value);

	    UI::CloseDialog();

	    if (widget != `ok)
		return;
	}

	// popup text, %1 is be replaced by disk name e.g. /dev/sda
	if (Popup::YesNo(sformat(_("Really create new partition table on %1? This will delete all data
on %1 and all RAIDs and Volume Groups using partitions on %1."), disk_device)))
	{
	    Storage::CreatePartitionTable(disk_device, label);

	    UpdateMainStatus();
	    UpdateNavigationTree(nil);
	    TreePanel::Create();
	}
    }


    void EpDeleteDisk(string device)
    {
	if (device == nil)
	{
	    // error popup
	    Popup::Error(_("No disk selected."));
	    return;
	}

	map<string, map> target_map = Storage::GetTargetMap();
	map<string, any> disk = Storage::GetDisk(target_map, device);

	if (disk["type"]:`CT_UNKNOWN == `CT_DMRAID)
	{
	    // popup text
	    if (Popup::YesNo(sformat(_("Really delete BIOS RAID %1?"), device)))
	    {
		if (deleteAllDevPartitions(disk, Stage::initial(), false))
		    Storage::DeleteDmraid(device);

		UpdateMainStatus();
		UpdateNavigationTree(`hd);
		TreePanel::Create();
	    }
	}
	else
	{
	    // error popup
	    Popup::Error(_("The disk cannot be deleted."));
	}
    }


    map<symbol, list> GetPossibleSlots(map disk, string disk_device)
    {
	list<map> slots = [];
	Storage::GetUnusedPartitionSlots(disk_device, slots);
	y2milestone("slots %1", slots);

	// individual sort primary, extended and logical slots

	map<symbol, list> ret = $[];
	list<map> tmp = [];

	tmp = filter(map slot, slots, { return slot["primary_possible"]:false; });
	tmp = sort(map a, map b, tmp, { return a["region", 1]:0 > b["region", 1]:0; });
	if (size(tmp) > 0)
	    ret[`primary] = maplist(map slot, tmp, { return slot["region"]:[]; });

	tmp = filter(map slot, slots, { return slot["extended_possible"]:false; });
	tmp = sort(map a, map b, tmp, { return a["region", 1]:0 > b["region", 1]:0; });
	if (size(tmp) > 0)
	    ret[`extended] = maplist(map slot, tmp, { return slot["region"]:[]; });

	tmp = filter(map slot, slots, { return slot["logical_possible"]:false; });
	tmp = sort(map a, map b, tmp, { return a["region", 1]:0 > b["region", 1]:0; });
	if (size(tmp) > 0)
	    ret[`logical] = maplist(map slot, tmp, { return slot["region"]:[]; });

	if (size(ret) == 0)
	{
	    // error popup
	    Popup::Error(sformat(_("It is not possible to create a partition on %1."), 
				 disk_device));
	}

	y2milestone("ret %1", ret);
	return ret;
    }


    /**
     * argument is device of hard disk
     */
    void EpCreatePartition(string disk_device)
    {
	if (disk_device == nil)
	{
	    // error popup
	    Popup::Error(_("No hard disk selected."));
	    return;
	}

	map<string, map> target_map = Storage::GetTargetMap();
	map disk = target_map[disk_device]:$[];

	if (disk["used_by_device"]:"" != "")
	{
	    // error popup
	    Popup::Error(_("The disk is in use and cannot be modified."));
	    return;
	}

	if (disk["readonly"]:false)
	{
	    Popup::Error(Partitions::RdonlyText(disk["device"]:"", true));
	    return;
	}

	map slots = GetPossibleSlots(disk, disk_device);

	if (size(slots) > 0)
	{
	    map<string, any> data = $[ "new" : true,
				       "create" : true,
				       "disk_device" : disk_device,
				       "cyl_size" : disk["cyl_size"]:0,
				       "cyl_count" : disk["cyl_count"]:0,
				       "slots" : slots ];

	    if (DlgCreatePartition(data))
	    {
		string device = data["device"]:"error";

		symbol mby = data["mountby"]:Storage::GetMountBy(device);
		Storage::CreatePartition(data["disk_device"]:"", device,
					 data["type"]:`primary,
					 data["fsid"]:Partitions::fsid_native,
					 data["region",0]:0, data["region",1]:0, mby);
		Storage::ChangeVolumeProperties(data);

		UpdateMainStatus();
		UpdateNavigationTree(nil);
		TreePanel::Create();
		UpdateTableFocus(device);
	    }
	}
    }


    void EpEditPartition(string device)
    {
	if (device == nil)
	{
	    // error popup
	    Popup::Error(_("No partition selected."));
	    return;
	}

	map<string, map> target_map = Storage::GetTargetMap();
	map<string, any> data = Storage::GetPartition(target_map, device);

	if (data["used_by"]:"" != "")
	{
	    // error popup, %1 is replace by partition device name e.g. /dev/sdb1
	    Popup::Error(sformat(_("The partition %1 is in use. It cannot be
edited. To edit %1, make sure it is not used."), device));
	    return;
	}

	if (data["type"]:`primary == `extended)
	{
	    // error popup text
	    Popup::Error(_("An extended partition cannot be edited."));
	    return;
	}

	if (DlgEditPartition(data))
	{
	    Storage::ChangeVolumeProperties(data);

	    UpdateMainStatus();
	    UpdateNavigationTree(nil);
	    TreePanel::Create();
	    UpdateTableFocus(device);
	}
    }


    void EpResizePartition(string device)
    {
	if (device == nil)
	{
	    // error popup
	    Popup::Error(_("No partition selected."));
	    return;
	}

	map<string, map> target_map = Storage::GetTargetMap();
	map<string, any> disk = Storage::GetDisk(target_map, device);
	map<string, any> data = Storage::GetPartition(target_map, device);

	if (disk["readonly"]:false)
	{
	    Popup::Error(Partitions::RdonlyText(disk["device"]:"", true));
	    return;
	}

	if (data["used_by"]:"" != "")
	{
	    // error popup, %1 is replace by partition device name, e.g. /dev/sdb1
	    Popup::Error(sformat(_("The partition %1 is in use. It cannot be
resized. To resize %1, make sure it is not used."), device));
	    return;
	}

	if (data["type"]:`primary == `extended)
	{
	    // error popup text
	    Popup::Error(_("An extended partition cannot be resized."));
	    return;
	}

	//Need to pass data on the whole disk, to determine free/available space
	if (DlgResizePartition(data, disk))
	{
	    Storage::ResizePartition(device, disk["device"]:"error", data["region", 1]:0);

	    UpdateMainStatus();
	    TreePanel::Create();
	    UpdateTableFocus(device);
	}
    }


    void EpDeletePartition(string device)
    {
	if (device == nil)
	{
	    // error popup
	    Popup::Error(_("No partition selected."));
	    return;
	}

	string parent = ParentDevice(device);

	if (EpDeleteDevice(device))
	{
	    UpdateMainStatus();
	    UpdateNavigationTree(parent);
	    TreePanel::Create();
	}
    }


    void EpDasdfmtDisk(string device)
    {
	map<string, map> target_map = Storage::GetTargetMap();

	map disk = target_map[device]:$[];

	if (!disk["dasdfmt"]:false)
	{
	    // popup text, %1 is replaced by a dasd name e.g. /dev/dasda
	    boolean doit = Popup::YesNo(sformat(_("Running dasdfmt deletes all data on the disk.
Really execute dasdfmt on disk %1?
"), device));

	    if (doit)
	    {
		Storage::InitializeDisk(device, true);
	    }
	}
	else
	{
	    // popup text
	    Popup::Message(_("The disk is no longer marked for dasdfmt.

Partitions currently present on this disk are again
displayed.
"));
	    Storage::InitializeDisk(device, false);
	}

	UpdateMainStatus();
	UpdateNavigationTree(nil);
	TreePanel::Create();
    }

    void EpCloneDisk( string device )
    {
	map<string, map> target_map = Storage::GetTargetMap();

	integer mysize = target_map[ device, "size_k"]:0;
	list <map> myparts = target_map[ device, "partitions"]:[];
	string mypart_table_type = target_map[ device, "label" ]:Storage::DefaultDiskLabel( mysize );

	list <string> AvailableTargetDisks() {
	    list <string> items = [];

	    map <string, map> filtered_target_map =
		filter( string dev, map props, target_map, {
		    return ( dev != device &&
			     props["type"]:`CT_UNKNOWN == `CT_DISK &&
			     props["used_by_device"]:"" == "");
		});

	    y2milestone("Available and unused disks (other than %1): %2", device, Map::Keys(filtered_target_map));

	    foreach( string dev, map props, filtered_target_map,{
		if( props["size_k"]:0 >= mysize )
		    items = add(items, dev); 
		else 
		    y2milestone("%1 is smaller than needed, skipping it", device);
	    });

	    return items;
	}

	boolean ConfirmDeletePartitions( list <string> to_delete) {

	    UI::OpenDialog( `opt(`warncolor), `VBox(
		    `Left(`Label(_("The following partitions will be deleted\nand all data on them will be lost:"))),
		    `VSpacing(1),
		    `RichText(HTML::List( to_delete)),
		    `Left(`Label(_("Really delete these partitions?"))),
		    `VSpacing(1),
		    `ButtonBox(
			`PushButton(`id(`ok), `opt(`default), Label::DeleteButton()),
			`PushButton(`id(`cancel), Label::CancelButton())
		    )
		)
	    );
	    symbol ret = (symbol) UI::UserInput();
	    UI::CloseDialog();

	    return (ret == `ok);
	}

	if (size(myparts) == 0) {
	    Popup::Error(_("There are no partitions on this disk (a clonable 
disk must have at least one partition).
Create some partitions before cloning the disk."));
	    return;
	}

	list <string> mydisks = AvailableTargetDisks();

	if( size( mydisks ) == 0 ){
	    Popup::Error("This disk cannot be cloned. There are no suitable 
disks that could have the same partitioning layout.");
	   return;
	}

	list<term> ui_items = maplist( string one_disk, mydisks, {
	    return `item(`id(one_disk), sformat("%1 (%2)",one_disk, 
			  Storage::KByteToHumanString( target_map[one_disk, "size_k"]:42)));
	});

	UI::OpenDialog (`MinSize( 60, 20, `VBox(
	    `Heading(sformat(_("Clone partition layout of %1"), device)),
	    `VSpacing(1),
	    `MultiSelectionBox(`id(`tdisk), _("Available target disks:"), ui_items ),
	    `VSpacing(1),
	    `ButtonBox(
		`PushButton(`id(`help), Label::HelpButton()),
	        `PushButton(`id(`ok), `opt(`default), Label::OKButton()),
	        `PushButton(`id(`cancel), Label::CancelButton())
	        )
	    )
	));

	any ret = nil;
	boolean run_raid_setup = false;

	while(ret != `ok && ret != `cancel) {
	    ret = UI::UserInput();

	    if( ret == `ok) {
	        list <string> selected_disks = (list <string>) UI::QueryWidget(`id(`tdisk), `SelectedItems);
		boolean any_disk_selected = size(selected_disks) > 0;

		if (!any_disk_selected) {
		    Popup::Error(_("Select some target disk for creating a clone"));
		    UI::SetFocus(`id(`tdisk));
		    ret = nil;
		    continue;
		}

		list <string> partitions_to_delete = [];

		//collect partitions to delete
		foreach (string this_disk, selected_disks, {
		    list <map> partitions = target_map[ this_disk, "partitions" ]:[];

		    if ( size( partitions ) > 0 ) {
			list <string> tmp = maplist( map one_part, partitions, {
			    return one_part["device"]:"";
			});
			partitions_to_delete = (list <string>) union( partitions_to_delete, tmp);
		    }
		});

		if (!ConfirmDeletePartitions( partitions_to_delete )){
		    ret = nil;
		    continue;
		}

		//We'll be deleting recursively, so that no longer valid
		//LVMs and RAIDs are not left behind
		boolean recursive = Storage::GetRecursiveRemoval();
		Storage::SetRecursiveRemoval(true);

		foreach (string this_disk, selected_disks, {
		    map <string,any> disk_info = Storage::GetDisk( target_map, this_disk );
		    list <map> partitions = target_map[ this_disk, "partitions" ]:[];
		    list<string> pnames = maplist(map part, partitions, { return part["device"]:""; });
		    string part_table_type = disk_info["label"]:Storage::DefaultDiskLabel(disk_info["size_k"]:0;

		    y2milestone("Deleting these partitions: %1", pnames);

		    if( size(partitions) > 0) {
			foreach( string one_partition, pnames,{
			    Storage::DeleteDevice( disk_info["device"]:"", one_partition );
			});
		    }

		    if( mypart_table_type != part_table_type ) {
			y2milestone("%1 has different type of partition table: %2, will create a new one",
			    this_disk, part_table_type);
			Storage::CreatePartitionTable( disk_info["device"]:"", mypart_table_type );
		    }

		    foreach( map one_partition, myparts, {
		        map next = Storage::NextPartition( this_disk, one_partition["type"]:`none);
		        Storage::CreatePartition( this_disk, next["device"]:"error", 
					      one_partition["type"]:`primary,
					      one_partition["fsid"]: Partitions::fsid_native,
					      one_partition["region",0]:0, one_partition["region",1]:0, 
					      one_partition["mountby"]:Storage::GetMountBy(device) );
		        //FIXME: ChangeVolumeProperties too?
		    });
		});

		Storage::SetRecursiveRemoval( recursive );
	   }
	}

	UI::CloseDialog();

	if( ret == `ok ) {
	    UpdateMainStatus();
	    UpdateNavigationTree(nil);
	    TreePanel::Create();
	}
    }
}
