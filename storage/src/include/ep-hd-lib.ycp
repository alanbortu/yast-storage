/**
 * File:	ep-hd-lib.ycp
 * Package:	yast2-storage
 * Summary:	Expert Partitioner
 * Authors:	Arvin Schnell <aschnell@suse.de>
 */
{
    textdomain "storage";


    void EpCreatePartitionTable(string disk_device)
    {
	if (disk_device == nil)
	{
	    // error popup
	    Popup::Error(_("No hard disk selected."));
	    return;
	}

	map<string, map> target_map = Storage::GetTargetMap();
	map disk = target_map[disk_device]:$[];

	if (disk["used_by_device"]:"" != "")
	{
	    // error popup
	    Popup::Error(_("The disk is in use and cannot be modified."));
	    return;
	}

	string default_label = Storage::DefaultDiskLabel(target_map[disk_device, "size_k"]:0);

	list<string> labels = [ default_label ];
	if (!contains(labels, "gpt"))
	    labels = add(labels, "gpt");

	string label = default_label;
	if (size(labels) > 1)
	{
	    term tmp = list::reduce(term t, string l, `VBox(), labels, {
		return add(t, `LeftRadioButton(`id(l), toupper(l), l == default_label));
	    });

	    UI::OpenDialog(`opt(`decorated),
			   Greasemonkey::Transform(
			       `VBox(
				   // dialog heading
				   `Label(sformat(_("Select new partition table type for %1."), disk_device)),
				   `RadioButtonGroup(`id(`labels), tmp),
				   `HBox(
				       `PushButton(`id(`ok), `opt(`default), Label::OKButton()),
				       `PushButton(`id(`cancel), Label::CancelButton())
				       )
				   )
			       )
		);

	    symbol widget = (symbol) UI::UserInput();

	    label = (string) UI::QueryWidget(`id(`labels), `Value);

	    UI::CloseDialog();

	    if (widget != `ok)
		return;
	}

	// popup text, %1 is be replaced by disk name e.g. /dev/sda
	if (Popup::YesNo(sformat(_("Really create new partition table on %1? This will delete all data
on %1 and all RAIDs and Volume Groups using partitions on %1."), disk_device)))
	{
	    Storage::CreatePartitionTable(disk_device, label);
	    UpdateNavigationTree(nil);
	    TreePanel::Create();
	}
    }


    void EpDeleteDisk(string device)
    {
	if (device == nil)
	{
	    // error popup
	    Popup::Error(_("No disk selected."));
	    return;
	}

	map<string, map> target_map = Storage::GetTargetMap();
	map<string, any> disk = Storage::GetDisk(target_map, device);

	if (disk["type"]:`CT_UNKNOWN == `CT_DMRAID)
	{
	    // popup text
	    if (Popup::YesNo(sformat(_("Really delete BIOS RAID %1?"), device)))
	    {
		if (deleteAllDevPartitions(disk, Stage::initial(), false))
		    Storage::DeleteDmraid(device);
		UpdateNavigationTree(`hd);
		TreePanel::Create();
	    }
	}
	else
	{
	    // error popup
	    Popup::Error(_("The disk cannot be deleted."));
	}
    }


    map GetPossibleSlots(map disk, string disk_device)
    {
	list<map> slots = [];
	Storage::GetUnusedPartitionSlots(disk_device, slots);
	y2milestone("slots %1", slots);

	// find biggest primary, extended and logical slot

	map ret = $[];
	list<map> tmp = [];

	tmp = filter(map slot, slots, { return slot["primary_possible"]:false; });
	tmp = sort(map a, map b, tmp, { return a["region", 1]:0 > b["region", 1]:0; });
	if (size(tmp) > 0)
	    ret[`primary] = tmp[0, "region"]:[];

	tmp = filter(map slot, slots, { return slot["extended_possible"]:false; });
	tmp = sort(map a, map b, tmp, { return a["region", 1]:0 > b["region", 1]:0; });
	if (size(tmp) > 0)
	    ret[`extended] = tmp[0, "region"]:[];

	tmp = filter(map slot, slots, { return slot["logical_possible"]:false; });
	tmp = sort(map a, map b, tmp, { return a["region", 1]:0 > b["region", 1]:0; });
	if (size(tmp) > 0)
	    ret[`logical] = tmp[0, "region"]:[];

	if (size(ret) == 0)
	{
	    // error popup
	    string text = sformat(_("It is not possible to create a partition on %1."), disk_device);
	    Popup::Warning(text);
	}

	y2milestone("ret %1", ret);
	return ret;
    }


    /**
     * argument is device of hard disk
     */
    void EpCreatePartition(string disk_device)
    {
	if (disk_device == nil)
	{
	    // error popup
	    Popup::Error(_("No hard disk selected."));
	    return;
	}

	map<string, map> target_map = Storage::GetTargetMap();
	map disk = target_map[disk_device]:$[];

	if (disk["used_by_device"]:"" != "")
	{
	    // error popup
	    Popup::Error(_("The disk is in use and cannot be modified."));
	    return;
	}

	if (disk["readonly"]:false)
	{
	    Popup::Error(Partitions::RdonlyText(disk["device"]:"", true));
	    return;
	}

	map slots = GetPossibleSlots(disk, disk_device);

	if (size(slots) > 0)
	{
	    map<string, any> data = $[ "new" : true,
				       "create" : true,
				       "disk_device" : disk_device,
				       "cyl_size" : disk["cyl_size"]:0,
				       "slots" : slots ];

	    if (DlgCreatePartition(data))
	    {
		string device = data["device"]:"error";

		symbol mby = data["mountby"]:Storage::GetMountBy(device);
		Storage::CreatePartition(data["disk_device"]:"", device,
					 data["type"]:`primary,
					 data["fsid"]:Partitions::fsid_native,
					 data["region",0]:0, data["region",1]:0, mby);
		Storage::ChangeVolumeProperties(data);

		UpdateNavigationTree(nil);
		TreePanel::Create();
		UpdateTableFocus(device);
	    }
	}
    }


    void EpEditPartition(string device)
    {
	if (device == nil)
	{
	    // error popup
	    Popup::Error(_("No partition selected."));
	    return;
	}

	map<string, map> target_map = Storage::GetTargetMap();
	map<string, any> data = Storage::GetPartition(target_map, device);

	if (data["used_by"]:"" != "")
	{
	    // error popup, %1 is replace by partition device name e.g. /dev/sdb1
	    Popup::Error(sformat(_("The partition %1 is in use. It cannot be
edited. To edit %1, make sure it is not used."), device));
	    return;
	}

	if (data["type"]:`primary == `extended)
	{
	    // error popup text
	    Popup::Error(_("An extended partition cannot be changed.
Delete this partition then create a new one using
the new parameters.
All data on this partition will be lost if you delete it."));
	    return;
	}

	if (DlgEditPartition(data))
	{
	    Storage::ChangeVolumeProperties(data);

	    UpdateNavigationTree(nil);
	    TreePanel::Create();
	    UpdateTableFocus(device);
	}
    }


    void EpResizePartition(string device)
    {
	if (device == nil)
	{
	    // error popup
	    Popup::Error(_("No partition selected."));
	    return;
	}

	map<string, map> target_map = Storage::GetTargetMap();
	map<string, any> disk = Storage::GetDisk(target_map, device);
	map<string, any> data = Storage::GetPartition(target_map, device);

	if (disk["readonly"]:false)
	{
	    Popup::Error(Partitions::RdonlyText(disk["device"]:"", true));
	    return;
	}

	if (data["used_by"]:"" != "")
	{
	    // error popup, %1 is replace by partition device name, e.g. /dev/sdb1
	    Popup::Error(sformat(_("The partition %1 is in use. It cannot be
resized. To resize %1, make sure it is not used."), device));
	    return;
	}

	//Need to pass data on the whole disk, to determine free/available space
	if ( DlgResizePartition(data, disk) )
	{
	    target_map = Storage::SetPartition( target_map, data );
	    Storage::SetTargetMap( target_map );
	}
    }


    void EpDeletePartition(string device)
    {
	if (device == nil)
	{
	    // error popup
	    Popup::Error(_("No partition selected."));
	    return;
	}

	string parent = ParentDevice(device);

	if (EpDeleteDevice(device))
	{
	    UpdateNavigationTree(parent);
	    TreePanel::Create();
	}
    }


    void EpDasdfmtDisk(string device)
    {
	map<string, map> target_map = Storage::GetTargetMap();

	map disk = target_map[device]:$[];

	if (!disk["dasdfmt"]:false)
	{
	    // popup text, %1 is replaced by a dasd name e.g. /dev/dasda
	    boolean doit = Popup::YesNo(sformat(_("Running dasdfmt deletes all data on the disk.
Really execute dasdfmt on disk %1?
"), device));

	    if (doit)
	    {
		Storage::InitializeDisk(device, true);
	    }
	}
	else
	{
	    // popup text
	    Popup::Message(_("The disk is no longer marked for dasdfmt.

Partitions currently present on this disk are again
displayed.
"));
	    Storage::InitializeDisk(device, false);
	}

	UpdateNavigationTree(nil);
	TreePanel::Create();
    }
}
