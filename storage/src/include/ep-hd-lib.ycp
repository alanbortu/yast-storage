/**
 * File:	ep-hd-lib.ycp
 * Package:	yast2-storage
 * Summary:	Expert Partitioner
 * Authors:	Arvin Schnell <aschnell@suse.de>
 *
 * This file must only be included in other Expert Partitioner files ("ep-*.ycp").
 */
{
    textdomain "storage";


    void EpCreatePartitionTable(string disk_device)
    {
	if (disk_device == nil)
	{
	    // error popup
	    Popup::Error(_("No hard disk selected."));
	    return;
	}

	map<string, map> target_map = Storage::GetTargetMap();
	map disk = target_map[disk_device]:$[];

	if (!isempty(disk["used_by_device"]:""))
	{
	    // error popup
	    Popup::Error(_("The disk is in use and cannot be modified."));
	    return;
	}

	string default_label = Storage::DefaultDiskLabel(target_map[disk_device, "size_k"]:0);

	list<string> labels = [ default_label ];
	if (!contains(labels, "gpt"))
	    labels = add(labels, "gpt");

	string label = default_label;
	if (size(labels) > 1)
	{
	    term tmp = list::reduce(term t, string l, `VBox(), labels, {
		return add(t, `LeftRadioButton(`id(l), toupper(l), l == default_label));
	    });

	    UI::OpenDialog(`opt(`decorated),
			   Greasemonkey::Transform(
			       `VBox(
				   // dialog heading
				   `Label(sformat(_("Select new partition table type for %1."), disk_device)),
				   `MarginBox(2, 0.4, `RadioButtonGroup(`id(`labels), tmp)),
				   `ButtonBox(
				       `PushButton(`id(`ok), `opt(`default), Label::OKButton()),
				       `PushButton(`id(`cancel), Label::CancelButton())
				       )
				   )
			       )
		);

	    symbol widget = (symbol) UI::UserInput();

	    label = (string) UI::QueryWidget(`id(`labels), `Value);

	    UI::CloseDialog();

	    if (widget != `ok)
		return;
	}

	// popup text, %1 is be replaced by disk name e.g. /dev/sda
	if (Popup::YesNo(sformat(_("Really create new partition table on %1? This will delete all data
on %1 and all RAIDs and Volume Groups using partitions on %1."), disk_device)))
	{
	    Storage::CreatePartitionTable(disk_device, label);

	    UpdateMainStatus();
	    UpdateNavigationTree(nil);
	    TreePanel::Create();
	}
    }


    void EpDeleteDisk(string device)
    {
	if (device == nil)
	{
	    // error popup
	    Popup::Error(_("No disk selected."));
	    return;
	}

	map<string, map> target_map = Storage::GetTargetMap();
	map<string, any> disk = Storage::GetDisk(target_map, device);

	if (disk["type"]:`CT_UNKNOWN == `CT_DMRAID)
	{
	    // popup text
	    if (Popup::YesNo(sformat(_("Really delete BIOS RAID %1?"), device)))
	    {
		if (deleteAllDevPartitions(disk, Stage::initial(), false))
		    Storage::DeleteDmraid(device);

		UpdateMainStatus();
		UpdateNavigationTree(`hd);
		TreePanel::Create();
	    }
	}
	else
	{
            list<map> parts = target_map[device, "partitions"]:[];
	    //partition names
            list<string> pnames = maplist(map part, parts, { return part["device"]:""; });
	    integer count = size(pnames);

	    if(count == 0)
	    {
	        // error ppup
	        Popup::Error(_("There are no partitions to delete on this disk."));
		return;
	    }

	    else
	    {
	        if ( ConfirmPartitionsDelete( device, pnames) && deleteAllDevPartitions(disk, Stage::initial(), false))
	        {
	            UpdateMainStatus();
	            UpdateNavigationTree(`hd);
	            TreePanel::Create();
	        }
	    }
	}
    }


    map<symbol, list> GetPossibleSlots(map disk, string disk_device)
    {
	list<map> slots = [];
	Storage::GetUnusedPartitionSlots(disk_device, slots);
	y2milestone("slots %1", slots);

	// individual sort primary, extended and logical slots

	map<symbol, list> ret = $[];
	list<map> tmp = [];

	tmp = filter(map slot, slots, { return slot["primary_possible"]:false; });
	tmp = sort(map a, map b, tmp, { return a["region", 1]:0 > b["region", 1]:0; });
	if (size(tmp) > 0)
	    ret[`primary] = maplist(map slot, tmp, { return slot["region"]:[]; });

	tmp = filter(map slot, slots, { return slot["extended_possible"]:false; });
	tmp = sort(map a, map b, tmp, { return a["region", 1]:0 > b["region", 1]:0; });
	if (size(tmp) > 0)
	    ret[`extended] = maplist(map slot, tmp, { return slot["region"]:[]; });

	tmp = filter(map slot, slots, { return slot["logical_possible"]:false; });
	tmp = sort(map a, map b, tmp, { return a["region", 1]:0 > b["region", 1]:0; });
	if (size(tmp) > 0)
	    ret[`logical] = maplist(map slot, tmp, { return slot["region"]:[]; });

	if (size(ret) == 0)
	{
	    // error popup
	    Popup::Error(sformat(_("It is not possible to create a partition on %1."),
				 disk_device));
	}

	y2milestone("ret %1", ret);
	return ret;
    }


    /**
     * argument is device of hard disk
     */
    void EpCreatePartition(string disk_device)
    {
	if (disk_device == nil)
	{
	    // error popup
	    Popup::Error(_("No hard disk selected."));
	    return;
	}

	map<string, map> target_map = Storage::GetTargetMap();
	map disk = target_map[disk_device]:$[];

	if (!isempty(disk["used_by_device"]:""))
	{
	    // error popup
	    Popup::Error(_("The disk is in use and cannot be modified."));
	    return;
	}

	if (disk["readonly"]:false)
	{
	    Popup::Error(Partitions::RdonlyText(disk["device"]:"", true));
	    return;
	}

	map slots = GetPossibleSlots(disk, disk_device);

	if (size(slots) > 0)
	{
	    map<string, any> data = $[ "new" : true,
				       "create" : true,
				       "disk_device" : disk_device,
				       "cyl_size" : disk["cyl_size"]:0,
				       "cyl_count" : disk["cyl_count"]:0,
				       "slots" : slots ];

	    if (DlgCreatePartition(data))
	    {
		string device = data["device"]:"error";

		symbol mby = data["mountby"]:Storage::GetMountBy(device);
		Storage::CreatePartition(data["disk_device"]:"", device,
					 data["type"]:`primary,
					 data["fsid"]:Partitions::fsid_native,
					 data["region",0]:0, data["region",1]:0, mby);
		Storage::ChangeVolumeProperties(data);

		UpdateMainStatus();
		UpdateNavigationTree(nil);
		TreePanel::Create();
		UpdateTableFocus(device);
	    }
	}
    }


    void EpEditPartition(string device)
    {
	if (device == nil)
	{
	    // error popup
	    Popup::Error(_("No partition selected."));
	    return;
	}

	map<string, map> target_map = Storage::GetTargetMap();
	map<string, any> data = Storage::GetPartition(target_map, device);

	if (!isempty(data["used_by_device"]:""))
	{
	    // error popup, %1 is replace by partition device name e.g. /dev/sdb1
	    Popup::Error(sformat(_("The partition %1 is in use. It cannot be
edited. To edit %1, make sure it is not used."), device));
	    return;
	}

	if (data["type"]:`primary == `extended)
	{
	    // error popup text
	    Popup::Error(_("An extended partition cannot be edited."));
	    return;
	}

	if (DlgEditPartition(data))
	{
	    Storage::ChangeVolumeProperties(data);

	    UpdateMainStatus();
	    UpdateNavigationTree(nil);
	    TreePanel::Create();
	    UpdateTableFocus(device);
	}
    }


    void EpResizePartition(string device)
    {
	if (device == nil)
	{
	    // error popup
	    Popup::Error(_("No partition selected."));
	    return;
	}

	map<string, map> target_map = Storage::GetTargetMap();
	map<string, any> disk = Storage::GetDisk(target_map, device);
	map<string, any> data = Storage::GetPartition(target_map, device);

	if (disk["readonly"]:false)
	{
	    Popup::Error(Partitions::RdonlyText(disk["device"]:"", true));
	    return;
	}

	if (!isempty(data["used_by_device"]:""))
	{
	    // error popup, %1 is replace by partition device name, e.g. /dev/sdb1
	    Popup::Error(sformat(_("The partition %1 is in use. It cannot be
resized. To resize %1, make sure it is not used."), device));
	    return;
	}

	if (data["type"]:`primary == `extended)
	{
	    // error popup text
	    Popup::Error(_("An extended partition cannot be resized."));
	    return;
	}

	//Need to pass data on the whole disk, to determine free/available space
	if (DlgResizePartition(data, disk))
	{
	    Storage::ResizePartition(device, disk["device"]:"error", data["region", 1]:0);

	    UpdateMainStatus();
	    TreePanel::Create();
	    UpdateTableFocus(device);
	}
    }


    void EpDeletePartition(string device, symbol context)
    {
	if (device == nil)
	{
	    // error popup
	    Popup::Error(_("No partition selected."));
	    return;
	}

	string parent = ParentDevice(device);
	string next = NextDeviceAfterDelete(device);

	if (EpDeleteDevice(device))
	{
	    UpdateMainStatus();

	    switch (context)
	    {
		case `table:
		    UpdateNavigationTree(nil);
		    TreePanel::Create();
		    if (!isempty(next))
			UI::ChangeWidget(`id(`table), `CurrentItem, next);
		    break;

		case `overview:
		    UpdateNavigationTree(parent);
		    TreePanel::Create();
		    break;
	    }
	}
    }


    void EpDasdfmtDisk(string device)
    {
	map<string, map> target_map = Storage::GetTargetMap();

	map disk = target_map[device]:$[];

	if (!disk["dasdfmt"]:false)
	{
	    // popup text, %1 is replaced by a dasd name e.g. /dev/dasda
	    boolean doit = Popup::YesNo(sformat(_("Running dasdfmt deletes all data on the disk.
Really execute dasdfmt on disk %1?
"), device));

	    if (doit)
	    {
		Storage::InitializeDisk(device, true);
	    }
	}
	else
	{
	    // popup text
	    Popup::Message(_("The disk is no longer marked for dasdfmt.

Partitions currently present on this disk are again
displayed.
"));
	    Storage::InitializeDisk(device, false);
	}

	UpdateMainStatus();
	UpdateNavigationTree(nil);
	TreePanel::Create();
    }
}
