/**
 * File:	ep-btrfs-dialogs.ycp
 * Package:	yast2-storage
 * Summary:	Expert Partitioner
 * Authors:	Thomas Fehr <fehr@suse.de>
 *
 * This file must only be included in other Expert Partitioner files ("ep-*.ycp").
 */
{
    textdomain "storage";


    boolean DlgEditBtrfsVolume(map<string, any> &data)
	{
	y2milestone( "DlgEditBtrfsVolume %1", data );
	string device = data["device"]:"error";

	map<string, any> aliases = $[
	    "FormatMount" : ``(MiniWorkflowStepFormatMount(data)),
	    "Password"	  : ``(MiniWorkflowStepPassword(data))
	    ];

	map<string, any> sequence = $[
	    "FormatMount" : $[ `next : "Password",
			       `finish : `finish ],
	    "Password"    : $[ `finish : `finish ]
	    ];

	// dialog title
	string title = sformat(_("Edit Btrfs %1"), data["uuid"]:"");

	symbol widget = MiniWorkflow::Run(title, StorageIcons::lvm_lv_icon, aliases, sequence, "FormatMount");

	return widget == `finish;
	}

    /////////////////////////////////////////////////////////////////
    // Get all volumes, we can probably use as volumes in an BTRFS
    // Add needed information: disksize 
    define list<map> GetPossibleVols( map<string,map> targetMap )
	{
	list<map> ret = [];
	    
	//////////////////////////////////////////////////////////////////////
	// add the devicename i.e /dev/hda1 or /dev/system/usr to partition list

	targetMap = mapmap( string dev, map devmap, targetMap,
	    {
	    list partitions = maplist( map part, devmap["partitions"]:[],
		{
		part["maindev"] = dev;
		return( part );
		});
	    return( $[ dev: add(devmap, "partitions", partitions) ] );
	    });

	////////////////////////////////////////////////////////////
	// Look for all partitions:
	// no mountpoint
	// id 0x83 

	list types_no = [ `btrfs, `extended ];
	list types_ok = [ `sw_raid, `dm, `lvm ];
	list fsids = [ Partitions::fsid_native, Partitions::fsid_lvm, Partitions::fsid_raid ];
	list allowed_enc_types = [ `none ];

	foreach( string dev, map devmap, targetMap,
	    ``{
	    y2milestone( "GetPossibleVols parts:%1", devmap["partitions"]:[] );
	    list<map> parts = 
		filter( map part, devmap["partitions"]:[],
			``( (size(part["mount"]:"")==0 || part["used_by_type"]:`UB_NONE==`UB_BTRFS) &&
			    !contains( types_no, part["type"]:`primary ) &&
			    contains(allowed_enc_types, part["enc_type"]:`none) &&
			    (!Storage::IsUsedBy(part) || part["used_by_type"]:`UB_NONE==`UB_BTRFS) &&
			    (contains( types_ok, part["type"]:`primary ) ||
			     contains( fsids, part["fsid"]:0 ))));
	    y2milestone( "GetPossibleVols filter:%1", parts );
	    if( devmap["used_by_type"]:`UB_NONE!=`UB_NONE )
		{
		parts = [];
		y2milestone( "GetPossibleVols no parts, disk used by %1 %2",
			     devmap["used_by_type"]:`UB_NONE, devmap["used_by_device"]:"" );
		}
	    /* currently disallow usage of whole disk devices as parts of BTRFS volumes
	    if( size(devmap["partitions"]:[])==0 && 
		Storage::IsPartType(devmap["type"]:`CT_UNKNOWN) &&
		(!Storage::IsUsedBy(devmap) || devmap["used_by_type"]:`UB_NONE==`UB_LVM))
		{
		map p = $[ "device":dev, "maindev":dev, 
			   "size_k":devmap["size_k"]:0 ];
		if( devmap["used_by_type"]:`UB_NONE != `UB_NONE )
		    {
		    p["used_by_type"] = devmap["used_by_type"]:`UB_NONE;
		    p["used_by_device"] = devmap["used_by_device"]:"";
		    }
		parts = [ p ];
		}
	    */
	    ret = (list<map>)merge( ret, parts );
	    });
	y2milestone( "GetPossibleVols ret %1", ret );
	return( ret );
	}

    boolean CheckNumberOfDevicesForVolume(integer num)
	{
	if (num < 1)
	    {
	    // error popup
	    Popup::Error(sformat(_("Select at least one device.")));
	    UI::SetFocus(`id(`unselected));
	    return false;
	    }
	else
	    {
	    return true; 
	    }
	}

    string MiniWorkflowStepResizeVolumeHelptext()
	{
	// helptext
	string helptext = _("<p>Change the devices that are used by the Btrfs volume.</p>");

	return helptext;
	}


    symbol MiniWorkflowStepResizeVolume(map<string, any> &data)
	{
	y2milestone("MiniWorkflowStepResizeVolume data:%1", data);

	string vgname = data["name"]:"error";
	list<string> pvs_new = [];

	list<symbol> fields = StorageSettings::FilterTable([ `device, `udev_path, `udev_id, `size, `encrypted, `type ]);

	list<map> poss_pvs = GetPossibleVols(Storage::GetTargetMap());
	y2milestone( "MiniWorkflowStepResizeVolume poss:%1", maplist( map pv, poss_pvs, ``( [ pv["device"]:"", pv["used_by_device"]:"" ])));
	list<map> unused_pvs = filter(map pv, poss_pvs, ``(pv["used_by_type"]:`UB_NONE==`UB_NONE));
	list<map> used_pvs = filter(map pv, poss_pvs, ``(pv["used_by_device"]:""==data["uuid"]:""));

	term contents = `VBox();

	contents = add(contents, DevicesSelectionBox::Create(unused_pvs, used_pvs, fields, nil,
							     _("Unused Devices:"),
							     _("Selected Devices:")));

	MiniWorkflow::SetContents(Greasemonkey::Transform(contents), MiniWorkflowStepResizeVolumeHelptext());
	MiniWorkflow::SetLastStep(true);

	symbol widget = nil;

	repeat
	    {
	    widget = MiniWorkflow::UserInput();
	    DevicesSelectionBox::Handle(widget);

	    switch (widget)
		{
		case `next:
		    {
		    pvs_new = maplist(map pv, DevicesSelectionBox::GetSelectedDevices(), {
			return pv["device"]:"";
			});

		    if (!CheckNumberOfDevicesForVolume(size(pvs_new)))
			widget = `again;

		    // TODO: overall size check
		    }
		break;
		}
	    }
	until (widget == `abort || widget == `back || widget == `next);

	if (widget == `next)
	    {
	    data["devices_new"] = pvs_new;

	    widget = `finish;
	    }

	y2milestone("MiniWorkflowStepResizeVg data:%1 ret:%2", data, widget);

	return widget;
	}


    boolean DlgResizeBtrfsVolume(map<string, any> &data, symbol() Commit)
	{
	map<string, any> aliases = $[
	    "TheOne" : ``(MiniWorkflowStepResizeVolume(data)),
	    "Commit" : ``(Commit())
	    ];

	map<string, any> sequence = $[
	    "TheOne" : $[ `finish : "Commit" ],
	    "Commit" : $[ `finish : `finish ]
	    ];

	y2milestone( "data:%1", data );

	// dialog title
	string title = sformat(_("Resize Btrfs Volume %1"), data["uuid"]:"error");

	symbol widget = MiniWorkflow::Run(title, StorageIcons::lvm_icon, aliases, sequence, "TheOne");

	return widget == `finish;
	}

}
