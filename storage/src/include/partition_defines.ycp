/**
 * File:
 *   partition_defines.ycp
 *
 * Module:
 *   partitioning
 *
 * Summary:
 *   main lib for partitioning defines
 *
 * Authors:
 *   mike <mike@suse.de>
 *
 *
 * $Id$
 *
 */

{
  import "Mode";
  import "FileSystems";

  textdomain "storage";


    /*---------------------------------------------------------------------
     * get a list of not used mountpoints
     *------------------------------------
     * in:  targetMap
     * out: list of mountpoints for a combobox  ["/usr","/opt", ...]
     *---------------------------------------------------------------------
     */

     define list<string> notUsedMountpoints( map<string,map> targetMap , list<string> all_mountpoints )
     ``{
	 if( all_mountpoints == [] || all_mountpoints == nil  )
	 {
	     all_mountpoints =  FileSystems::SuggestMPoints();
	 }


	list mountpoints = 
	    maplist( any dev, map devmap, targetMap,
		     ``{
		     return( maplist( map part, devmap["partitions"]:[], 
				      ``( part["mount"]:"") ));
		     });

	mountpoints = (list) flatten((list<list>)mountpoints);
	mountpoints = union(mountpoints, []); // remove double entrys "" and swap

	list<string> not_used_mountpoints = filter( string mnt, all_mountpoints,
					    ``( !contains( mountpoints, mnt) ));

	 return( not_used_mountpoints );
     };


    ////////////////////////////////////////////////////////////////////////
    // input:
    // win_size_f: new size of wimdows partion in bytes as float
    // cyl_size  : cylinder size
    //
    // output: lentgh of win-region in cylinder

    define integer PartedSizeToCly( float win_size_f, integer cyl_size )
    ``{
	float   new_length_f = (win_size_f) / tofloat( cyl_size );
	integer new_length_i = tointeger( new_length_f );

	y2debug("new_length_f: <%1> - new_length_i: <%2>", new_length_f, new_length_i );

	if ( tofloat( new_length_f ) != tofloat( new_length_i ) )
	{
	    new_length_i = new_length_i + 1;	// add 1 cylinder if there is a residual
	}

	return( new_length_i );
    };


    /**
     * Make a proposal for a single mountpoint
     * (first free on the list in installation, 
     * empty string otherwise)
     **/
define string SingleMountPointProposal( ) 
``{
    if ( Mode::normal() )
	return "";
    else
    {
        list free_list = notUsedMountpoints( Storage::GetTargetMap(), FileSystems::SuggestMPoints() ); // = filter( string point, base,
	return free_list[0]:"";
    }
  }
}
