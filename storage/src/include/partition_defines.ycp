/**
 * File:
 *   partition_defines.ycp
 *
 * Module:
 *   partitioning
 *
 * Summary:
 *   main lib for partitioning defines
 *
 * Authors:
 *   mike <mike@suse.de>
 *
 *
 * $Id$
 *
 */

{
  import "Arch";
  import "Installation";
  import "Wizard";
  import "Storage";
  import "Mode";
  import "Stage";
  import "Partitions";
  import "FileSystems";
  import "Report";
  import "String";
  import "Popup";


  textdomain "storage";


//////////////////////////////////////////////////////////////////////
// size str to byte
// in: <number>[kKmM][bB]
//
// return "0" if input is invalid
//
// 8 is 8k
// 16K == 16k == 16KB == 16kb
// TODO: remove
define integer kmgt_str_to_byte( string input )
{
    integer number = 0;
    integer pos = findfirstnotof( input, " +" );

    if( pos != nil && pos>0 )
	{
	input = substring( input, pos );
	}

    if( size(filterchars(input, "0123456789kKmMgGtTbBoO .")) != size(input))
       {
       return(0);
       }

    input = filterchars(input, "0123456789kKmMgGtTbBoO.");

    if( size(input)>0 && findfirstnotof( input, "0123456789.") != nil  )
        {
	// check whether the last char is in "kKmM" or "bB"
	string last_char = substring( input, size(input)-1, 1);

	if( last_char == "b" || last_char == "B" ||
	    last_char == "o" || last_char == "O" )
	    {
	    input = substring( input, 0, size(input)-1);
	    // check whether the last char is in "kKmM"
	    last_char = substring( input, size(input)-1, 1);
	    }

        string number_str = substring(input, 0, size(input)-1);

	if( findfirstnotof( number_str, "0123456789.") == nil )
	    {
	    if( last_char == "k" || last_char == "K" )
	        {
		number = tointeger(tofloat( number_str ) * 1024.0) ;
		}
	    else if ( last_char == "m" || last_char == "M" )
		{
		number = tointeger(tofloat( number_str ) * 1024.0 * 1024.0);
	        }
	    else if ( last_char == "g" || last_char == "G" )
		{
		number = tointeger(tofloat( number_str ) * 
				   1024.0 * 1024.0 * 1024.0);
		}
	    else if ( last_char == "t" || last_char == "T" )
	        {
		number = tointeger(tofloat( number_str ) * 
				   1024.0 * 1024.0 * 1024.0 * 1024.0);
		}
	    else
		{
		number = 0;
	        }
	    }
        else
	    {
	    number = 0;
	    }
        }
    else if( size(input)==0 )
	{
	number = 0;
	}
    else
        {
        number = tointeger( input );
        }
    return( number );
    };


    /*---------------------------------------------------------------------
     * get a list of not used mountpoints
     *------------------------------------
     * in:  targetMap
     * out: list of mountpoints for a combobox  ["/usr","/opt", ...]
     *---------------------------------------------------------------------
     */

     define list<string> notUsedMountpoints( map<string,map> targetMap , list<string> all_mountpoints )
     ``{
	 if( all_mountpoints == [] || all_mountpoints == nil  )
	 {
	     all_mountpoints =  FileSystems::SuggestMPoints();
	 }


	list mountpoints = 
	    maplist( any dev, map devmap, targetMap,
		     ``{
		     return( maplist( map part, devmap["partitions"]:[], 
				      ``( part["mount"]:"") ));
		     });

	mountpoints = (list) flatten((list<list>)mountpoints);
	mountpoints = union(mountpoints, []); // remove double entrys "" and swap

	list<string> not_used_mountpoints = filter( string mnt, all_mountpoints,
					    ``( !contains( mountpoints, mnt) ));

	 return( not_used_mountpoints );
     };


    ////////////////////////////////////////////////////////////////////////
    // input:
    // win_size_f: new size of wimdows partion in bytes as float
    // cyl_size  : cylinder size
    //
    // output: lentgh of win-region in cylinder

    define integer PartedSizeToCly( float win_size_f, integer cyl_size )
    ``{
	float   new_length_f = (win_size_f) / tofloat( cyl_size );
	integer new_length_i = tointeger( new_length_f );

	y2debug("new_length_f: <%1> - new_length_i: <%2>", new_length_f, new_length_i );

	if ( tofloat( new_length_f ) != tofloat( new_length_i ) )
	{
	    new_length_i = new_length_i + 1;	// add 1 cylinder if there is a residual
	}

	return( new_length_i );
    };


    /**
     * Make a proposal for a single mountpoint
     * (first free on the list in installation, 
     * empty string otherwise)
     **/
define string SingleMountPointProposal( ) 
``{
    if ( Mode::normal() )
	return "";
    else
    {
        list free_list = notUsedMountpoints( Storage::GetTargetMap(), FileSystems::SuggestMPoints() ); // = filter( string point, base,
	return free_list[0]:"";
    }
  }
}
