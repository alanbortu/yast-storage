/**
 * File:
 *   partition_defines.ycp
 *
 * Module:
 *   partitioning
 *
 * Summary:
 *   main lib for partitioning defines
 *
 * Authors:
 *   mike <mike@suse.de>
 *
 *
 * $Id$
 *
 */

{
  import "Arch";
  import "Installation";
  import "Wizard";
  import "Storage";
  import "Mode";
  import "HTML";
  import "Partitions";
  import "Report";

  include "ui/common_popups.ycp";
  include "partitioning/custom_part_testdata.ycp";

  textdomain "storage";

    //////////////////////////////////////////////////////////////////////
    // fills up a string to a minimum length

    global define ToLen( integer wide, string str )
    ``{
	while ( size(str) < wide ) str = " " + str;
	return( str );
    };

    //////////////////////////////////////////////////////////////////////
    // converts int to string
    // fills up the  string to a minimum length

    global define ToStringLen( integer wide, integer number )
    ``{
	return( ToLen( wide, sformat("%1", number )));
    };

    //////////////////////////////////////////////////////////////////////
    // size str to byte
    // in: <number>[kKmM][bB]
    //
    // return "0" if input is invalid
    //
    // 8 is 8k
    // 16K == 16k == 16KB == 16kb
     global define kmgt_str_to_byte( string input )
     ``{
   	   integer number = 0;

	   if ( size(filterchars(input, "0123456789kKmMgGtTbBoO ."))
		!= size(input))
	   {
	       return(0);
	   }

	   input = filterchars(input, "0123456789kKmMgGtTbBoO.");

	   y2debug( "EEE -%1- **** ", input);

           if ( findfirstnotof( input, "0123456789.") != nil  )
           {
               // check whether the last char is in "kKmM" or "bB"
               string last_char = substring( input, size(input)-1, 1);

	       if ( last_char == "b" || last_char == "B" ||
	            last_char == "o" || last_char == "O" )
               {
                   input = substring( input, 0, size(input)-1);
		   // check whether the last char is in "kKmM"
		   last_char = substring( input, size(input)-1, 1);
               }

	       string number_str = substring(input, 0, size(input)-1);

	       if ( findfirstnotof( number_str, "0123456789.") == nil )
	       {
   	          if ( last_char == "k" || last_char == "K" )
		  {
		      number = tointeger(tofloat( number_str ) * 1024.0) ;
		  }
		  else if ( last_char == "m" || last_char == "M" )
		  {
		      number = tointeger(tofloat( number_str ) * 1024.0 * 1024.0);
		  }
		  else if ( last_char == "g" || last_char == "G" )
		  {
		      number = tointeger(tofloat( number_str ) * 1024.0 * 1024.0 * 1024.0);
		  }
		  else if ( last_char == "t" || last_char == "T" )
		  {
		      number = tointeger(tofloat( number_str ) * 1024.0 * 1024.0 * 1024.0 * 1024.0);
		  }
		  else
		  {
		      number = 0;
		  }
	       }
	       else
	       {
		   number = 0;
	       }
           }
           else
           {
               number = tointeger( input );
           }

	   return( number );
     };



    /*---------------------------------------------------------------------
     * TargetChangesToRichText()
     *------------------------------------
     * scan targetmap for changes: visualize them for a RichText-Widget
     *---------------------------------------------------------------------
     */

    global define TargetChangesToRichText( map targetMap, map modTg )
    ``{
	if ( targetMap == nil )
	{
	    y2error( "TargetChangesToRichText(nil)");
	    return("");
	}

	string description = "";

	list delete_lst = [];
	list resize_lst = [];
	list reuse_lst  = [];
	list create_lst = [];
	list other_lst  = [];


	foreach( `disk, `diskinfo, targetMap, ``{
	    list    partitions = diskinfo["partitions"]:[];
	    integer cyl_size  = diskinfo["cyl_size"]:1;

	    foreach( `part, partitions, ``{

		string  device   = Storage::GetDeviceName( disk, part["nr"]:0 );
		string  used_fs  = substring(sformat("%1", part["used_fs"]:" ") ,1);
		string  mount    = part["mount"]:"";
		symbol  type     = part["type"]:`unknown;
		string  fstype   = part["fstype"]:"";
		string  winstr   = "";
		boolean is_fat   = Partitions::IsDosPartition( part["fsid"]:0 );
		string  psize    = ByteToHumanString (part["region",1]:0 * cyl_size);
		string  old_size = "";
		string  debugstr = "";

		if ( Mode::test && !Mode::screen_shot )
		{
		    integer startcyl =  part["region",0]:0;
		    integer lencyl   =  part["region",1]:0;
		    debugstr = sformat(" cyl: %1 to %2  ", ToStringLen(5, startcyl), ToStringLen(5,startcyl + lencyl -1) );
		}

		if ( is_fat )
		{
		   // try to find windows letter like C: D:
		   // look for /windows/ or /dos/
		    if ( size(mount) > 5  &&  substring( mount, 0, 5) == "/dos/" )      winstr = substring( mount, 5, 1 ) + ":";
		    if ( size(mount) > 9  &&  substring( mount, 0, 9) == "/windows/" )  winstr = substring( mount, 9, 1 ) + ":";

		    old_size = ByteToHumanString (part["ori_length"]:0 * cyl_size);
		}

		y2debug( "WWW %1", part);

		if ( part["delete"]:false )
		{
		    if ( is_fat )
		    {
			// to translators: * Delete Windows partition C: (hda3) 600 MB
			delete_lst = add( delete_lst, debugstr + sformat(_("<font color=red>Delete Windows partition</font> %1 (%2) %3"), winstr, device, psize ));
		    }
		    else
		    {
		        // to translators: * Delete partition hda3 600 MB (Linux LVM)
		        delete_lst = add( delete_lst, debugstr + sformat(_("<font color=red>Delete partition</font> %1 %2 (%3)"), device, psize, fstype ));
		    }
		}

		else if ( part["create"]:false )
		{
		    boolean new_mp = false;

		    string instr = mount;

		    // for Create %1 partition to Create boot partition
		    if( mount == "/boot" || 
			part["fsid"]:0 == Partitions::fsid_prep_chrp_boot )
			instr = _("boot");
		    // for Create %1 partition to Create root partition
		    else if ( mount == "/")     instr = _("root");
		    // for Create %1 partition to Create swap partitions
		    else if ( mount == "swap" ) instr = _("swap");
                    // or a non default mp
		    else new_mp = true;


		    if ( !new_mp && 
		         (part["fsid"]:0 == Partitions::fsid_prep_chrp_boot ||
			  mount == "swap"))
		    {
			// to translators: * Create swap partition 1.2 GB on hda1
			create_lst = add( create_lst, debugstr + sformat(_("Create %1 partition %2 on %3"), instr, psize, device ));
		    }
		    else if ( !new_mp )
		    {
			// to translators: * Create root partition 1.2 GB (hda1 with ext2)
			create_lst = add( create_lst, debugstr + sformat(_("Create %1 partition %2 (%3 with %4)"), instr, psize, device, used_fs ));
		    }
		    else if ( type == `extended )
		    {
			// to translators: * Create extended partition 1.2 GB (hda1)
			create_lst = add( create_lst, debugstr + sformat(_("Create extended partition %2 (%3)"), instr, psize, device));
		    }
		    else
		    {
			if( diskinfo["is_lvm_vg"]:false == false )
			    {
			    if( mount != "" )
				{
				// to translators: * Create partition hda3 700 MB (for /var with ext2)
				create_lst = add( create_lst, debugstr + sformat(_("Create partition %1 %2 (for %3 with %4)"), device, psize, mount, used_fs ));
				}
			    else
				{
				integer id = part["fsid"]:0;
				if( (id != Partitions::fsid_native) &&
				    (id != Partitions::fsid_swap) )
				    {
				    // to translators: * Create partition hda3 (id=0x41) 700 MB
				    create_lst = add( create_lst, debugstr + sformat(_("Create partition %1 (id=%2) %3"), device, Partitions::ToHexString(id), psize ));
				    }
				else
				    {
				    // to translators: * Create partition hda3 700 MB
				    create_lst = add( create_lst, debugstr + sformat(_("Create partition %1 %2"), device, psize ));
				    }
				}
			    }
			else
			    {
			    // to translators: * Create LV var in VG system 700 MB (for /var with ext2)
			    create_lst = add( create_lst, debugstr + sformat(_("Create LV %1 in VG %2 %3 (for %4 with %5)"), part["nr"]:"", substring(disk,5), psize, mount, used_fs ));
			    }
		    }
		}

		else if ( part["resize"]:false )
		{
		    if ( is_fat )
		    {
			// to translators: * Resize Windows partition C: (hda1) from 3.2GB to 1.8GB.
			// or without C:   * Resize Windows partition (hda1) from 3.2GB to 1.8GB.
			resize_lst = add( resize_lst, debugstr + sformat(_("Resize Windows partition %1 (%2) from %3 to %4"),
							      winstr, device, old_size, psize  ));
		    }
		    else
		    {
			// to translators: * Resize partition hda1 to 1.8GB.
			resize_lst = add( resize_lst, debugstr + sformat(_("Resize partition %1 to %2"),  device, psize  ));
		    }
		}

		else if ( part["format"]:false )
		{
		    if( mount == "swap")
			{
			if( !diskinfo["is_lvm_vg"]:false )
			    {
			    // to translators: * Format partition hda3 700 MB (for swap)
			    reuse_lst = add( reuse_lst, debugstr + sformat(_("<font color=red>Format partition</font> %1 %2 (for %3)"), device, psize, mount ));
			    }
			else
			    {
			    // to translators: * Format LV swap in VG system 700 MB (for swap)
			    reuse_lst = add( reuse_lst, debugstr + sformat(_("<font color=red>Format LV %1</font> in VG %2 %3 (for %4)"), part["nr"]:"", substring(disk,5), psize, mount ));
			    }
			}
		    else
			{
			if( diskinfo["is_lvm_vg"]:false == false )
			    {
			    // to translators: * Format partition hda3 700 MB (for /var with ext2)
			    reuse_lst = add( reuse_lst, debugstr + sformat(_("<font color=red>Format partition</font> %1 %2 (for %3 with %4)"), device, psize, mount, used_fs ));
			    }
			else
			    {
			    // to translators: * format LV var in VG system 700 MB (for /var with ext2)
			    reuse_lst = add( reuse_lst, debugstr + sformat(_("<font color=red>Format LV %1</font> in VG %2 %3 (for %4 with %5)"), part["nr"]:"", substring(disk,5), psize, mount, used_fs ));
			    }
			}
		}
		else if( haskey(part,"ori_label") &&
		         part["ori_label"]:"" != part["label"]:"" )
		    {
		    other_lst = 
			add( other_lst, 
			     sformat(_("Set volume label of %1 to %2"),
				     device, part["label"]:"" ));
		    }
		else if( !Mode::initial && haskey(part,"ori_mount") && 
		         part["ori_mount"]:""!=part["mount"]:"" )
		    {
		    if( size(part["mount"]:"") > 0 )
			other_lst = 
			    add( other_lst, 
				 sformat(_("Set mount point of %1 to %2"),
					   device, part["mount"]:"" ));
		    else
			other_lst = 
			    add( other_lst, 
				 sformat(_("Remove device %1 from /etc/fstab"),
					   device ));
		    }
		else if( !Mode::initial && (haskey(part,"ori_fstopt") && 
		          part["ori_fstopt"]:""!=part["fstopt"]:"") ||
			 (haskey(part,"ori_mountby") &&
			  part["ori_mountby"]:`device!=part["mountby"]:`device))
		    {
		    other_lst = 
			add( other_lst, 
			     sformat(_("Change mount options of %1 in /etc/fstab"),
				       device ));
		    }
	    });
	});


	foreach( `num, `entry, modTg, ``{
	    if( entry["type"]:"" == "remove_lv" )
		{
		// to translators: * Delete LV /dev/system/usr 
		delete_lst = 
		    add( delete_lst, 
		         sformat(_("<font color=red>Delete LV</font> /dev/%1/%2"),
			         entry["vgname"]:"", entry["name"]:"" ));
		}

	    if( entry["type"]:"" == "create_vg" )
		{
		// to translators: * create VG system
		create_lst = 
		    add( create_lst, 
			 sformat(_("Create VG %1"), entry["vgname"]:"" ));
		}
	    if( entry["type"]:"" == "resize_lv" )
		{
		// to translators: * create VG system
		resize_lst = 
		    add( resize_lst, 
		         sformat(_("Resize LV /dev/%1/%2 to %3"), 
			         entry["vgname"]:"", entry["name"]:"",
				 ByteToHumanString(entry["size"]:0)));
		}

	});

        foreach( `line, delete_lst, ``{
            y2debug( "OUT: DELETE: %1", line);
        });
        foreach( `line, reuse_lst, ``{
            y2debug( "OUT: REUSE : %1", line);
        });
        foreach( `line, resize_lst, ``{
            y2debug( "OUT: RESIZE: %1", line);
        });
        foreach( `line, create_lst, ``{
            y2debug( "OUT: CREATE: %1", line);
        });

	string ret = "";

	list all = flatten( [ delete_lst, reuse_lst, resize_lst,
			      create_lst, other_lst ] );
	if( size(all)>0 )
	    {
	    ret = HTML::Colorize( HTML::List( all ), "black" );
	    }
	return ret;
    };



  
    /*---------------------------------------------------------------------
     * get a list of not used mountpoints
     *------------------------------------
     * in:  targetMap
     * out: list of mountpoints for a combobox  ["/usr","/opt", ...]
     *---------------------------------------------------------------------
     */

     global define notUsedMountpoints( map targetMap , list all_mountpoints )
     ``{
	 if( all_mountpoints == [] || all_mountpoints == nil  )
	 {
	     all_mountpoints =  FileSystems::suggest_m_points;
	 }


	list mountpoints = maplist( `dev, `devmap, targetMap,
			   ``{
			       list not_del_part = filter(  `part, lookup( devmap, "partitions", []),
							    ``( lookup( part, "delete", false) == false));

			       return( maplist( `part, not_del_part, ``( lookup( part, "mount", "")) ));
			   });


	mountpoints = flatten(mountpoints);
	mountpoints = union(mountpoints, []); // remove double entrys "" and swap

	list not_used_mountpoints = filter( `mnt, all_mountpoints,
					    ``( !contains( mountpoints, mnt) ));

	 return( not_used_mountpoints );
     };


    /*---------------------------------------------------------------------
     * Convert <number-of-bytes> to XXX.X MB or XXX.X GB or XXX.X TB
     *
     * see also ByteToHumanString !
     * Return value: string  "0" if input == 0
     *----------------------------------------------------------------------
     */
    global define ByteToHumanStringWithZero ( integer number )
    ``{
	// string or locale
	any ret = ByteToHumanString( number );

	if ( ret == _("unknown") )
	{
	    return( "0 " + _("MB") );
	}
	else
	{
	    return( ret );
	}
    };


    /*---------------------------------------------------------------------
     * Convert <number-of-bytes> to XXX.X MB or XXX.X GB or XXX.X TB
     *
     * see also ByteToHumanStringWithZero !
     * Return value: string  "unknown" if input == 0
     *----------------------------------------------------------------------
     */
    global define ByteToHumanString ( integer number )
    ``{
          // column description, if disk space is not known
          if ( number == 0 ) return( _("unknown") );

          if ( number < 1073741824 )
          {
              // < 1 GB
              integer MB    = number / 1048576;
              integer hunKB = (number - (MB * 1048576)) / 102400;
              if ( hunKB >= 10 )
              {
                hunKB = 9;
              }
              return( sto8string(sformat( "%1.%2 MB", MB,hunKB )));
          }

          else if ( number < 1099511627776 )
          {
              // < 1 TB
              integer GB    = number / 1073741824;
              integer hunMB = (number - (GB * 1073741824)) /  104857600;
              if ( hunMB >= 10 )
              {
                hunMB = 9;
              }
              return( sto8string(sformat( "%1.%2 GB", GB,hunMB )));
          }
          else
          {
              // >= 1 TB
              integer TB    = number / 1099511627776;
              integer hunGB = (number - (TB * 1099511627776)) / 107374182400;
              if ( hunGB >= 10 )
              {
                hunGB = 9;
              }
              return( sto8string(sformat( "%1.%2 TB", TB,hunGB )));
          }
    };



    /*---------------------------------------------------------------------
     * returns for a string a string with a minimum of 9 characters:
     * "1"      -> "       1"
     * "22"     -> "      22"
     * "145"    -> "     145"
     * "2134"   -> "    2134"
     *----------------------------------------------------------------------
     */
    global define sto8string( string str )
    ``{
	integer nb = size( str );
	if ( nb > 8  )   return( sformat( "%1", str ));
	if ( nb > 7  )   return( sformat( " %1", str ));
	if ( nb > 6  )   return( sformat( "  %1", str ));
	if ( nb > 5  )   return( sformat( "   %1", str ));
	if ( nb > 4  )   return( sformat( "    %1", str ));
	if ( nb > 3  )   return( sformat( "     %1", str ));
	if ( nb > 2  )   return( sformat( "      %1", str ));
	if ( nb > 1  )   return( sformat( "       %1", str ));
	return( sformat( "         %1", str ));
    };

  global define get_device_name( string disk, any partition ) ``{
      return( Storage::GetDeviceName( disk, partition ));
  };





 


  /*---------------------------------------------------------------------
   * changeExtendedIdTo15
   *---------------------------------------------------------------------
   * change the fsid of every extended partiton in  the map targets
   * in user_settings from 5 to 15
   *---------------------------------------------------------------------
   */

    global define void changeExtendedIdTo15()
    ``{
        include "partitioning/lvm_lib.ycp";

	map modify_targets = Storage::GetModifyTargets();
	map targets        = Storage::GetTargetMap();

	foreach ( `dev, `disk, targets,
	``{
	    list partitions = lookup ( disk, "partitions", [] );

	    foreach ( `partition, partitions,
	    ``{
		if ( (lookup( partition , "fsid", 0 ) == 5) &&
		     (lookup(partition, "create", false)  ) &&
		     ( !lookup(partition, "define", false))    )
		{
		    modify_targets = addTargetModification( modify_targets, $[
									      "disk" : dev,
									      "id" : 15,
									      "nr" : lookup( partition, "nr", 0 ),
									      "type" : "change_id",
									      "use_module" : "fdisk_ll" ]);
		}
	    });
	});


	//SCR::Write(.dumpto.tmp.my_modify,    modify_targets );
	Storage::SetModifyTargets( modify_targets);
    };



  /*---------------------------------------------------------------------
   * checkForMdRootFs
   *---------------------------------------------------------------------
   * check if the root filesystem is a md device
   *---------------------------------------------------------------------
   */
    global define checkForMdRootFs( map ust )
    ``{
      boolean ret = false;
      if( lookup( ust, "instmode", `install ) == `update )
	{
	string root = lookup( ust, "selectedRootPartition", "" );
	y2debug( "checkForMdRootFs root=%1", root );
	if( size(root)>0 )
	    {
	    ret = find( root, "/dev/md" )==0;
	    }
	}
      else
        {
	list root = lookup( lookup( ust, "mountpoints", $[] ), "/", $[] );
	y2debug( "checkForMdRootFs root=%1", root );
	ret = select( root, 2, "" ) == "/dev/md";
        }
      y2milestone( "checkForMdRootFs ret=%1", ret );
      return ret;
    };



global define integer GetModifyIdx( map modify_targets, map new )
    ``{
    integer idx = -1;
    foreach( `key, `entry, modify_targets,
	``{
	if( idx == -1 && 
	    entry["use_module"]:""==new["use_module"]:"" &&
	    entry["type"]:""==new["type"]:"" &&
	    entry["name"]:""==new["name"]:"" &&
	    entry["vgname"]:""==new["vgname"]:"" )
	    {
	    idx = key;
	    }
	});
    y2debug( "get_modify_idx new:%1 ret:%2", new, idx );
    return( idx );
    };


    //////////////////////////////////////////////////////////////////////
    // add a new entry into the execution stack "modify_targets"

    global define addTargetModification( map modify_targets, map add_el )
    ``{
        boolean done = false;
	y2milestone( "addTargetModification %1", add_el );
        if( add_el["type"]:"" == "remove_pv" )
	    {
	    map rem = filter( `k, `m, modify_targets,
	                      ``(m["type"]:""=="create_pv" &&
				 m["device"]:""==add_el["device"]:"") );
	    if( size(rem)>0 )
		{
		integer num = select( maplist( `k, `m, rem, ``(k) ), size(rem)-1, -1 );
		modify_targets = removeTargetModification( modify_targets, num );
		y2milestone( "addTargetModification remove pv %1", modify_targets );
		done = true;
		}
	    }
	else if( add_el["type"]:"" == "remove_lv" )
	    {
	    map rem = filter( `k, `m, modify_targets,
	                      ``(m["type"]:""=="create_lv" &&
			         m["vgname"]:""==add_el["vgname"]:"" &&
				 m["name"]:""==add_el["name"]:"") );
	    if( size(rem)>0 )
		{
		integer num = select( maplist( `k, `m, rem, ``(k) ), size(rem)-1, -1 );
		modify_targets = removeTargetModification( modify_targets, num );
		y2milestone( "addTargetModification remove lv %1", modify_targets );
		done = true;
		}
	    rem = filter( `k, `m, modify_targets,
	                  ``(m["type"]:""=="resize_lv" &&
			     m["vgname"]:""==add_el["vgname"]:"" &&
			     m["name"]:""==add_el["name"]:"") );
	    if( size(rem)>0 )
		{
		integer num = select( maplist( `k, `m, rem, ``(k) ), size(rem)-1, -1 );
		modify_targets = removeTargetModification( modify_targets, num );
		y2milestone( "addTargetModification resize lv %1", modify_targets );
		}
	    }
	else if( add_el["type"]:"" == "resize_lv" )
	    {
	    map rem = filter( `k, `m, modify_targets,
	                      ``(m["type"]:""=="resize_lv" &&
			         m["vgname"]:""==add_el["vgname"]:"" &&
				 m["name"]:""==add_el["name"]:"") );
	    if( size(rem)>0 )
		{
		integer num = select( maplist( `k, `m, rem, ``(k) ), size(rem)-1, -1 );
		modify_targets = removeTargetModification( modify_targets, num );
		y2milestone( "addTargetModification resize lv %1", modify_targets );
		}
	    }
	if( !done )
	    {
	    integer max = size( modify_targets );
	    return( add( modify_targets, max+1, add_el ));
	    }
	else
	    {
	    return( modify_targets );
	    }
    };

    //////////////////////////////////////////////////////////////////////
    // remove an entry from the execution stack "modify_targets"
    // renumber the rest of the entries

    global define removeTargetModification( map modify_targets, integer num )
    ``{
	// delete entry
	modify_targets = filter( `k, `v, modify_targets, ``(k != num ) );
	// renumber 1 2 4 5 -> 1 2 3 4
	modify_targets = mapmap( `k, `v, modify_targets, ``{
	    if ( k > num )
	       {
	       return([k-1, v]);
	       }
	    else
	       {
	       return([k, v]);
	       }
	    });
	return( modify_targets );
      }


    ////////////////////////////////////////////////////////////////////////
    // input:
    // win_size_f: new size of wimdows partion in bytes as float
    // cyl_size  : cylinder size
    //
    // output: lentgh of win-region in cylinder

    global define PartedSizeToCly( float win_size_f, integer cyl_size )
    ``{
	float   new_length_f = (win_size_f) / tofloat( cyl_size );
	integer new_length_i = tointeger( new_length_f );

	y2debug("new_length_f: <%1> - new_length_i: <%2>", new_length_f, new_length_i );

	if ( tofloat( new_length_f ) != tofloat( new_length_i ) )
	{
	    new_length_i = new_length_i + 1;	// add 1 cylinder if there is a residual
	}

	return( new_length_i );
    };


    global define convertFsOptionMapInList(map  partition ) ``{

	map fs_options 	  = lookup( partition, "fs_options" , $[]);
	list all_options  = [];

	// do nothing
	if( ! lookup( partition, "format", false) || fs_options == nil || fs_options == $[] )
	{
	    return [];
	    //partition = add( partition, "fs_options" , [] );
	    //return partition;
	}

	list ignore = [ "auto", "default", "none", "" ];

	foreach( `option_key, `option, fs_options , ``{

	    string option_str   = lookup( option, "option_str", "");
	    any    option_value = lookup( option, "option_value", "");
	    boolean option_blank = option["option_blank"]:false;

	    if( is( option_value, string) && option_value != nil )
	    {
		if( ! contains( ignore, option_value ))
		{
		    if( option_blank )
			{
			all_options = add( all_options, option_str);
			all_options = add( all_options, option_value);
			}
		    else
			all_options = add( all_options , option_str + option_value);
		}
	    }
	    else if ( is( option_value, boolean) && option_value != nil )
	    {
		if( option_value )
		    all_options = add( all_options ,  option_str );
	    }
	    else if ( is( option_value, integer) && option_value != nil )
	    {
		if( option_blank )
		    {
		    all_options = add( all_options, option_str);
		    all_options = add( all_options, sformat("%1", option_value));
		    }
		else
		    all_options = add( all_options , option_str + sformat("%1", option_value));
	    }
	});

	//partition = add( partition, "fs_options" , all_options);
	//return partition;
	return all_options;
    };



    /**
     * Make a proposal for a Mountpoint
     * @parm targetMap all targets
     * @return string next mountpoint
     **/
    global define GetMountPointProposal( map targetMap , list not_supported_mount_points )
    ``{
	list base = [ "/", "/usr", "/boot", "/var", "/opt", "/home" ];
	base      = filter(`mount_point , base, ``( ! contains( not_supported_mount_points , mount_point )));

	list free_list = filter( `point, base,
	``{
	    boolean found = false;

	    foreach( `dev, `disk, targetMap, ``{
		map parti = find( `part, lookup( disk, "partitions", []), ``( lookup( part, "mount", "") == point &&
										      lookup( part, "delete", false) == false ));
		if (parti != nil)
		{
		    found = true;
		}
	    });

	    if (found)  return( false );
	    return( true );
	});


	if ( size( free_list ) == 0 )
	{
	    return( "/work" );
	}
	else
	{
	    return( select( free_list, 0, "" ));
	}

    };




    /**
     * Find next free loop device.
     * @return string loop_dev ( e.g.: /dev/loop1 ) or nil
     */
    global define get_loop_dev()
    ``{
	if( Mode::test )
	    return "/dev/loop2";

	integer max_loop_dev= 7;
	integer loop_dev_nb = 0;
	boolean found_free  = false;
	string  loop_dev    = "";

	while( ! found_free  && loop_dev_nb <= max_loop_dev )
	{
	    loop_dev = sformat("/dev/loop%1", loop_dev_nb );
	    loop_dev_nb = loop_dev_nb + 1;

	    // Test loop dev
	    if (SCR::Execute(.target.bash , "/sbin/losetup " + loop_dev ) != 0 )
		found_free = true;

	}


	if ( loop_dev_nb >= 8 )
	{
	    // internal error popup
	    UI::ErrorPopup( _("Too many loop devices (cryptofs ...)") );
	    y2error( "Too many loop devices");
	    return( nil );
	}

	y2milestone("free loop device: %1",loop_dev);

	if( found_free )
	{
	    return( loop_dev );
	}

	return ( nil );
    };



    // check for ppc-PReP/CHRP system, they need a special boot partition

    global define void prepare_ppc_boot_part()    
    ``{
	// Chancing patition-type of /boot to 0x41.
	y2milestone( "Checking partitions for ppc prep chrp " );
	map targets = Storage::GetTargetMap();

	list ppc_partitions = [];
	foreach (`targetdevice,`target, targets, ``{
	    // every disk
	    any partitions = lookup ( target, "partitions", [] );
	    any boot_pentry = nil;
	    ppc_partitions = [];

	    y2debug("Target: %1", targetdevice );

	    foreach (`pentry, partitions, ``{
		string device = Storage::GetDeviceName( targetdevice, lookup (pentry, "nr", 0));
		string mountpoint = lookup (pentry, "mount", "");
		symbol type       = lookup (pentry, "type", `dummy);
		boolean do_format = lookup (pentry, "format", false);
		if (!lookup (pentry, "delete", false)) {		// only those which aren't deleted
		    y2debug("Partition: %1", pentry);
		    if ( mountpoint == "/boot" )
		    {
			boot_pentry = pentry;
			change ( boot_pentry, "fsid", Partitions::fsid_prep_chrp_boot );
			change ( boot_pentry, "fstype", "PPC PReP Boot" );
			change ( boot_pentry, "mount",  "" );
			ppc_partitions = add ( ppc_partitions, boot_pentry );
			y2debug( "Set partition-type of /boot to 0x41" );
		    }
		    else
			ppc_partitions = add ( ppc_partitions, pentry );
		}
		else
		{
		    ppc_partitions = add ( ppc_partitions, pentry );
		}

	    });
	    targets[targetdevice] = target;
	    targets[targetdevice,"partitions"] = ppc_partitions;
	});
	
	Storage::SetTargetMap(  targets);
    };

}
