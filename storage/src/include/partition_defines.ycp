/**
 * File:
 *   partition_defines.ycp
 *
 * Module:
 *   partitioning
 *
 * Summary:
 *   main lib for partitioning defines
 *
 * Authors:
 *   mike <mike@suse.de>
 *
 *
 * $Id$
 *
 */

{
  import "Arch";
  import "Installation";
  import "Wizard";
  import "Storage";
  import "Mode";
  import "Stage";
  import "Partitions";
  import "FileSystems";
  import "Report";

  import "Popup";
//  include "partitioning/custom_part_testdata.ycp";

  textdomain "storage";

    //////////////////////////////////////////////////////////////////////
    // fills up a string to a minimum length

    define string ToLen( integer wide, string str )
    ``{
	while ( size(str) < wide ) str = " " + str;
	return( str );
    };

    //////////////////////////////////////////////////////////////////////
    // converts int to string
    // fills up the  string to a minimum length

    define string ToStringLen( integer wide, integer number )
    ``{
	return( ToLen( wide, sformat("%1", number )));
    };

//////////////////////////////////////////////////////////////////////
// size str to byte
// in: <number>[kKmM][bB]
//
// return "0" if input is invalid
//
// 8 is 8k
// 16K == 16k == 16KB == 16kb
define integer kmgt_str_to_byte( string input )
    ``{
    return( Storage::KmgtStrToByte( input ));
    };


    /*---------------------------------------------------------------------
     * returns for a string a string with a minimum of 9 characters:
     * "1"      -> "       1"
     * "22"     -> "      22"
     * "145"    -> "     145"
     * "2134"   -> "    2134"
     *----------------------------------------------------------------------
     */
    define string sto8string( string str )
    ``{
	integer nb = size( str );
	if ( nb > 8  )   return( sformat( "%1", str ));
	if ( nb > 7  )   return( sformat( " %1", str ));
	if ( nb > 6  )   return( sformat( "  %1", str ));
	if ( nb > 5  )   return( sformat( "   %1", str ));
	if ( nb > 4  )   return( sformat( "    %1", str ));
	if ( nb > 3  )   return( sformat( "     %1", str ));
	if ( nb > 2  )   return( sformat( "      %1", str ));
	if ( nb > 1  )   return( sformat( "       %1", str ));
	return( sformat( "         %1", str ));
    };

/*---------------------------------------------------------------------
 * Convert <number-of-bytes> to XXX.X MB or XXX.X GB or XXX.X TB
 *
 * see also ByteToHumanStringWithZero !
 * Return value: string  "unknown" if input == 0
 *----------------------------------------------------------------------
 */
define string ByteToHumanString ( integer number )
    ``{
    // column description, if disk space is not known
    if( number == 0 ) return( _("unknown") );

    if( number < 1073741824 )
	{
	// < 1 GB
	integer MB    = number / 1048576;
	integer hunKB = (number - (MB * 1048576)) / 104858;
	return( sto8string(sformat( "%1.%2 MB", MB,hunKB )));
	}
    else if ( number < 1099511627776 )
	{
	// < 1 TB
	integer GB    = number / 1073741824;
	integer hunMB = (number - (GB * 1073741824)) / 107374183;
	return( sto8string(sformat( "%1.%2 GB", GB,hunMB )));
	}
    else
        {
        // >= 1 TB
        integer TB    = number / 1099511627776;
        integer hunGB = (number - (TB * 1099511627776)) / 109951162778;
	return( sto8string(sformat( "%1.%2 TB", TB,hunGB )));
        }
    };




    /*---------------------------------------------------------------------
     * get a list of not used mountpoints
     *------------------------------------
     * in:  targetMap
     * out: list of mountpoints for a combobox  ["/usr","/opt", ...]
     *---------------------------------------------------------------------
     */

     define list<string> notUsedMountpoints( map<string,map> targetMap , list<string> all_mountpoints )
     ``{
	 if( all_mountpoints == [] || all_mountpoints == nil  )
	 {
	     all_mountpoints =  (list<string>)FileSystems::suggest_m_points;
	 }


	list mountpoints = 
	    maplist( any dev, map devmap, targetMap,
		     ``{
		     return( maplist( map part, devmap["partitions"]:[], 
				      ``( part["mount"]:"") ));
		     });

	mountpoints = (list) flatten((list<list>)mountpoints);
	mountpoints = union(mountpoints, []); // remove double entrys "" and swap

	list<string> not_used_mountpoints = filter( string mnt, all_mountpoints,
					    ``( !contains( mountpoints, mnt) ));

	 return( not_used_mountpoints );
     };


/*---------------------------------------------------------------------
 * Convert <number-of-bytes> to XXX.X MB or XXX.X GB or XXX.X TB
 *
 * see also ByteToHumanString !
 * Return value: string  "0" if input == 0
 *----------------------------------------------------------------------
 */
define string ByteToHumanStringWithZero ( integer number )
    ``{
    // string or locale
    string  ret = ByteToHumanString( number );

    // label text
    if( ret == _("unknown") )
	{
	// label text, short for Megabyte (MB)
	return( "0 " + _("MB") );
	}
    else
	{
	return( ret );
	}
    };


  /*---------------------------------------------------------------------
   * changeExtendedIdTo15
   *---------------------------------------------------------------------
   * change the fsid of every extended partiton in  the map targets
   * in user_settings from 5 to 15
   *---------------------------------------------------------------------
   */

    ////////////////////////////////////////////////////////////////////////
    // input:
    // win_size_f: new size of wimdows partion in bytes as float
    // cyl_size  : cylinder size
    //
    // output: lentgh of win-region in cylinder

    define integer PartedSizeToCly( float win_size_f, integer cyl_size )
    ``{
	float   new_length_f = (win_size_f) / tofloat( cyl_size );
	integer new_length_i = tointeger( new_length_f );

	y2debug("new_length_f: <%1> - new_length_i: <%2>", new_length_f, new_length_i );

	if ( tofloat( new_length_f ) != tofloat( new_length_i ) )
	{
	    new_length_i = new_length_i + 1;	// add 1 cylinder if there is a residual
	}

	return( new_length_i );
    };


    define list convertFsOptionMapInList(map  partition ) ``{

	map<any,map> fs_options	  = partition["fs_options"]:$[];
	list all_options  = [];

	// do nothing
	if( ! partition["format"]:false || fs_options == nil || fs_options == $[] )
	{
	    return [];
	    //partition = add( partition, "fs_options" , [] );
	    //return partition;
	}

	list ignore = [ "auto", "default", "none", "" ];

	foreach(any option_key, map option, fs_options , ``{

	    string option_str   = option["option_str"]:"";
	    any    option_value = option["option_value"]:"";
	    boolean option_blank = option["option_blank"]:false;

	    if( is( option_value, string) && option_value != nil )
	    {
		if( ! contains( ignore, option_value ))
		{
		    if( option_blank )
			{
			all_options = add( all_options, option_str);
			all_options = add( all_options, option_value);
			}
		    else
			all_options = add( all_options , option_str + (string) option_value);
		}
	    }
	    else if ( is( option_value, boolean) && option_value != nil )
	    {
		if( (boolean) option_value )
		    all_options = add( all_options ,  option_str );
	    }
	    else if ( is( option_value, integer) && option_value != nil )
	    {
		if( option_blank )
		    {
		    all_options = add( all_options, option_str);
		    all_options = add( all_options, sformat("%1", option_value));
		    }
		else
		    all_options = add( all_options , option_str + sformat("%1", option_value));
	    }
	});

	//partition = add( partition, "fs_options" , all_options);
	//return partition;
	y2milestone( "convertFsOptionMapInList ret: %1", all_options );
	return all_options;
    };



    /**
     * Make a proposal for a Mountpoint
     * @parm targetMap all targets
     * @return string next mountpoint
     **/
define string GetMountPointProposal( map<string,map> targetMap, 
                                     list not_supported_mount_points )
    ``{
    list<string> base = FileSystems::suggest_m_points;
    base = filter( string mount_point, base, 
		   ``( !contains( not_supported_mount_points, mount_point )));
    list free_list = filter( string point, base,
	``{
	boolean found = false;

	foreach(string dev, map disk, targetMap, 
	    ``{
	    map parti = (map) find(map part, disk["partitions"]:[], 
	                      ``( part["mount"]:"" == point ));
	    if (parti != nil)
		{
		found = true;
		}
	    });

	return( !found );
	});

    return( Mode::normal()?"":(free_list[0]:"") );
    };

define string evms_texts_evms_nonevms()
    ``{
    string t = 
_("It is normally not a good idea to use EVMS and non-EVMS
entities on the same disk. 
While it is possible in principle and may make sense
for experienced users, it also can easily create 
unexpected problems.

Really do this?
");
    return( t );
    }

define string evms_texts_evms_lvm()
    {
    string t = 
_("It is normally not a good idea to use EVMS and LVM
on the same system.
While it is possible in principle and may make sense
for experienced users, it also can easily create 
unexpected problems.

Really do this?
");
    return( t );
    }
}
