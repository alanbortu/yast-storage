/**
 * File:
 *   lvm_pv_lib.ycp
 *
 * Module: 
 *    configuration of lvm: lib for handling of physical volumes
 *
 * Summary:
 *
 * Authors:
 *   mike <mike@suse.de>
 *
 *
 * $Id$
 *
 */


{
     textdomain "storage";
     import "Storage";
     import "Partitions";
     import "Package";

     include "partitioning/lvm_lib.ycp";
     include "partitioning/lvm_lv_lib.ycp";
     
    //////////////////////////////////////////////////////////////////////
    // add a partition to the current volume group
    //
    // 	   $[ 1 : $[  "use_module" : "lvm_ll"
    // 		      "type"       : "create_pv",
    // 		      "vgname"     : "system"     -- optional, wenn da dann vgextend nach pvcreate
    // 		      "device"     : "/dev/sda1"
    //
    //   !!!!!!! changes targetMap by reference !!!!!!
    // 	
    //////////////////////////////////////////////////////////////////////

define boolean addPhysicalVolume( map<string,map> targetMap, string id, 
				  string current_vg )
    ``{
    map partition = Storage::GetPartition( targetMap, id );
    y2milestone( "partition %1", partition );
    
    if( partition["fsid"]:0 != Partitions::fsid_lvm && 
        contains( [`primary, `logical], partition["type"]:`none ) )
	{
	Storage::SetPartitionId( id, Partitions::fsid_lvm );
	}
    Storage::SetPartitionMount( id, "" );
    Storage::SetPartitionFormat( id, false, `none );
    boolean ret = Storage::ExtendLvmVg( current_vg, id );
    return( ret );
    };
	

define boolean removePhysicalVolume( map<string,map> targetMap, string id,
                                 string current_vg )
    ``{
    map partition = Storage::GetPartition( targetMap, id );

    if( partition["fsid"]:0 == Partitions::fsid_lvm &&
        contains( [`primary, `logical], partition["type"]:`none ) )
	{
	Storage::UnchangePartitionId( id );
	}
    boolean ret = Storage::ReduceLvmVg( current_vg, id );
    if( !ret )
	{
	// message popup
	Popup::Error(_("If you remove the selected device from the volume group,
there will not be enough space for all logical volumes in 
this group.  To delete the volume group completely, remove 
its logical volumes first.
"));
	}
    return( ret );
    };
	

//////////////////////////////////////////////////////////////////////
// belongs the the partition "id" already to a volume group
//////////////////////////////////////////////////////////////////////

define boolean isItemPv( map<string,map> tg, string id )
    ``{
    map part = $[];
    if( haskey( tg, id ))
	part = tg[id]:$[];
    else
	part = Storage::GetPartition( tg, id );
    return( part["used_by_type"]:`UB_NONE == `UB_LVM ||
            part["used_by_type"]:`UB_NONE == `UB_EVMS );
    };


//////////////////////////////////////////////////////////////////////
// belongs the the partition "id" already to a volume group
// if YES: popup a proper Message and return(false)
//////////////////////////////////////////////////////////////////////

define boolean CheckItemIsNotPv( map<string,map> tg, string id )
    ``{
    if( !isItemPv(tg,id) )
	{
	//////////////
	return( true );
	//////////////
	}

    // error case:
    if( id != nil )
	{
	// message popup
	Popup::Message(sformat(_("The item %1 is already a physical volume.
To add it to a different volume group,
remove it from its current volume group
then add it to the new group.
"), id ));
	}
    else
	{
	// message popup
	Popup::Message(_("You have to select one device in the table"));
	}
    return( false );
    };

    //////////////////////////////////////////////////////////////////////
    // belongs the the partition "id" already to a volume group?
    // if NO: popup a proper Message and return(false)
    //////////////////////////////////////////////////////////////////////

define boolean CheckItemIsPv( map<string,map> tg, string id )
    ``{
    if ( isItemPv(tg,id) )
	{
	//////////////
	return( true );
	//////////////
	}

    // error case: 
    if ( id != nil )
	{
	// Message popup
	Popup::Message(sformat(_("The item %1 cannot be removed.
It does not belong to a volume group.
"), id ));
	}
    else
	{
	//Message popup
	Popup::Message(_("You have to select one device in the table"));
	}
    return( false );
    };


/////////////////////////////////////////////////////////////////
// Get all partitions, we can probably use as physical volumes
// Add needed information: disksize 
define list<map> get_possible_pvs( map<string,map> targetMap )
    ``{
    list<map> ret = [];
	
    //////////////////////////////////////////////////////////////////////
    // add the devicename i.e /dev/hda1 or /dev/system/usr to partition list
    // and the device key  <subdevice>/<maindevice> i.e. 1//dev/hda
    
    targetMap = mapmap( string dev, map devmap, targetMap,
	``{
	list partitions = maplist( map part, devmap["partitions"]:[],
	    ``{
	    part["maindev"] = dev;
	    return( part );
	    });
	return( $[ dev: add(devmap, "partitions", partitions) ] );
	});

    ////////////////////////////////////////////////////////////
    // Look for all partitions:
    // not LVM ( here I mean /dev/<lvm_volumegroup>/<lv> entries!
    //           there are only the lv's in the targetMap under /dev/<lvm_volumegroup>/<lv> !)
    // no mountpoint
    // id 0x83 or 0x8e or 0xfe

    list types_no = [ `lvm, `evms, `extended ];
    list fsids = [ Partitions::fsid_lvm, Partitions::fsid_raid,
		   Partitions::fsid_native ];
    list ubs = [ `UB_NONE, `UB_LVM, `UB_EVMS ];

    foreach( string dev, map devmap, targetMap,
	``{
	y2milestone( "get_possible_pvs parts:%1", devmap["partitions"]:[] );
	list<map> parts = 
	    filter( map part, devmap["partitions"]:[],
		    ``( size(part["mount"]:"")==0 &&
			!contains( types_no, part["type"]:`primary ) &&
			contains( ubs, part["used_by_type"]:`UB_NONE ) &&
			(part["type"]:`primary==`sw_raid||
			 part["type"]:`primary==`dm||
			contains( fsids, part["fsid"]:0 ))));
	y2milestone( "get_possible_pvs filter:%1", parts );
	if( devmap["used_by_type"]:`UB_NONE!=`UB_NONE )
	    {
	    parts = [];
	    y2milestone( "get_possible_pvs no parts, disk used by %1 %2",
	                 devmap["used_by_type"]:`UB_NONE, devmap["used_by"]:"" );
	    }
	if( size(devmap["partitions"]:[])==0 && 
	    Storage::IsPartType(devmap["type"]:`CT_UNKNOWN) &&
	    contains( ubs, devmap["used_by_type"]:`UB_NONE ))
	    {
	    map p = $[ "device":dev, "maindev":dev, 
	               "size_k":devmap["size_k"]:0 ];
	    if( devmap["used_by_type"]:`UB_NONE != `UB_NONE )
		{
		p["used_by_type"] = devmap["used_by_type"]:`UB_NONE;
		p["used_by"] = devmap["used_by"]:"";
		}
	    parts = [ p ];
	    }
	ret = (list<map>)merge( ret, parts );
	});
    ret = maplist( map p, ret,
	``{
	p["used_by"] = lvmVg( p["used_by"]:"" );
	return( p );
	});
    y2milestone( "get_possible_pvs ret %1", ret );
    return( ret );
    };


    
    //////////////////////////////////////////////////////////////////////
    // partition list to widget table
    // in:
    // [  $["fsid":Partitions::fsid_lvm,
    //	  "fstype":"LVM",
    //	  "nr":"var",
    //	  "region":[255, 16],
    //	  "type":`primary],
    //	  $[
    //	   "fsid":131,
    //	   "fstype":"Linux native",
    //	   "nr":4, "region":[271, 844],
    //    ...
    //
    // out:
    // [
    // 	`item(`id("/dev/hda1"), "/dev/hda1 ",   " 2G ",  " LVM ",   " system"),
    // 	`item(`id("/dev/hda2"), "/dev/hda2 ",   " 1G ",  " Linux ", " ")
    // ];

define list get_pv_widget_table( list<map> possPvList )
    ``{
    list    ret = [];

    possPvList = 
    sort( map x, map y, possPvList,
	  ``{
	  if( x["maindev"]:"" == y["maindev"]:"")
	      {
	      if( haskey( x, "nr" ))
		  return( x["nr"]:0 < y["nr"]:0);
	      else
		  return( x["name"]:"" < y["name"]:"");
	      }
	  else
	      {
	      return( x["maindev"]:"" < y["maindev"]:"" );
	      }
	  });
    
    return( maplist( map p, possPvList,
	 ``{
	     return(`item( `id(p["device"]:"--"),
			   p["device"]:"--",
			   ByteToHumanStringWithZero(p["size_k"]:0*1024),
			   p["fstype"]:"--",
			   p["used_by"]:"--"
			   ));
	    }
	  ));
    };

    

/**
 * Check if the user can delete the partition.
 * -> Existing LVM partition with volume group
 * -> size of volume group to small for all logical partition
 */
define boolean check_pv_delete( map<string,map> targetMap, string id, 
                                string current_vg ) 
    ``{
    boolean ret = true;
    y2milestone( "check_pv_delete id %1 current_vg: %2", id, current_vg );
    integer num_pvs = size( filter( map p, get_possible_pvs(targetMap),
				    ``(p["used_by"]:""==current_vg)));
    y2milestone( "check_pv_delete num_pvs:%1", num_pvs );
    if( num_pvs<=1 )
	{
	// message popup
	Popup::Error(_("You cannot remove the last PV from a volume group.
Delete the volume group completely instead.
"));
	y2milestone( "check_pv_delete `nodelete" );
	ret = false;
	}

    y2milestone( "check_pv_delete ret:%1", ret );
    return( ret );
    }
    

boolean check_vgname_dev( string vgname )
    {
    boolean ret = true;
    string devdir = "/dev/" + vgname;
    map stat = (map) SCR::Read( .target.stat, devdir );
    y2milestone( "check_vgname_dev stat %1", stat );
    if( size(stat)>0 )
	{
	ret = stat["isdir"]:false;
	if( ret )
	    {
	    map out = (map)SCR::Execute( .target.bash_output, 
	                                 "find "+devdir+" ! -type l | sed 1d" );
	    ret = size(out["stdout"]:"")==0;
	    }
	}
    y2milestone( "check_vgname_dev %1 ret %2", vgname, ret );
    return( ret );
    }
}

