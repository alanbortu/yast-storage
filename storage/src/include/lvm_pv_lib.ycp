/*
 * Copyright (c) 2012 Novell, Inc.
 *
 * All Rights Reserved.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as published
 * by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
 * more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, contact Novell, Inc.
 *
 * To contact Novell about this file by physical or electronic mail, you may
 * find current contact information at www.novell.com.
 */

/**
 * File:
 *   lvm_pv_lib.ycp
 *
 * Module: 
 *    configuration of lvm: lib for handling of physical volumes
 *
 * Summary:
 *
 * Authors:
 *   mike <mike@suse.de>
 *
 *
 * $Id$
 *
 */


{
     textdomain "storage";
     import "Storage";
     import "Partitions";

     include "partitioning/lvm_lib.ycp";
     include "partitioning/lvm_lv_lib.ycp";
     
    //////////////////////////////////////////////////////////////////////
    // add a partition to the current volume group
    //
    // 	   $[ 1 : $[  "use_module" : "lvm_ll"
    // 		      "type"       : "create_pv",
    // 		      "vgname"     : "system"     -- optional, wenn da dann vgextend nach pvcreate
    // 		      "device"     : "/dev/sda1"
    //
    //   !!!!!!! changes targetMap by reference !!!!!!
    // 	
    //////////////////////////////////////////////////////////////////////

// used by autoyast
define boolean addPhysicalVolume( map<string,map> targetMap, string id, 
				  string current_vg )
    ``{
    map partition = Storage::GetPartition( targetMap, id );
    y2milestone( "partition %1", partition );
    
    if( partition["fsid"]:0 != Partitions::fsid_lvm && 
        contains( [`primary, `logical], partition["type"]:`none ) )
	{
	Storage::SetPartitionId( id, Partitions::fsid_lvm );
	}
    Storage::SetPartitionMount( id, "" );
    Storage::SetPartitionFormat( id, false, `none );
    boolean ret = Storage::ExtendLvmVg( current_vg, id );
    return( ret );
    };


/////////////////////////////////////////////////////////////////
// Get all partitions, we can probably use as physical volumes
// Add needed information: disksize 
define list<map> get_possible_pvs( map<string,map> targetMap )
    ``{
    list<map> ret = [];
	
    //////////////////////////////////////////////////////////////////////
    // add the devicename i.e /dev/hda1 or /dev/system/usr to partition list
    // and the device key  <subdevice>/<maindevice> i.e. 1//dev/hda
    
    targetMap = mapmap( string dev, map devmap, targetMap,
	``{
	list partitions = maplist( map part, devmap["partitions"]:[],
	    ``{
	    part["maindev"] = dev;
	    return( part );
	    });
	return( $[ dev: add(devmap, "partitions", partitions) ] );
	});

    ////////////////////////////////////////////////////////////
    // Look for all partitions:
    // not LVM ( here I mean /dev/<lvm_volumegroup>/<lv> entries!
    //           there are only the lv's in the targetMap under /dev/<lvm_volumegroup>/<lv> !)
    // no mountpoint
    // id 0x83 or 0x8e or 0xfe

    list types_no = [ `lvm, `extended ];
    list fsids = [ Partitions::fsid_lvm, Partitions::fsid_raid,
		   Partitions::fsid_native ];
    list allowed_enc_types = [ `none, `luks ];

    foreach( string dev, map devmap, targetMap,
	``{
	y2milestone( "get_possible_pvs parts:%1", devmap["partitions"]:[] );
	list<map> parts = 
	    filter( map part, devmap["partitions"]:[],
		    ``( size(part["mount"]:"")==0 &&
			!contains( types_no, part["type"]:`primary ) &&
			contains(allowed_enc_types, part["enc_type"]:`none) &&
			(!Storage::IsUsedBy(part) || part["used_by_type"]:`UB_NONE==`UB_LVM) &&
			(part["type"]:`primary==`sw_raid||
			 part["type"]:`primary==`dm||
			contains( fsids, part["fsid"]:0 ))));
	y2milestone( "get_possible_pvs filter:%1", parts );
	if( devmap["used_by_type"]:`UB_NONE!=`UB_NONE )
	    {
	    parts = [];
	    y2milestone( "get_possible_pvs no parts, disk used by %1 %2",
	                 devmap["used_by_type"]:`UB_NONE, devmap["used_by_device"]:"" );
	    }
	if( size(devmap["partitions"]:[])==0 && 
	    Storage::IsPartType(devmap["type"]:`CT_UNKNOWN) &&
	    (!Storage::IsUsedBy(devmap) || devmap["used_by_type"]:`UB_NONE==`UB_LVM))
	    {
	    map p = $[ "device":dev, "maindev":dev, 
	               "size_k":devmap["size_k"]:0 ];
	    if( devmap["used_by_type"]:`UB_NONE != `UB_NONE )
		{
		p["used_by_type"] = devmap["used_by_type"]:`UB_NONE;
		p["used_by_device"] = devmap["used_by_device"]:"";
		}
	    if (haskey(devmap, "used_by"))
		p["used_by"] = devmap["used_by"]:[];
	    parts = [ p ];
	    }
	ret = (list<map>)merge( ret, parts );
	});
    y2milestone( "get_possible_pvs ret %1", ret );
    return( ret );
    };


boolean check_vgname_dev( string vgname )
    {
    boolean ret = true;
    string devdir = "/dev/" + vgname;
    map stat = (map) SCR::Read( .target.stat, devdir );
    y2milestone( "check_vgname_dev stat %1", stat );
    if( size(stat)>0 )
	{
	ret = stat["isdir"]:false;
	if( ret )
	    {
	    map out = (map)SCR::Execute( .target.bash_output, 
	                                 "find "+devdir+" ! -type l | sed 1d" );
	    ret = size(out["stdout"]:"")==0;
	    }
	}
    y2milestone( "check_vgname_dev %1 ret %2", vgname, ret );
    return( ret );
    }
}
