/**
 * File:
 *   lvm_pv_lib.ycp
 *
 * Module: 
 *    configuration of lvm: lib for handling of physical volumes
 *
 * Summary:
 *
 * Authors:
 *   mike <mike@suse.de>
 *
 *
 * $Id$
 *
 */


{
     textdomain "storage";
     import "Storage";
     import "Partitions";

     include "partitioning/lvm_lib.ycp";
     include "partitioning/lvm_lv_lib.ycp";
     
    //////////////////////////////////////////////////////////////////////
    // get the current summ of physical volumes which belong to volume
    // group "current_vg" 
    /////////
    //
    // [  $["fsid":Partitions::fsid_lvm,
    //	  "fstype":"LVM",
    //	  "nr":"var",
    //	  "region":[255, 16],
    //	  "type":`primary],
    //	  $[
    //	   "fsid":131,
    //	   "fstype":"Linux native",
    //	   "nr":4, "region":[271, 844],
    //    ...
    //
    //  out: "10.6 GB"
     
global define get_vg_size( list partition_list, string current_vg, 
                           symbol `what )
    ``{
    integer sum_byte = vg_size( partition_list, current_vg );
    if( what == `string )
	return( ByteToHumanStringWithZero( sum_byte ));
    return sum_byte;
    };
		
	 

    //////////////////////////////////////////////////////////////////////
    // add a partition to the current volume group
    //
    // 	   $[ 1 : $[  "use_module" : "lvm_ll"
    // 		      "type"       : "create_pv",
    // 		      "vgname"     : "system"     -- optional, wenn da dann vgextend nach pvcreate
    // 		      "device"     : "/dev/sda1"
    //
    //   !!!!!!! changes targetMap by reference !!!!!!
    // 	
    //////////////////////////////////////////////////////////////////////

    global define addPhysicalVolume( map    modify_targets,
				     map    targetMap,
				     string id,
				     string current_vg )
    ``{
	string maindev = Storage::GetMainDevKey(id);  // i.e. /dev/hda for /dev/hda1
	string subdev  = Storage::GetSubDevIndex( id);  // i.e. 1        for /dev/hda1

	map  disk       = lookup( targetMap, maindev, $[] );
	list partitions = lookup( disk, "partitions", []  );
	map partition   = select( filter( `part, partitions,
					  ``( (sformat("%1", lookup(part, "nr", "")) == subdev)
					       && (lookup( part, "delete", false) == false) ) ), 0, $[]);
	
	

	
	if( lookup( partition, "fsid", 0 )!=Partitions::fsid_lvm )
	    {
	    if( ! lookup( partition, "change_fsid", false ))
		{
		change ( partition , "change_fsid", true );
		change ( partition , "ori_fsid",    lookup( partition, "fsid", 0 ));
		change ( partition , "ori_fstype" , lookup( partition, "fstype" ,""));
		}

	    
	    /*
	    /////////////////////////////////////////////////
	    // new entry in execution stack "modify_targets"
	
	    map new_chang_fsid = $[
				  "use_module" : "fdisk_ll",
				  "type"       : "change_id",
				  "id"     : Partitions::fsid_lvm ];
	    new_chang_fsid = add( new_chang_fsid, "nr", lookup(partition, "nr") );
	    new_chang_fsid = add( new_chang_fsid, "disk", maindev );
	
	    modify_targets = addTargetModification( modify_targets, new_chang_fsid );
	    */
	}

        // if we have /data? the automatic generated mountpoint: delete it  
	change( partition , "mount", "" );
	if( haskey( partition, "format" ))
	    {
	    change( partition, "format", false );
	    }
	
	/////////////////////////////////////////////////
	// new entry in execution stack "modify_targets"
	
	map new_create_pv = $[
			      "use_module" : "lvm_ll",
			      "type"       : "create_pv",
			      "vgname"     : current_vg,
			      "device"     : Storage::GetDeviceName(maindev,partition["nr"]:"") ];
	
	modify_targets = addTargetModification( modify_targets, new_create_pv );
	y2debug( "EEE s %1", modify_targets);


	/////////////////////////////////////////////////
	// change targetMap

	change( partition, "fsid",      Partitions::fsid_lvm);
	change( partition, "fstype",    "Linux LVM");
	change( partition, "lvm_group", current_vg);


	return( $[ "modify_targets":modify_targets, "targets":targetMap, "error":false ]);
    };
	

    //////////////////////////////////////////////////////////////////////
    // removes a partition from its current volume group
    //
    // 	   $[ 1 : $[  "use_module" : "lvm_ll"
    // 		      "type"       : "remove_pv",
    // 		      "vgname"     : "system"
    // 		      "device"     : "/dev/sda1"
    //
    //////////////////////////////////////////////////////////////////////

global define removePhysicalVolume( map modify_targets, map targetMap,
				    string id, string current_vg )
    ``{
    string maindev = Storage::GetMainDevKey(id);  // i.e. /dev/hda for /dev/hda1
    string subdev  = Storage::GetSubDevIndex(id); // i.e. 1        for /dev/hda1

    map partition  = Storage::GetPartition( targetMap, 
                                            Storage::GetDeviceName(maindev, tointeger(subdev)) );

    if( partition["change_fsid"]:false )
	{
	partition["fsid"] = partition["ori_fsid"]:0;
	partition["fstype"] = partition["ori_fstype"]:"";
	partition = filter( `key, `value, partition, 
			    ``( key != "ori_fsid" && 
				key != "change_fsid" && 
				key != "ori_fstype" ));
	}

    partition = filter( `key, `val, partition, ``( key != "lvm_group" ));

    targetMap = Storage::SetPartition( targetMap, partition );

    map new_remove_pv = $[
			  "use_module" : "lvm_ll",
			  "type"       : "remove_pv",
			  "vgname"     : current_vg,
			  "device"     : Storage::GetDeviceName(maindev,partition["nr"]:"") ];
	
    modify_targets = addTargetModification( modify_targets, new_remove_pv );

    return( $[ "modify_targets":modify_targets, "targets":targetMap, 
               "error":false ] );
    };
	

    //////////////////////////////////////////////////////////////////////
    // belongs the the partition "id" already to a volume group
    // if YES: popup a proper Message and return(false)
    //////////////////////////////////////////////////////////////////////

    global define CheckItemIsNotPv( any id )
    ``{
	if ( ! isItemPv(id) )
	{
	    //////////////
	    return( true );
	    //////////////
	}

	// error case:
	if ( id != nil )
	{
	    // message popup
	    UI::MessagePopup(sformat(_("The item %1%2 is already a physical volume.
To add it to a different volume group,
remove it from its current volume group
then add it to the new group.
"), Storage::GetMainDevKey(id), Storage::GetSubDevIndex(id)));
	}
	else
	{
	    // message popup
	    UI::MessagePopup(_("You have to select one device in the table"));
	}
	
	return( false );
    };


    
    //////////////////////////////////////////////////////////////////////
    // belongs the the partition "id" already to a volume group?
    // if NO: popup a proper Message and return(false)
    //////////////////////////////////////////////////////////////////////

    global define CheckItemIsPv( any id )
    ``{
	if ( isItemPv(id) )
	{
	    //////////////
	    return( true );
	    //////////////
	}

	// error case: 
	if ( id != nil )
	{
	    // Message popup
	    UI::MessagePopup(sformat(_("The item %1%2 cannot be removed.
It does not belong to a volume group.
"), Storage::GetMainDevKey(id), Storage::GetSubDevIndex(id)));
	}
	else
	{
	    //Message popup
	    UI::MessagePopup(_("You have to select one device in the table"));
	}

	return( false );
    };
    
    

    //////////////////////////////////////////////////////////////////////
    // belongs the the partition "id" already to a volume group
    //////////////////////////////////////////////////////////////////////

    global define isItemPv( any id )
    ``{
        map part = Storage::IdFromTarget( targetMap, id );
	if ( part["lvm_group"]:"" == "" )
	    {
	    return( false );
	    }
	else
	    {
	    return( true );
	    }
    };


/////////////////////////////////////////////////////////////////
// Get all partitions, we can probably use as physical volumes
// Add needed information: devkey, is_lv, disksize 

global define get_possible_pvs( map targetMap )
    ``{
    list ret = [];
	
    //////////////////////////////////////////////////////////////////////
    // add the devicename i.e /dev/hda1 or /dev/system/usr to partition list
    // and the device key  <subdevice>/<maindevice> i.e. 1//dev/hda
    
    targetMap = mapmap( `dev, `devmap, targetMap,
	``{
	boolean is_lvm_vg  = devmap["is_lvm_vg"]:false;
	integer cyl_size   = devmap["cyl_size"]:1000000;
					    
	list partitions = maplist( `part, devmap["partitions"]:[],
	    ``{
	    integer bytes_of_part = 0;
	    integer nb_cyl = part["region",1]:0;
    
	    bytes_of_part = nb_cyl * cyl_size;
	    part["size_byte"] = bytes_of_part;
	    part["size_str"] = ByteToHumanStringWithZero(bytes_of_part);
	    if( is_lvm_vg )
		{
		part["is_lv"] = true;
		}
	    part["maindev"] = dev;
	    part["devkey"] = sformat( "%2/%1", dev, part["nr"]:"");
	    return( part );
	    });
		
	return( [ dev, add(devmap, "partitions", partitions) ] );
	});

    ////////////////////////////////////////////////////////////
    // Look for all partitions:
    // not LVM ( here I mean /dev/<lvm_volumegroup>/<lv> entries!
    //           there are only the lv's in the targetMap under /dev/<lvm_volumegroup>/<lv> !)
    // no mountpoint
    // id 0x83 or 0x8e or 0xfe
    // RAID

    foreach( `dev, `devmap, targetMap,
	``{
	ret = add( ret, 
		   filter( `part, devmap["partitions"]:[],
			   ``(( part["mount"]:"" == "" ||
				substring(part["mount"]:"", 0, 5) == "/data" )
			     &&
			     ( !part["is_lv"]:false && 
			       part["raid_name"]:"" == "" )
			     &&
			       !part["delete"]:false 
			     &&
			       ( part["fsid"]:0 == Partitions::fsid_lvm ||
				 part["fsid"]:0 == Partitions::fsid_raid ||
				 part["fsid"]:0 == Partitions::fsid_native )
		 )));
	});

    return( flatten(ret) );
    };


    
    //////////////////////////////////////////////////////////////////////
    // partition list to widget table
    // in:
    // [  $["fsid":Partitions::fsid_lvm,
    //	  "fstype":"LVM",
    //	  "nr":"var",
    //	  "region":[255, 16],
    //	  "type":`primary],
    //	  $[
    //	   "fsid":131,
    //	   "fstype":"Linux native",
    //	   "nr":4, "region":[271, 844],
    //    ...
    //
    // out:
    // [
    // 	`item(`id("/dev/hda1"), "/dev/hda1 ",   " 2G ",  " LVM ",   " system"),
    // 	`item(`id("/dev/hda2"), "/dev/hda2 ",   " 1G ",  " Linux ", " ")
    // ];

    global define get_pv_widget_table( list possPvList )
    ``{

	list    ret = [];

	possPvList = sort( `x, `y, possPvList,
		     ``{
			 if (lookup(x,"maindev","") == lookup(y,"maindev",""))
			 {
			     // return( sformat("%1",lookup(x,"nr")) <= sformat("%1",lookup(y,"nr")));
			     return( lookup(x,"nr","") <= lookup(y,"nr",""));
			 }
			 else
			 {
			     return( lookup(x,"maindev", "") <= lookup(y,"maindev", ""));
			 }
		     });
	
	
    return( maplist( `partition, possPvList,
	     ``{
		 return(`item( `id(partition["devkey"]:"--"),
			       partition["device"]:"--",
			       partition["size_str"]:"--",
			       partition["fstype"]:"--",
			       partition["lvm_group"]:"--"
			       ));
		}
	  ));
    };

    

    /**
     * Check if the user can delete the partition.
     * -> Existing LVM partition with volume group
     * -> size of volume group to small for all logical partition
     */
global define check_pv_delete( map targetMap, string id, string current_vg ) 
    ``{
    string maindev = Storage::GetMainDevKey(id);  // i.e. /dev/hda for /dev/hda1
    string subdev  = Storage::GetSubDevIndex(id); // i.e. 1        for /dev/hda1
    map partition  = Storage::GetPartition( targetMap, 
                                            Storage::GetDeviceName(maindev, tointeger(subdev)) );

    y2debug( "part %1 current_vg: %2", partition, current_vg );

    //new partition should be deleted -> check size for volume group
    //total size of volume group  
    integer vg_siz = get_vg_size( get_possible_pvs(targetMap), current_vg,
                                  `integer );
    y2debug( "vg_size : %1", vg_siz);

    //used size (sum logical partitions)
    list parts = get_lvs_and_mounted_partitions( targetMap, false, current_vg );
    y2debug( "parts=%1 current_vg=%2", parts, current_vg );
	    
    integer used_size = select( get_lv_size_info( targetMap, parts, current_vg ) , 0, 0);
	
    // size of the seleted partition
    integer bytes_of_part = 0;
    integer nb_cyl = partition["region",1]:0;
	
    bytes_of_part = nb_cyl * targetMap[maindev,"cyl_size"]:1000000; 
	
    if( vg_siz - bytes_of_part < used_size)
	{
	// message popup
	UI::ErrorPopup(_("If you remove the selected partition from the volume group,
there will not be enough space for all logical volumes in this group.
To delete the volume group completely, remove its
logical volumes first.
"));
	return `nodelete;
	}
	    
    return `delete;
    }
    
}

