/**
 * Module:		auto_part_create.ycp
 *
 * Authors:		Andreas Schwab (schwab@suse.de)
 *			Klaus Kämpf (kkaempf@suse.de)
 *
 * Purpose:		This module creates the neccessary partitions
 *			in the targetMap
 *
 * $Id$
 *
 * used globals
 *
 * integer first_logical_nr
 *
 *
 * defined functions
    define create_partitions (list partitions, list selected_region)
 */
{
    textdomain "storage";

    import "Storage";
    import "Partitions";


    // --------------------------------------------------------------
    // Add new partition entries for the boot, swap and root parititions.
    // Each new entry is marked with "create":true. They key "mount"
    // contains the mount point or "swap" for the swap partition.

    global define create_partitions (list partitions, list selected_region)
    ``{
	y2milestone ("create_partitions (partitions %1\nselected_region %2)", partitions, selected_region);
	partitions = filter (`pentry, partitions, ``(lookup (pentry, "type", `unknown) != `free));
	partitions = renumber_logical_partitions (partitions);
	symbol ptype = `primary;
	integer last_pnr = 0;

	boolean empty_disk = (partitions == []);

	map absd_partition = $["create":true, "format":true,
			       "type": `primary, "fsid":Partitions::fsid_empty,
			       "nr":3,
			       "region":full_region ];

	// If any partitions are left to be preserved, create the new
	// partitions in an extended partition.

	if (selected_region != full_region)
	{
	    if (partition_type == `FAT)
	    {
		ptype = `logical;
	    }
	    else
	    {
		// If we don't have a FAT partition_type get the
		// last used partition number

		list used_primaries =
		  maplist (`pentry,
			 filter (`pentry, partitions, ``(!lookup (pentry, "delete", false))),
			 ``(lookup (pentry, "nr", 0)));

		integer unused_primary_pnr = 1;

		while (contains (used_primaries, unused_primary_pnr))
		{
		    unused_primary_pnr = unused_primary_pnr + 1;
		}

		last_pnr = unused_primary_pnr - 1;
	    }
	}

	// Add the extended partition if necessary

	if (ptype == `logical)
	{

	    if (!contains_extended (partitions))
	    {

		// Find unused primary number
		list used_primaries =
		    maplist (`pentry, filter (`pentry, partitions,
				          ``(!lookup (pentry, "delete", false))),
			 ``(lookup (pentry, "nr", 0)));

		integer unused_primary_pnr = 1;

		while (contains (used_primaries, unused_primary_pnr))
		    unused_primary_pnr = unused_primary_pnr + 1;

		// create new extended partition
		// if it starts above cyl 1024, create it as fsid_extended_win
		integer ext_fsid = Partitions::fsid_extended;
		if (start_of_region (selected_region) >= 1024)
		{
		    ext_fsid = Partitions::fsid_extended_win;
		}
		partitions = add (partitions,
				$[ "create":true,
				   "type":`extended, "fsid":ext_fsid,
				   "nr":unused_primary_pnr,
				   "region":selected_region ]);

		last_pnr = max_primary;
	    }
	    else
	    {
		// Find the last used logical partition number.
		// We know that these partitions are numbered contiguously
		last_pnr = first_logical_nr - 1;
		foreach (`pentry, partitions, ``{
		    if (!lookup (pentry, "delete", false)
			&& (lookup (pentry, "type", `unknown) == `logical))
			last_pnr = lookup (pentry, "nr", 0);
		});
	    }
	} // ptyle == `logical
	

	list boot_region = [ select(selected_region, 0,0), size_to_units (size_of_boot) ];
	list swap_region = [ end_of_region (boot_region), size_to_units (size_of_swap) ];
	list root_region = [ end_of_region (swap_region),
			   end_of_region (selected_region) - end_of_region (swap_region) ];
	last_pnr = last_pnr + 1;

	// skip #3 on bsd

	if ((partition_type == `ABSD || partition_type == `SBSD)
	    && (last_pnr == 3))
	{
	    last_pnr = last_pnr + 1;
	}

	// add /boot for FAT and SBSD partitions

	if ((partition_type == `FAT) || (partition_type == `SBSD))
	{
	    map boot_part = $[ "create":true, "format":true,
			       "type": ptype, "fsid":Partitions::fsid_boot,
			       "nr":last_pnr,
			       "region":boot_region,
			       "mount":"/boot",
			       "used_fs":Partitions::default_boot_fs];
	    partitions = add (partitions, boot_part);
	    last_pnr = last_pnr + 1;
	}

	// skip #3 on bsd

	if ((partition_type == `ABSD || partition_type == `SBSD)
	    && (last_pnr == 3))
	{
	  last_pnr = last_pnr + 1;
	}

	partitions = add (partitions,
			$[ "create":true, "format":true,
			   "type": ptype, "fsid":Partitions::fsid_swap,
			   "nr":last_pnr,
			   "region":swap_region,
			   "mount":"swap" ]);
	last_pnr = last_pnr + 1;

	// skip #3 on bsd

	if ((partition_type == `ABSD || partition_type == `SBSD)
	    && (last_pnr == 3))
	{
	  last_pnr = last_pnr + 1;
	}

	partitions = add (partitions,
			$[ "create":true, "format":true,
			   "type": ptype, "fsid":Partitions::fsid_native,
			   "used_fs" : Partitions::default_fs,
			   "nr":last_pnr,
			   "region":root_region,
			   "mount":"/" ]);
	last_pnr = last_pnr + 1;

	// create #3 on bsd if needed

	if ((partition_type == `ABSD || partition_type == `SBSD)
	     && (last_pnr == 3)
	     && empty_disk)
	{
	    partitions = add (partitions, absd_partition);
	}
	
	// Add flag whether using the entire disk
	Storage::SetWholeDisk( selected_region == full_region );

	return( partitions );

    }; // create_partitions

}
