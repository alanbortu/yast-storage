/**
 * Module: 		target_modify.ycp
 *
 * Authors:		Thomas Fehr (fehr@suse.de) 
 *			Michael Hager (mike@suse.de)
 *
 * Purpose:
 * Start of new disk preparation
 *			
 *			
 *
 * $Id$
 */

{
    textdomain "storage";

    import "Storage";
    import "Partitions";

    include "ui/common_messages.ycp";
    include "ui/common_functions.ycp";
    include "partitioning/write_fstab.ycp";

    global define target_modify( map modify_targets, boolean installation )
	``{

	y2debug( "BEGINNING of modify_targets" );
  

	/////////////////////////////////////////////////
	// handle all inserted modification requests
	//
	// Example data:
	//
	// 	  $[ 1 : $[
	// 		"use_module" : "lvm_ll"
	// 		"type"       : "create_lv", 
	// 		"name"       : "usr"
	// 		"size"     : 12121
	// 		"vgname"   : "system"
	// 		"stripes"  : 1 ]
	// 
	// 	     2:  $[  "use_module" : "lvm_ll"
	// 		  "type"       : "remove_lv", 
	// 		  "name" : "usr"
	// 		  "vgname" : "system"
	// 		  "target_map_entry" : $[...]
	// 	         ]
	// 	 ...
	//   fdisk_ll change_id is supported only for
	//   compatability and should not be used any more!
	//
	//   use targetMap "change_fsid" : true instead (see README.target_partition)

	integer number_of_modifications = size( modify_targets );
	integer curr_modification       = 0;
	boolean ok                      = true;

    
	while ( ok && (curr_modification < number_of_modifications) )
	{
	    curr_modification = curr_modification +1;
	    string curr_module = "";
	    map curr_map = lookup( modify_targets, curr_modification, $[] );

	    // Choose the module, which can handle this request:

	    curr_module = lookup( curr_map, "use_module", "error" );

	    y2debug( "cur=%1 cnr=%2 module=%3", curr_modification,
		     number_of_modifications, curr_module );
	    y2debug( "map=%1", curr_map );
	    if ( curr_module == "lvm_ll" )
	    {
		if( ! installation &&
		    lookup( curr_map, "type", "" )=="remove_lv" )
		{
		    string umnt = "umount /dev/" + lookup( curr_map, "vgname", "" );
		    umnt = umnt + "/" + lookup( curr_map, "name", "" );
		    y2debug( "umnt=%1", umnt );
		    SCR::Execute (.target.bash, umnt );
		}
		map ret = SCR::Write(.lvm.command, curr_map);


		ok = lookup( ret, "ok", false );

		y2debug( "ret=%1", ret );
		if ( ok == false )
		{
		    string error_text = lookup( ret, "errtxt", "" );
		    string lvm_cmd = lookup( ret, "cmdline", "" );
		    if( size(lvm_cmd)>0 )
		    {
			lvm_cmd = "<b>" + lvm_cmd;
			lvm_cmd = lvm_cmd + "</b><p>";
		    }
		    term content = `RichText( lvm_cmd + error_text );
		    UI::LongTextPopup( _("LVM error"), content, 50, 20 );
		}
		else if( ! installation )
		{
		    string cmd = lookup( curr_map, "type", "" );
		    if( cmd=="remove_lv" || cmd=="create_lv" )
		    {
			list fstab = SCR::Read( .etc.fstab );
			y2debug( "fstab=%1", fstab );
			map target = Storage::GetTargetMap();
			string device = "/dev/" + lookup( curr_map, "vgname", "" );
			string name = lookup( curr_map, "name", "" );
			boolean write_fstab = false;
			y2debug( "device=%1 name=%2", device, name );
			if( cmd=="remove_lv" )
			{
			    device = device + "/" + name;
			    integer old = size(fstab);
			    fstab = filter( `e, fstab, 
					    ``(lookup(e,"spec","")!=device ));
			    y2debug( "size=%1 old=%2", size(fstab), old );
			    write_fstab = old != size(fstab);
			}
			else if( cmd=="create_lv" )
			{
			    list parts = lookup( lookup( target, device, $[] ), 
			                     "partitions", [] );
			    map entry = select( filter( `e, parts, 
			                            ``(lookup(e,"nr","")==name )), 0, $[] );
			    y2debug( "entry=%1", entry );
			    if( lookup( entry, "mount", "" )!="" )
			    {
				fstab = add( fstab, 
					     onepartition2fstab( device, entry ));
				write_fstab = true;
			    }
			}
			y2debug( "write_fstab=%1", write_fstab );
			if( write_fstab )
			{
			    y2debug( "new_fstab=%1", fstab );
			    SCR::Write(.etc.fstab, fstab);
			}
		    }
		}
	    }
	    else if( curr_module == "fdisk_ll" )
	    {
		ok = fdisk_call( curr_map );
	    }
	}

	y2debug("END target_modify");

	return ( ok );
    };

    global define fdisk_call( map curr_map )
	``{
	boolean ok  = false;
	integer pos = 0;
	string disk = lookup( curr_map, "disk", "" );
	string pt   = "";
      
	disk = substring( disk, 5 );
	pos = findfirstof( disk, "/" );
	while( pos > 0 )
	{
	    pt = pt + "." + substring( disk, 0, pos );
	    disk = substring( disk, pos+1 );
	    pos = findfirstof( disk, "/" );
	}

	boolean parted = Partitions::UseParted();

	if( curr_map["type"]:"" == "change_id" )
	    {
	    if( !Partitions::PartitionIdParted( curr_map["id"]:0 ) )
		{
		parted = false;
		}
	    }
	else if( curr_map["type"]:"" == "resize" )
	    {
	    parted = true;
	    }

	pt = pt + "." + disk;
	if( size(pt)>0 )
	{
	    pt = ".disk" + pt + ".command";
	    y2debug( "pt=%1", pt );
	    ok = SCR::Write(topath(pt), curr_map, parted );
	}

	return( ok );
    }
      

    ////////////////////////////////////////////////////////////////////
    // change the id of a partition:
    //  "disk" : "/dev/sdb",
    //  "id"   : 142,          // new id
    //   "nr"  : 8,            // for sdb8
  
    global define boolean fdisk_change_id( string disk, integer nr, integer id  )
	``{
	map curr_change_id = $[
			       "disk" : disk,
			       "id"   :  id,
			       "nr"   :  nr,
			       "type" : "change_id" ];
      
	return( fdisk_call( curr_change_id ));       
    };



    ////////////////////////////////////////////////////////////////////
    // resize a partition:
    //  "disk"          : "/dev/sdb",
    //   "nr"           : 8,            // for sdb8
    //   "new_cyl_num"  : 1500          // resize to 1500 cylinders
  
    global define boolean fdisk_resize( string disk, integer nr, integer new_cyl  )
	``{
	map curr_change = $[
			       "disk"         : disk,
			       "new_cyl_cnt" : new_cyl,
			       "nr"           :  nr,
			       "type"         : "resize" ];
      
	return( fdisk_call( curr_change ));       
    };



 
  global define boolean HandleResizePartitions( string disk_dev, map disk,
						boolean decrease )
    ``{
    boolean ret = true;
    integer cyl_size = disk["cyl_size"]:0;

    list part = filter( `p, disk["partitions"]:[], 
			``(p["resize"]:false && !p["delete"]:false));
    if( decrease )
	{
	part = filter( `p, part, ``(p["region",1]:0 < p["ori_length"]:0));
	}
    else
	{
	part = filter( `p, part, ``(p["region",1]:0 > p["ori_length"]:0));
	}
    if( Mode::initial )
	{
	part = filter( `p, part, 
		       ``(!Partitions::IsDosWinNtPartition( p["fsid"]:0 )));
	}

    foreach( `p, part, ``{
        if( ret )
	    {
	    integer new_size = p["region",1]:0*cyl_size/(1024*1024);
	    integer old_size = p["ori_length"]:0*cyl_size/(1024*1024);
	    ret = HandleResize( disk_dev, p, new_size, old_size );
	    }
	});
    return( ret );
    }

global define boolean HandleResizeLvm( map target, map mod, boolean decrease )
    ``{
    y2milestone( "HandleResizeLvm decrease:%1 mod:%2", decrease, mod );
    boolean ret = true;
    integer num = 1;
    map doit = $[];
    foreach( `n, `e, mod, ``{
	string device = "/dev/" + e["vgname"]:"" + "/" + e["name"]:"abcde";
        map p = Storage::GetPartition( target, device );
	y2debug( "p:%1", p );
        integer new_size = e["size"]:0;
        integer old_size = p["ori_length"]:new_size;
	old_size = old_size / (1024*1024);
	new_size = new_size / (1024*1024);
	if( (decrease && old_size > new_size) ||
	    (!decrease && old_size < new_size) )
	    {
	    e["part"] = eval(p);
	    doit[num] = e;
	    num = num + 1;
	    }
	});
    y2debug( "doit:%1", doit );
    if( size(doit)>0 )
	{
	if( !decrease )
	    {
	    ret = target_modify( doit, Mode::initial );
	    }
	foreach( `n, `e, doit, ``{
	    if( ret )
		{
		y2debug( "n:%1 e:%2", n, e );
		integer new_size = e["size"]:0 / (1024*1024);
		integer old_size = e["part","ori_length"]:0 / (1024*1024);
		ret = HandleResize( "/dev/"+e["vgname"]:"", e["part"]:$[],
		                    new_size, old_size );
		}
	    });
	if( decrease )
	    {
	    ret = target_modify( doit, Mode::initial );
	    }
	}
    return( ret );
    }

global define boolean HandleResize( string disk_dev, map part,
                                    integer new_size, integer old_size )
    ``{
    y2milestone( "HandleResize disk:%1 new:%2 old:%3", disk_dev, new_size,
                 old_size );
    y2milestone( "HandleResize part:%1", part );
    string unit = _("MB");
    boolean retry = false;
    string cmd = "";
    string device = Storage::GetDeviceName( disk_dev, part["nr"]:0 );
    symbol fs = part["used_fs"]:`unknown;
    string fs_name = FileSystems::GetName( fs, _("unknown") );
    boolean lvm = part["type"]:`unknown == `lvm;
    boolean decrease = new_size < old_size;
    boolean format = part["format"]:false;
    map possible = FileSystems::IsResizable( fs );
    list swap = Storage::SwappingPartitions();
    do
	{
	UI::ChangeWidget(`id(`progress), `Label, 
			 sformat(_("Resizing device %1 with filesystem %2 from %3 %4 to %5 %4"), 
				 device, fs_name, old_size, unit, new_size ));
	retry = false;
	boolean result = true;
	boolean need_umount = false;
	string mp = "";
	if( Mode::normal )
	    mp = Partitions::MountedOn( device, Partitions::CurMounted() );
	if( size(mp)>0 )
	    {
	    if( decrease && !possible["mount_shrink"]:false )
		need_umount = true;
	    if( !decrease && !possible["mount_extend"]:false )
		need_umount = true;
	    if( format )
		need_umount = true;
	    }
	if( contains( swap, device ))
	    {
	    cmd = sformat( "swapoff %1", device );
	    y2milestone( "execute cmd:%1", cmd );
	    SCR::Execute(.target.bash, cmd );
	    need_umount = false;
	    }
	if( need_umount )
	    {
	    cmd = sformat("umount %1", mp );
	    y2milestone( "execute cmd:%1", cmd );
	    result = SCR::Execute(.target.bash, cmd ) == 0;
	    if( !result )
		{
		UI::MessagePopup( _("
Resizing of the given filesystem is only possible while the filesystem
is not mounted. Trying to umount the failed for some reason. 
Therefore resizing is not possible.
You could umount the filesystem manually and retry resizing." ));
		}
	    }
	if( result && decrease && !format )
	    {
	    result = HandleFilesystem( device, fs, new_size, decrease, mp );
	    }
	if( result && lvm && !format && decrease && possible["parted"]:false )
	    {
	    cmd = sformat( "/usr/sbin/parted -s %1 resize 1 0 %2", device,
	                   new_size );
	    y2milestone( "execute cmd:%1", cmd );
	    result = SCR::Execute(.target.bash, cmd ) == 0;
	    }
	if( result && !lvm )
	    {
	    result = fdisk_resize( disk_dev, part["nr"]:0, part["region",1]:0 );
	    y2milestone( "fdisk_resize ret:%1", result );
	    }
	if( result && lvm && !format && !decrease && possible["parted"]:false )
	    {
	    cmd = sformat( "/usr/sbin/parted -s %1 resize 1 0 %2", device,
	                   new_size );
	    y2milestone( "execute cmd:%1", cmd );
	    result = SCR::Execute(.target.bash, cmd ) == 0;
	    }
	if( result && !decrease && !format )
	    {
	    result = HandleFilesystem( device, fs, new_size, decrease, mp );
	    }
	if( need_umount && !format )
	    {
	    cmd = sformat("mount %1 %2", device, mp );
	    y2milestone( "execute cmd:%1", cmd );
	    SCR::Execute(.target.bash, cmd );
	    }
	if( contains( swap, device ))
	    {
	    cmd = sformat( "mkswap %1", device );
	    y2milestone( "execute cmd:%1", cmd );
	    SCR::Execute(.target.bash, cmd );
	    cmd = sformat( "swapon %1", device );
	    y2milestone( "execute cmd:%1", cmd );
	    SCR::Execute(.target.bash, cmd );
	    }
	if ( !result )
	  {
	  y2error("Oops, partition resize failed for device %1", device);
	  symbol ans=`yes;
	  // continue/cancel/retry during installation
	  ans = UI::AnyQuestionPopup3(_("resize failed."),
		  sformat (_("Resizing of device %1 failed."), device),
		  UI::ContinueButtonLabel(), UI::AbortButtonLabel(), UI::RetryButtonLabel(), `focus_no);

	  if( ans == `retry )
	    {
	    retry = true;
	    }
	  else if( ans == `no )
	    {
	    ret = false;
	    }
	  }
	else
	  {
	  map tg = Storage::GetTargetMap();
	  tg = Storage::DelPartitionData( tg, part["device"]:"", "ori_length" );
	  tg = Storage::DelPartitionData( tg, part["device"]:"", "resize" );
	  Storage::SetTargetMap( tg );
	  }
	} while ( retry );
    }
				     

 global define boolean HandleFilesystem( string device, symbol fs, 
                                         integer new_size,
                                         boolean decrease,
					 string mp )
    ``{
    boolean ret = true;
    string cmd = "";
    y2milestone( "HandleFilesystem device:%1 fs:%2 new:%3 decrease:%4 mp:%5",
                 device, fs, new_size, decrease, mp );
    if( fs == `reiser )
	{
	if( !decrease && size(mp)>0 )
	    {
	    cmd = sformat("mount -oremount,resize=%1 %2", new_size*256, mp );
	    }
	else
	    {
	    cmd = sformat("echo y | resize_reiserfs -s %1M -f %2", new_size, 
			  device );
	    }
	y2milestone( "execute cmd:%1", cmd );
	ret = SCR::Execute(.target.bash, cmd ) == 0;
	}
    else if( fs == `xfs && !decrease )
	{
	string mdir = Misc::tmpdir + "/m1";
	if( size(mp)==0 )
	    {
	    cmd = sformat("mkdir %1", mdir );
	    SCR::Execute(.target.bash, cmd );
	    cmd = sformat("mount %1 %2", device, mdir );
	    y2milestone( "execute cmd:%1", cmd );
	    ret = SCR::Execute(.target.bash, cmd ) == 0;
	    }
	else
	    {
	    mdir = mp;
	    }
	if( ret )
	    {
	    cmd = sformat("xfs_growfs %1", mdir );
	    y2milestone( "execute cmd:%1", cmd );
	    ret = SCR::Execute(.target.bash, cmd ) == 0;
	    }
	if( size(mp)==0 )
	    {
	    cmd = sformat("umount %1", device );
	    y2milestone( "execute cmd:%1", cmd );
	    SCR::Execute(.target.bash, cmd );
	    cmd = sformat("rmdir %1", mdir );
	    SCR::Execute(.target.bash, cmd );
	    }
	}
    y2milestone( "HandleFilesystem ret:%1", ret );
    return( ret );
    }
  
}
