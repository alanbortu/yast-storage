/**
 * File:	ep-raid-dialogs.ycp
 * Package:	yast2-storage
 * Summary:	Expert Partitioner
 * Authors:	Arvin Schnell <aschnell@suse.de>
 */
{
    textdomain "storage";


    integer MinimalNumberOfDevicesForRaid(string raid_type)
    {
	map<string, integer> info = $[ "raid0" : 2, "raid1" : 2, "raid5" : 3, "raid6" : 4,
				       "raid10" : 2, "multipath" : 2 ];
	return info[raid_type]:0;
    }


    boolean CheckNumberOfDevicesForRaid(string raid_type, integer num)
    {
	integer min_num = MinimalNumberOfDevicesForRaid(raid_type);

	if (num < min_num)
	{
	    map<string, string> info = $[ "raid0" : "RAID0", "raid1" : "RAID1", "raid5" : "RAID5", "raid6" : "RAID6",
					  "raid10" : "RAID10", "multipath" : "Multipath RAID" ];
	    Error(sformat(_("For %1, select at least %2 device.", "For %1, select at least %2 devices.", min_num),
			  info[raid_type]:"error", min_num));
	    return false;
	}
	else
	{
	    return true;
	}
    }


    integer DefaultChunkSizeK(string raid_type)
    {
	map<string, integer> info = $[ "raid0" : 32, "raid5" : 128 ];
	return info[raid_type]:4;
    }


    symbol MiniWorkflowStepRaidTypeDevices(map<string, any> &data)
    {
	y2milestone("MiniWorkflowStepRaidTypeDevices data:%1", data);

	string raid_type = data["raid_type"]:"raid0";
	string device = data["device"]:"error";
	list<string> devices = data["devices"]:[];

	integer callback(list<map> devices)
	{
	    integer sizeK = 0;
	    Storage::ComputeMdSize(symbolof(toterm(raid_type)), maplist(map device, devices, { return device["device"]:""; }), sizeK);
	    return sizeK;
	}

	list<symbol> fields = StorageSettings::FilterTable([ `device, `udev_path, `udev_id, `size ]);

	map<string, map> target_map = Storage::GetTargetMap();
	list<map> unused_devices = filter(map dev, get_possible_rds(target_map), { return dev["used_by"]:"" == "" &&
		    !contains(devices, dev["device"]:""); });
	list<map> used_devices = filter(map dev, get_possible_rds(target_map), { return dev["used_by"]:"" == "" &&
		    contains(devices, dev["device"]:""); });

	term contents = `VBox(`Left(
	    `HVSquash(`Frame(_("RAID Type"),
			     `RadioButtonGroup(`id(`raid_type),
					       `VBox(
						   // Translators, 'Striping' is a technical term here. Translate only if
						   // you are sure!! If in doubt, leave it in English.
						   `LeftRadioButton(`id(`raid0), `opt(`notify), _("RAID &0  (Striping)"),
								    raid_type == "raid0"),
						   // Translators, 'Mirroring' is a technical term here. Translate only if
						   // you are sure!! If in doubt, leave it in English.
						   `LeftRadioButton(`id(`raid1), `opt(`notify), _("RAID &1  (Mirroring)"),
								    raid_type == "raid1"),
						   // Translators, 'Redundant Striping' is a technical term here. Translate
						   // only if you are sure!! If in doubt, leave it in English.
						   `LeftRadioButton(`id(`raid5), `opt(`notify), _("RAID &5  (Redundant Striping)"),
								    raid_type == "raid5")
						   )
				 ))))
	    );

	contents = add(contents, DevicesSelectionBox::Create(unused_devices, used_devices, fields, callback,
							     _("Available Devices:"),
							     _("Selected Devices:")));

	MiniWorkflow::SetContents(Greasemonkey::Transform(contents), "TODO help");
	MiniWorkflow::SetLastStep(false);

	symbol widget = nil;

	repeat
	{
	    widget = MiniWorkflow::UserInput();
	    DevicesSelectionBox::Handle(widget);

	    switch (widget)
	    {
		case `raid0:
		case `raid1:
		case `raid5:
		{
		    raid_type = substring(tostring((symbol) UI::QueryWidget(`id(`raid_type), `Value)), 1);
		    DevicesSelectionBox::UpdateSelectedSize();
		}
		break;

		case `next:
		{
		    devices = maplist(map device, DevicesSelectionBox::GetSelectedDevices(), {
			return device["device"]:"";
		    });

		    if (!CheckNumberOfDevicesForRaid(raid_type, size(devices)))
			widget = `again;
		}
		break;
	    }
	}
	until (widget == `abort || widget == `back || widget == `next);

	if (widget == `next)
	{
	    data["raid_type"] = raid_type;
	    data["devices"] = devices;
	}

	y2milestone("MiniWorkflowStepRaidTypeDevices data:%1 ret:%2", data, widget);

	return widget;
    }


    symbol MiniWorkflowStepRaidOptions(map<string, any> &data)
    {
	y2milestone("MiniWorkflowStepRaidOptions data:%1", data);

	string raid_type = data["raid_type"]:"error";
	integer chunk_size = (data["chunk_size_k"]:DefaultChunkSizeK(raid_type))*1024;
	symbol parity_algorithm = data["parity_algorithm"]:`left_asymmetric;

	list<term> chunk_sizes_list = maplist(integer i, Integer::RangeFrom(11, 22), {
	    return `item(`id(2 << i), Storage::ByteToHumanStringWithPrecision(2 << i, 2, true));
	});

	term options = `VBox(
	    `Left(`ComboBoxSelected(`id(`chunk_size), _("Chunk Size"), chunk_sizes_list,
				    `id(chunk_size)))
	    );

	if (raid_type == "raid5")
	    options = add(options,
			  `Left(`ComboBoxSelected(`id(`parity_algorithm), `opt(`hstretch), _("Parity &Algorithm"),
						  [ `item(`id(`left_asymmetric), "left-asymmetric"),
						    `item(`id(`left_symmetric), "left-symmetric"),
						    `item(`id(`right_asymmetric), "right-asymmetric"),
						    `item(`id(`right_symmetric), "right-symmetric") ],
						  `id(parity_algorithm)))
		);

	term contents = `HVSquash(`Frame(_("RAID Options"), options));

	MiniWorkflow::SetContents(Greasemonkey::Transform(contents), "TODO help");
	MiniWorkflow::SetLastStep(false);

	symbol widget = nil;

	repeat
	{
	    widget = MiniWorkflow::UserInput();
	}
	until (widget == `abort || widget == `back || widget == `next);

	if (widget == `next)
	{
	    chunk_size = (integer) UI::QueryWidget(`id(`chunk_size), `Value);

	    if (UI::WidgetExists(`id(`parity_algorithm)))
		parity_algorithm = (symbol) UI::QueryWidget(`id(`parity_algorithm), `Value);

	    data["chunk_size_k"] = chunk_size / 1024;
	    data["parity_algorithm"] = parity_algorithm;
	}

	y2milestone("MiniWorkflowStepRaidOptions data:%1 ret:%2", data, widget);

	return widget;
    }


    symbol MiniWorkflowStepResizeRaid(map<string, any> &data)
    {
	y2milestone("MiniWorkflowStepResizeRaid data:%1", data);

	string device = data["device"]:"error";
	string raid_type = data["raid_type"]:"error";
	list<string> devices_new = [];

	integer callback(list<map> devices)
	{
	    integer sizeK = 0;
	    Storage::ComputeMdSize(symbolof(toterm(raid_type)), maplist(map device, devices, { return device["device"]:""; }), sizeK);
	    return sizeK;
	}

	list<symbol> fields = StorageSettings::FilterTable([ `device, `udev_path, `udev_id, `size ]);

	map<string, map> target_map = Storage::GetTargetMap();
	list<map> unused_devices = filter(map dev, get_possible_rds(target_map), { return dev["used_by"]:"" == ""; });
	list<map> used_devices = filter(map dev, get_possible_rds(target_map), { return "/dev/" + dev["used_by"]:"" == device; });

	term contents = `VBox();

	contents = add(contents, DevicesSelectionBox::Create(unused_devices, used_devices, fields, callback,
							     _("Available Devices:"),
							     _("Selected Devices:")));

	MiniWorkflow::SetContents(Greasemonkey::Transform(contents), "TODO");
	MiniWorkflow::SetLastStep(true);

	symbol widget = nil;

	repeat
	{
	    widget = MiniWorkflow::UserInput();
	    DevicesSelectionBox::Handle(widget);

	    switch (widget)
	    {
		case `next:
		{
		    devices_new = maplist(map device, DevicesSelectionBox::GetSelectedDevices(), {
			return device["device"]:"";
		    });

		    if (!CheckNumberOfDevicesForRaid(raid_type, size(devices_new)))
			widget = `again;
		}
		break;
	    }
	}
	until (widget == `abort || widget == `back || widget == `next);

	if (widget == `next)
	{
	    data["devices_new"] = devices_new;

	    widget = `finish;
	}

	y2milestone("MiniWorkflowStepResizeRaid data:%1 ret:%2", data, widget);

	return widget;
    }


    boolean DlgCreateRaidNew(map<string, any> &data)
    {
	map<string, any> aliases = $[
	    "TypeDevices" : ``(MiniWorkflowStepRaidTypeDevices(data)),
	    "Options"     : ``(MiniWorkflowStepRaidOptions(data)),
	    "FormatMount" : ``(MiniWorkflowStepFormatMount(data)),
	    "Password"	  : ``(MiniWorkflowStepPassword(data))
	];

	map<string, any> sequence = $[
	    "TypeDevices" : $[ `next : "Options" ],
	    "Options"     : $[ `next : "FormatMount" ],
	    "FormatMount" : $[ `next : "Password",
			       `finish : `finish ],
	    "Password"    : $[ `finish : `finish ]
	];

	string title = sformat(_("Add RAID %1"), data["device"]:"error");

	symbol widget = MiniWorkflow::Run(title, raid_icon, aliases, sequence, "TypeDevices");

	return widget == `finish;
    }


    boolean DlgResizeRaid(map<string, any> &data)
    {
	map<string, any> aliases = $[
	    "TheOne" : ``(MiniWorkflowStepResizeRaid(data))
	];

	map<string, any> sequence = $[
	    "TheOne" : $[ `finish : `finish ]
	];

	string title = sformat(_("Resize RAID %1"), data["device"]:"error");

	symbol widget = MiniWorkflow::Run(title, raid_icon, aliases, sequence, "TheOne");

	return widget == `finish;
    }


    boolean DlgEditRaid(map<string, any> &data)
    {
	string device = data["device"]:"error";

	map<string, any> aliases = $[
	    "FormatMount" : ``(MiniWorkflowStepFormatMount(data)),
	    "Password"	  : ``(MiniWorkflowStepPassword(data))
	];

	map<string, any> sequence = $[
	    "FormatMount" : $[ `next : "Password",
			       `finish : `finish ],
	    "Password"    : $[ `finish : `finish ]
	];

	string title = sformat(_("Edit RAID %1"), device);

	symbol widget = MiniWorkflow::Run(title, raid_icon, aliases, sequence, "FormatMount");

	return widget == `finish;
    }
}
