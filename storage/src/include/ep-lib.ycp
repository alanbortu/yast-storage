/**
 * File:	ep-lib.ycp
 * Package:	yast2-storage
 * Summary:	Expert Partitioner
 * Authors:	Arvin Schnell <aschnell@suse.de>
 *
 * This file must only be included in other Expert Partitioner files ("ep-*.ycp").
 */
{
    textdomain "storage";


    boolean EpDeleteVolumeGroup(string device);
    boolean ConfirmRecursiveDelete(string device, list <string> partitions, string headline, string text_before, string text_after );


    list<string> AddedToList(list<string> old, list<string> new)
    {
	return multiset::difference(sort(new), sort(old));
    }


    list<string> RemovedFromList(list<string> old, list<string> new)
    {
	return multiset::difference(sort(old), sort(new));
    }


    // Calculates the devices from the devices, devices_add and devices_rem entries
    // in data.
    list<string> MergeDevices(map<string, any> data)
    {
	list<string> devices = sort((list<string>) data["devices"]:[]);
	list<string> devices_add = sort((list<string>) data["devices_add"]:[]);
	list<string> devices_rem = sort((list<string>) data["devices_rem"]:[]);

	devices = multiset::union(devices, devices_add);
	devices = multiset::difference(devices, devices_rem);

	return devices;
    }


    /**
     * Must be called before removing device.
     */
    string ParentDevice(string device)
    {
	map<string, map> target_map = Storage::GetTargetMap();

	map disk = target_map[device]:nil;
	map part = nil;

	if (disk == nil)
	{
	    foreach(string s, map d, target_map, {
		part = find(map p, d["partitions"]:[], { return p["device"]:"" == device; });
		if (part != nil) {
		    disk = d;
		    break;
		}
	    });
	}

	return disk["device"]:"";
    }

    boolean ConfirmDeletingUsedDevice( map tg, map <string, any> part, symbol used_by )
    {
	string device = part["device"]:"";
	string used_by_device = part["used_by_device"]:"";

	switch (used_by)
	{
	    case `UB_LVM:
	    {
		list <map> parts =  tg[used_by_device, "partitions"]:[];
        	list<string> volumes = prepend(
			maplist(map part, parts, { return part["device"]:""; }),
			used_by_device);

		return ( ConfirmRecursiveDelete( device, volumes,
		    _("Confirm Deleting Partition Used by LVM"),
		    sformat(_("The selected partition is used by volume group \"%1\"
To keep system in consistent state, the following volume group
and its logical volumes will be deleted:"), used_by_device),
		    sformat( _("Delete partition \"%1\" and volume group \"%2\" now?"), device, used_by_device)
		    ));
		break;
	    }
	    case `UB_MD:
	    {
		return ( ConfirmRecursiveDelete( device, [used_by_device],
		    _("Confirm Deleting Partition Used by RAID"),
		    sformat(_("The selected partition belongs to RAID  \"%1\"
To keep system in consistent state, the following
RAID device will be deleted:"), used_by_device),
		    sformat( _("Delete partition \"%1\" and RAID \"%2\" now?"), device, used_by_device)
		    ));

	    }
	    default:
		break;
	}

	return false;
    }

    /**
     * Must be called before removing device.
     */
    string NextDeviceAfterDelete(string device)
    {
	map<string, map> target_map = Storage::GetTargetMap();

	string parent = ParentDevice(device);

	list<string> partitions = maplist(map part, target_map[parent, "partitions"]:[], {
	    return part["device"]:"";
	});

	integer index = -1;
	foreach(integer i, Integer::Range(size(partitions)), {
	    if (partitions[i]:"" == device)
		index = i;
	});

	string ret = "";
	if (index > 0)
	    ret = partitions[index - 1]:"";
	else if (size(partitions) > 1)
	    ret = partitions[1]:"";

	y2milestone("NextDeviceAfterDelete device:%1 ret:%2", device, ret);
	return ret;
    }


    boolean EpDeleteDevice(string id)
    {
	map<string,map> tg =  Storage::GetTargetMap();

	map<string,any> part = $[];
	map<string,any> disk = Storage::GetDisk( tg, id );

	if( !haskey( tg, id ) )
	    part = Storage::GetPartition( tg, id );
	y2milestone( "id:%1 part:%2", id, part );
	if( !haskey( tg, id ) && size(part)==0 )
	{
	    return false;
	}

	if( disk["readonly"]:false )
	{
	    Popup::Error( Partitions::RdonlyText( disk["device"]:"", true ));
	    return false;
	}

	if( haskey( tg, id ) )
	{
	    if( tg[id,"type"]:`CT_UNKNOWN == `CT_MD )
	    {
		return false;
	    }
	    else if( tg[id,"type"]:`CT_UNKNOWN == `CT_DMRAID )
	    {
		if( Popup::YesNo( sformat(_("Really delete BIOS RAID %1?"), id )))
		{
		    if( deleteAllDevPartitions( disk, Stage::initial(), false ))
			Storage::DeleteDmraid( id );
		    return true;
		}
	    }
	    // YesNo popup text %1 is replaced by a disk name e.g. /dev/hda
	    else if( Popup::YesNo( sformat(_("Really delete all partitions on %1?"), id )))
	    {
		deleteAllDevPartitions( disk, Stage::initial(), false );
		return true;
	    }
	}
	else if( part["type"]:`unknown==`lvm )
	{
	    if( !check_device_delete( part, false, Stage::initial(), $[] ))
	    {
		return false;
	    }
	    else
	    {
		return HandleRemoveLv( tg, id );
	    }
	}
	else
	{
	    /////////////////////////////////////////////////////
	    // delete algorithm:
	    // if you find newly created (but until now not realy
	    // written) partition (sign: "create = true"): delete it
	    // else there must be already existing partition: mark it
	    // with "delete = true"

	    y2milestone( "delete part %1", part );
	    /////////////////////////////////////////////////////
	    // check if the partition can be deleted

	    if( part["type"]:`primary == `extended &&
		!check_extended_delete( disk, Stage::initial() ))
	    {
		return false;
	    }

	    if( part["type"]:`primary != `extended )
	    {
		symbol used_by = check_devices_used( [ part ], false);

		if ( used_by != `UB_NONE)
		{
		    if (ConfirmDeletingUsedDevice( tg, part, used_by ))
		    {
			boolean recursive = Storage::GetRecursiveRemoval();
			Storage::SetRecursiveRemoval( true );
			Storage::DeleteDevice( disk["device"]:"",
			   part["device"]:"" );
			Storage::SetRecursiveRemoval( recursive );
			return true;
		    }
		    else
			return false;
		}

		if (!check_device_delete( part, false, Stage::initial(),
				      disk ))
		    return false;
	    }

	    /////////////////////////////////////////////////////
	    // now delete partition!!

	    // YesNo popup text, %1 is replaced by a device name e.g. /dev/hda1
	    if( Popup::YesNo( sformat(_("Really delete %1?"),
				      part["device"]:"" )))
	    {
		if( (search( id, "/dev/loop")==0 ||
		     search( id, "/dev/mapper/")==0) &&
		    size(part["fpath"]:"")>0 &&
		    Mode::normal() &&
		    // YesNo popup.  %1 is path to a file
		    Popup::YesNo( sformat(_("\nShould the loop file %1 also be removed?
"), part["fpath"]:"" )))
		{
		    Storage::DeleteLoop( disk["device"]:"",
					 part["fpath"]:"", true );
		}
		else
		{
		    Storage::DeleteDevice( disk["device"]:"",
					   part["device"]:"" );
		}
		return true;
	    }
	}

	return false;
    }


    void ImportMountPoints()
    {
	map<string,map> od = (map<string,map>)Storage::GetOndiskTarget();
	list<list> fstab = scanAndReadExistingFstab( od );
	y2milestone( "adapt_mp fstab %1", fstab );
	list ti = maplist( list e, fstab, ``(AddFstabToData( od, (list<map>)e)[1]:$[]));
	y2milestone( "adapt_mp ti %1", ti );

	integer idx = FstabAddDialog( ti );
	if( idx>=0 )
	{
	    od = (map<string,map>)Storage::GetOndiskTarget();
	    y2milestone( "adapt_mp use fstab idx %1", idx );
	    ti = AddFstabToData( od, (list<map>)fstab[idx]:[] );
	    Storage::ResetOndiskTarget();
	    foreach( string d, map disk, ti[0]:$[],
		     ``{
			 foreach( map p, disk["partitions"]:[],
				  ``{
				      if( size(p["mount"]:"")>0 && p["enc_type"]:`none!=`none &&
					  !p["tmpcrypt"]:false )
				      {
					  string pwd = DlgCreateCryptFs( p["device"]:"", 1, false, false );
					  if( pwd != nil && size(pwd)>0 )
					      Storage::SetCryptPwd( p["device"]:"", pwd );
				      }
				  });
		     });
	    Storage::SetTargetMap(ti[0]:$[]);
	}
    }
}
