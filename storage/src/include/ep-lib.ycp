/**
 * File:	ep-lib.ycp
 * Package:	yast2-storage
 * Summary:	Expert Partitioner
 * Authors:	Arvin Schnell <aschnell@suse.de>
 */
{
    textdomain "storage";

    boolean EpDeleteVolumeGroup(string device);

    list<string> AddedToList(list<string> old, list<string> new)
    {
	return multiset::difference(sort(new), sort(old));
    }


    list<string> RemovedFromList(list<string> old, list<string> new)
    {
	return multiset::difference(sort(old), sort(new));
    }


    /**
     * Must be called before removing device.
     */
    string ParentDevice(string device)
    {
	map<string, map> target_map = Storage::GetTargetMap();

	map disk = target_map[device]:nil;
	map part = nil;

	if (disk == nil)
	{
	    foreach(string s, map d, target_map, {
		part = find(map p, d["partitions"]:[], { return p["device"]:"" == device; });
		if (part != nil) {
		    disk = d;
		    break;
		}
	    });
	}

	return disk["device"]:"";
    }

    boolean ConfirmDeletingUsedDevice( map <string, any> part, symbol used_by )
    {
	switch (used_by)
	{
	    case `UB_LVM:
		if (Popup::AnyQuestion( _("Confirm Deleting Partition Used by LVM"),
		    sformat(_("The selected partition \"%1\" belongs to volume group \"%2\". 
To keep system in consistent state, it is recommended to delete the volume group and 
all its logical volumes before deleting the partition. 
 
Delete partition \"%1\" AND volume group \"%2\" now?"), part["device"]:"", part["used_by_device"]:""),
		    Label::DeleteButton(),
		    Label::CancelButton(),
		    `focus_no
		    ))
		{
		   return  EpDeleteVolumeGroup(part["used_by_device"]:"");
		}
		break;
	    //FIXME: add RAID case here
	    default:
		break;
	}

	return false;
    }

    /**
     * Must be called before removing device.
     */
    string NextDeviceAfterDelete(string device)
    {
	map<string, map> target_map = Storage::GetTargetMap();

	string parent = ParentDevice(device);

	list<string> partitions = maplist(map part, target_map[parent, "partitions"]:[], {
	    return part["device"]:"";
	});

	integer index = -1;
	foreach(integer i, Integer::Range(size(partitions)), {
	    if (partitions[i]:"" == device)
		index = i;
	});

	string ret = "";
	if (index > 0)
	    ret = partitions[index - 1]:"";
	else if (size(partitions) > 1)
	    ret = partitions[1]:"";

	y2milestone("NextDeviceAfterDelete device:%1 ret:%2", device, ret);
	return ret;
    }


    boolean EpDeleteDevice(string id)
    {
	map<string,map> tg =  Storage::GetTargetMap();

	map<string,any> part = $[];
	map<string,any> disk = Storage::GetDisk( tg, id );

	if( !haskey( tg, id ) )
	    part = Storage::GetPartition( tg, id );
	y2milestone( "id:%1 part:%2", id, part );
	if( !haskey( tg, id ) && size(part)==0 )
	{
	    return false;
	}

	if( disk["readonly"]:false )
	{
	    Popup::Error( Partitions::RdonlyText( disk["device"]:"", true ));
	    return false;
	}

	if( haskey( tg, id ) )
	{
	    if( tg[id,"type"]:`CT_UNKNOWN == `CT_MD )
	    {
		return false;
	    }
	    else if( tg[id,"type"]:`CT_UNKNOWN == `CT_DMRAID )
	    {
		if( Popup::YesNo( sformat(_("Really delete BIOS RAID %1?"), id )))
		{
		    if( deleteAllDevPartitions( disk, Stage::initial(), false ))
			Storage::DeleteDmraid( id );
		    return true;
		}
	    }
	    // YesNo popup text %1 is replaced by a disk name e.g. /dev/hda
	    else if( Popup::YesNo( sformat(_("Really delete all partitions on %1?"), id )))
	    {
		deleteAllDevPartitions( disk, Stage::initial(), false );
		return true;
	    }
	}
	else if( part["type"]:`unknown==`lvm )
	{
	    if( !check_device_delete( part, false, Stage::initial(), $[] ))
	    {
		return false;
	    }
	    else
	    {
		HandleRemoveLv( tg, id );
		return true;
	    }
	}
	else
	{
	    /////////////////////////////////////////////////////
	    // delete algorithm:
	    // if you find newly created (but until now not realy
	    // written) partition (sign: "create = true"): delete it
	    // else there must be already existing partition: mark it
	    // with "delete = true"

	    y2milestone( "delete part %1", part );
	    boolean ask = true;
	    /////////////////////////////////////////////////////
	    // check if the partition can be deleted

	    if( part["type"]:`primary == `extended &&
		!check_extended_delete( disk, Stage::initial() ))
	    {
		return false;
	    }

	    if( part["type"]:`primary != `extended )
	    {
		symbol used_by = check_devices_used( [ part ], false);

		if ( used_by != `UB_NONE)
		{
		    if (!ConfirmDeletingUsedDevice( part, used_by ))
			return false;
		    // whatever was using the defice is deleted by now
		    else
		    {
			// but we must re-read target map to reflect current status
			// i.e. device is no longer used by now
			tg = Storage::GetTargetMap();
		        part = Storage::GetPartition(tg, id);
			// do not ask anymore - user has already confirmed deleting
		        ask = false;
		    }
		}

		if (!check_device_delete( part, false, Stage::initial(),
				      disk ))
		    return false;
	    }

	    /////////////////////////////////////////////////////
	    // now delete partition!!

	    // YesNo popup text, %1 is replaced by a device name e.g. /dev/hda1
	    if( !ask || Popup::YesNo( sformat(_("Really delete %1?"),
				      part["device"]:"" )))
	    {
		if( (search( id, "/dev/loop")==0 ||
		     search( id, "/dev/mapper/")==0) &&
		    size(part["fpath"]:"")>0 &&
		    Mode::normal() &&
		    // YesNo popup.  %1 is path to a file
		    Popup::YesNo( sformat(_("\nShould the loop file %1 also be removed?
"), part["fpath"]:"" )))
		{
		    Storage::DeleteLoop( disk["device"]:"",
					 part["fpath"]:"", true );
		}
		else
		{
		    Storage::DeleteDevice( disk["device"]:"",
					   part["device"]:"" );
		}
		return true;
	    }
	}

	return false;
    }


    void ImportMountPoints()
    {
	map<string,map> od = (map<string,map>)Storage::GetOndiskTarget();
	list<list> fstab = scanAndReadExistingFstab( od );
	y2milestone( "adapt_mp fstab %1", fstab );
	list ti = maplist( list e, fstab, ``(AddFstabToData( od, (list<map>)e)[1]:$[]));
	y2milestone( "adapt_mp ti %1", ti );

	integer idx = FstabAddDialog( ti );
	if( idx>=0 )
	{
	    od = (map<string,map>)Storage::GetOndiskTarget();
	    y2milestone( "adapt_mp use fstab idx %1", idx );
	    ti = AddFstabToData( od, (list<map>)fstab[idx]:[] );
	    Storage::ResetOndiskTarget();
	    foreach( string d, map disk, ti[0]:$[],
		     ``{
			 foreach( map p, disk["partitions"]:[],
				  ``{
				      if( size(p["mount"]:"")>0 && p["enc_type"]:`none!=`none &&
					  !p["tmpcrypt"]:false )
				      {
					  string pwd = DlgCreateCryptFs( p["device"]:"", 1, false, false );
					  if( pwd != nil && size(pwd)>0 )
					      Storage::SetCryptPwd( p["device"]:"", pwd );
				      }
				  });
		     });
	    Storage::SetTargetMap(ti[0]:$[]);
	}
    }
}
