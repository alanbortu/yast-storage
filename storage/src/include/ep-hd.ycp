/**
 * File:        ep-hd.ycp
 * Package:     yast2-storage
 * Summary:     Expert Partitioner
 * Authors:     Arvin Schnell <aschnell@suse.de>
 *
 * This file must only be included in other Expert Partitioner files ("ep-*.ycp").
 */
{
    textdomain "storage";

    include "partitioning/ep-hd-dialogs.ycp";
    include "partitioning/ep-hd-lib.ycp";


    void EpContextMenuHdDisk(string device)
    {
	symbol widget = ContextMenu::Simple([ `item(`id(`add), `icon(StorageIcons::hd_part_icon), _("Add Partition")),
					      `item(`id(`delete), _("Delete")) ]);

	switch (widget)
	{
	    case `add:
		EpCreatePartition(device);
		break;

	    case `delete:
		EpDeleteDisk(device);
		break;
	}
    }


    void EpContextMenuHdPartition(string device)
    {
	symbol widget = ContextMenu::Simple([ `item(`id(`edit), _("Edit")),
					      `item(`id(`move), _("Move")),
					      `item(`id(`resize), _("Resize")),
					      `item(`id(`delete), _("Delete")) ]);

	switch (widget)
	{
	    case `edit:
		EpEditPartition(device);
		break;

	    case `move:
		EpMovePartition(device);
		break;

	    case `resize:
		EpResizePartition(device);
		break;

	    case `delete:
		EpDeletePartition(device, `table);
		break;
	}
    }


    list<term> HdButtons()
    {
	return [
	    // push button text
	    `PushButton(`id(`edit),`opt(`key_F4), _("Edit...")),
	    // push button text
	    `PushButton(`id(`move), `opt(`key_F7), _("Move...")),
	    // push button text
	    `PushButton(`id(`resize), `opt(`key_F6), _("Resize...")),
	    // push button text
	    `PushButton(`id(`delete), `opt(`key_F5), _("Delete..."))
	];
    }


    void HandleHdButtons( any user_data, string device, map event )
    {
	string disk_device = "";
	boolean is_disk = false;

	if (user_data == nil)
	{
	    map disk = nil;
	    map part = nil;

	    map<string, map> target_map = Storage::GetTargetMap();
	    SplitDevice(target_map, device, disk, part);
	    disk_device = (string) disk["device"]:"";
	    is_disk = part == nil;
	}
	else
	{
	    disk_device = (string) user_data;
	}

	switch (Event::IsWidgetActivated(event))
	{
	    case `add:
		EpCreatePartition(disk_device);
		break;

	    case `edit:
		if (is_disk)
		    TreePanel::SwitchToNew( disk_device );
		else
		    EpEditPartition( device );
		break;

	    case `move:
		if (is_disk)
		    // error popup
		    Popup::Error(_("Hard disks, BIOS RAIDs and multipath
devices cannot be moved."));
		else
		    EpMovePartition(device);
		break;

	    case `resize:
		if (is_disk)
		    // error popup
		    Popup::Error(_("Hard disks, BIOS RAIDs and multipath
devices cannot be resized."));
		else
		    EpResizePartition ( device );
		break;

	    case `delete:
		if (is_disk)
		    EpDeleteDisk(disk_device);
		else
		    EpDeletePartition ( device, UI::WidgetExists(`id(`table)) ? `table : `overview );
		break;
	}
    }


    void CreateHdMainPanel(any user_data)
    {
	symbol Predicate(map disk, map partition)
	{
	    return StorageFields::PredicateDiskType(disk, partition, [`CT_DMRAID, `CT_DMMULTIPATH,
								      `CT_MDPART, `CT_DISK]);
	}

	list<symbol> fields = StorageSettings::FilterTable([ `device, `udev_path, `udev_id, `size, `format,
							     `encrypted, `type, `fs_type, `label, `mount_point,
							     `mount_by, `start_cyl, `end_cyl, `used_by ]);

	map<string, map> target_map = Storage::GetTargetMap();

	term table_header = StorageFields::TableHeader(fields);
	list<term> table_contents = StorageFields::TableContents(fields, target_map, Predicate);

	UI::ReplaceWidget(`tree_panel,
			  Greasemonkey::Transform(
			      `VBox(
				  // heading
				  `IconAndHeading(_("Hard Disks"), StorageIcons::hd_icon),
				  `Table(`id(`table), `opt(`keepSorting, `notify, `notifyContextMenu),
					 table_header, table_contents),
				  ArrangeButtons(flatten([
					[ // push button text
					  `PushButton(`id(`add),`opt(`key_F3), _("Add Partition...")) ],
					HdButtons(),
					[ `HStretch() ]
				  ]))
			      )
			)
	    );

	// helptext
	string helptext = _("<p>This view shows all hard disks including
iSCSI disks, BIOS RAIDs and Multipath disks and their partitions.</p>");

	Wizard::RestoreHelp(helptext + StorageFields::TableHelptext(fields));
    }


    void HandleHdMainPanel(any user_data, map event)
    {
	string device = (string) UI::QueryWidget(`id(`table), `CurrentItem);

	HandleHdButtons( user_data, device, event );

	switch (Event::IsWidgetContextMenuActivated(event))
	{
	    case `table:
		EpContextMenuDevice(device);
		break;
	}
    }


    void CreateHdDiskOverviewTab(any user_data)
    {
	string device = (string) user_data;

	map<string, map> target_map = Storage::GetTargetMap();

	symbol ctype = target_map[device, "type"]:`CT_DISK;

	list<symbol> fields = [ `heading_device, `device, `size, `udev_path, `udev_id, `used_by,
				`heading_hd, `vendor, `model, `num_cyl, `cyl_size, `bus, `bios_id,
				`sector_size, `disk_label ];

	if (contains([ `CT_MDPART ], ctype))
	{
	    fields = (list<symbol>) merge(fields, [ `heading_md, `raid_type, `chunk_size, `parity_algorithm ]);
	}

	if (contains([ `CT_DISK ], ctype) && 
	   (target_map[device, "transport"]:`unknown == `fc ||
	    target_map[device, "transport"]:`unknown == `fcoe ))
	{
	    fields = (list<symbol>) merge(fields, [`heading_fc, `fc_wwpn, `fc_port_id, `fc_fcp_lun ]);
	}

	fields = StorageSettings::FilterOverview(fields);

	term buttons = `HBox();

	if ((integer) SCR::Read(.target.size, "/usr/sbin/smartctl") > 0)
	    // push button text (do not translate 'SMART', it is the name of the tool)
	    buttons = add(buttons, `PushButton(`id(`smart), _("Health Test (SMART)...")));

	if ((integer) SCR::Read(.target.size, "/sbin/hdparm") > 0)
	    // push button text (do not translate 'hdparm', it is the name of the tool)
	    buttons = add(buttons, `PushButton(`id(`hdparm), _("Properties (hdparm)...")));

	UI::ReplaceWidget(`tab_panel,
			  `VBox(
			      `HStretch(),
			      StorageFields::Overview(fields, target_map, device),
			      add(buttons, `HStretch())
			      )
	    );

	// helptext
	string helptext = _("<p>This view shows detailed information about the
selected hard disk.</p>");

	Wizard::RestoreHelp(helptext + StorageFields::OverviewHelptext(fields));
    }


    boolean DiskMaySupportSmart(string disk_device)
    {
	if (String::StartsWith(disk_device, "/dev/dasd"))
	    return false;

	map<string, map> target_map = Storage::GetTargetMap();
	map disk = target_map[disk_device]:$[];

	if (disk["type"]:`CT_UNKNOWN != `CT_DISK)
	    return false;

	if (contains([ "3w-9xxx" ], disk["driver"]:""))
	    return false;

	return true;
    }


    boolean DiskMaySupportHdparm(string disk_device)
    {
	if (String::StartsWith(disk_device, "/dev/dasd"))
	    return false;

	map<string, map> target_map = Storage::GetTargetMap();
	map disk = target_map[disk_device]:$[];

	if (disk["type"]:`CT_UNKNOWN != `CT_DISK)
	    return false;

	return true;
    }


    void HandleHdDiskOverviewTab(any user_data, map event)
    {
	string disk_device = (string) user_data;

	switch (Event::IsWidgetActivated(event))
	{
	    case `smart:
	    {
		if (!DiskMaySupportSmart(disk_device))
		    Popup::Error(_("SMART is not available for this disk."));
		else
		    DisplayCommandOutput(sformat("/usr/sbin/smartctl --health '%1'", disk_device));
		break;
	    }

	    case `hdparm:
	    {
		if (!DiskMaySupportHdparm(disk_device))
		    Popup::Error(_("hdparm is not available for this disk."));
		else
		    DisplayCommandOutput(sformat("/sbin/hdparm -aAgr '%1'", disk_device));
		break;
	    }
	}
    }


    void CreateHdDiskPartitionsTab(any user_data)
    {
	string device = (string) user_data;

	symbol Predicate(map disk, map partition)
	{
	    return StorageFields::PredicateDiskDevice(disk, partition, [ device ]);
	}

	list<symbol> fields = StorageSettings::FilterTable([ `device, `udev_path, `udev_id, `size, `format,
							     `encrypted, `type, `fs_type, `label, `mount_point,
							     `mount_by, `start_cyl, `end_cyl, `used_by ]);

	map<string, map> target_map = Storage::GetTargetMap();

	term table_header = StorageFields::TableHeader(fields);
	list<term> table_contents = StorageFields::TableContents(fields, target_map, Predicate);

	list<term> expert_cmds = [];

	if (!String::StartsWith(device, "/dev/dasd"))
	{
	    expert_cmds = add(expert_cmds,
			      `item(`id(`create_partition_table),
				    // menu entry text
				    _("Create New Partition Table")));
	}

	expert_cmds = add(expert_cmds,
			  `item(`id(`clone_disk),
				// menu entry text
				_("Clone This Disk")));

	if (String::StartsWith(device, "/dev/dasd"))
	{
	    expert_cmds = add(expert_cmds,
			      `item(`id(`dasdfmt),
				    // menu entry text
				    _("Execute dasd&fmt on the DASD Device"))
		);
	}

	UI::ReplaceWidget(`tab_panel,
			  `VBox(
			      DiskBarGraph(device),
			      `Table(`id(`table), `opt(`keepSorting, `notify, `notifyContextMenu),
				     table_header, table_contents),
			      `HBox(
				  ArrangeButtons(flatten([
				      [ // push button text
				        `PushButton(`id(`add),`opt(`key_F3), _("Add...")) ],
				      HdButtons(),
				      [ `HStretch(),
					// menu button text
					`MenuButton(`opt(`key_F7), _("Expert..."), expert_cmds)]
				  ])))
			      ));

	// helptext
	string helptext = _("<p>This view shows all partitions of the selected
hard disk. If the hard disk is used by e.g. BIOS RAID or multipath no
partitions are shown here.</p>");

	Wizard::RestoreHelp(helptext + StorageFields::TableHelptext(fields));
    }


    void HandleHdDiskPartitionsTab(any user_data, map event)
    {
	string disk_device = (string) user_data;
	string part_device = (string) UI::QueryWidget(`id(`table), `CurrentItem);

	HandleHdButtons( disk_device, part_device, event );

	switch (Event::IsMenu(event))
	{
	    case `create_partition_table:
		EpCreatePartitionTable(disk_device);
		break;

	    case `clone_disk:
		EpCloneDisk(disk_device);
		break;

	    case `dasdfmt:
		EpDasdfmtDisk(disk_device);
		break;
	}

	switch (Event::IsWidgetContextMenuActivated(event))
	{
	    case `table:
		EpContextMenuDevice(part_device);
		break;
	}

	UI::SetFocus(`id(`table));
    }


    void CreateHdDiskDevicesTab(any user_data)
    {
	string part_device = (string) user_data;

	symbol Predicate(map disk, map partition)
	{
	    return StorageFields::PredicateUsedByDevice(disk, partition, [ part_device ]);
	}

	list<symbol> fields = StorageSettings::FilterTable([ `device, `udev_path, `udev_id, `size,
							     `format, `encrypted, `type, `used_by ]);

	map<string, map> target_map = Storage::GetTargetMap();

	term table_header = StorageFields::TableHeader(fields);
	list<term> table_contents = StorageFields::TableContents(fields, target_map, Predicate);

	UI::ReplaceWidget(`tab_panel,
			  `VBox(
			      `Table(`id(`table), `opt(`keepSorting, `notify),
				     table_header, table_contents)
			      )
	    );

	// helptext
	string helptext = _("<p>This view shows all devices used by the
selected hard disk. The view is only available for BIOS RAIDs, partitioned
software RAIDs and Multipath Disks.</p>");

	Wizard::RestoreHelp(helptext + StorageFields::TableHelptext(fields));
    }


    void CreateHdDiskPanel(any user_data)
    {
	string device = (string) user_data;

	map<string, map> target_map = Storage::GetTargetMap();

	map<symbol, map> data = $[ `overview : $[ `create : CreateHdDiskOverviewTab,
						  `handle : HandleHdDiskOverviewTab,
						  `user_data : user_data ],
				   `partitions : $[ `create : CreateHdDiskPartitionsTab,
						    `handle : HandleHdDiskPartitionsTab,
						    `user_data : user_data ],
				   `devices : $[ `create : CreateHdDiskDevicesTab,
						 `user_data : user_data ] ];

	symbol ctype = target_map[device, "type"]:`CT_DISK;

	list<term> tabs = [
	    // tab heading
	    `item(`id(`overview), _("&Overview")),
	    // tab heading
	    `item(`id(`partitions), _("&Partitions"))
	];

	if (contains([ `CT_DMRAID, `CT_DMMULTIPATH, `CT_MDPART ], ctype))
	{
	    // tab heading
	    tabs = add(tabs, `item(`id(`devices), _("&Used Devices")));
	}

	UI::ReplaceWidget(`tree_panel,
			  Greasemonkey::Transform(
			      `VBox(
				  // heading
				  `IconAndHeading(sformat(_("Hard Disk: %1"), device), StorageIcons::hd_icon),
				  `DumbTab(`id(`tab), tabs,
					   `ReplacePoint(`id(`tab_panel), TabPanel::empty_panel)
				      )
				  )
			      ));

	TabPanel::Init(data, `partitions);
    }


    void HandleHdDiskPanel(any user_data, map event)
    {
	TabPanel::Handle(event);
    }


    void CreateHdPartitionPanel(any user_data)
    {
	string device = (string) user_data;

	map<string, map> target_map = Storage::GetTargetMap();

	list<symbol> fields = StorageSettings::FilterOverview([ `heading_device, `device, `size, `encrypted,
								`udev_path, `udev_id, `used_by, `fs_id,
								`heading_filesystem, `fs_type, `mount_point,
								`mount_by, `uuid, `label ]);

	UI::ReplaceWidget(`tree_panel,
			  Greasemonkey::Transform(
			      `VBox(
				  `HStretch(),
				  // heading
				  `IconAndHeading(sformat(_("Partition: %1"), device), StorageIcons::hd_part_icon),
				  StorageFields::Overview(fields, target_map, device),
				  ArrangeButtons(flatten([
				      HdButtons(),
				      [ `HStretch() ]
				  ]))
			      )
			      )
	    );

	// helptext
	string helptext = _("<p>This view shows detailed information about the
selected partition.</p>");

	Wizard::RestoreHelp(helptext + StorageFields::OverviewHelptext(fields));
    }


    void HandleHdPartitionPanel(any user_data, map event)
    {
	string part_device = (string) user_data;

	HandleHdButtons( nil, part_device, event);
	UI::SetFocus(`id(`text));
    }
}
