/**
 * File:        ep-hd.ycp
 * Package:     yast2-storage
 * Summary:     Expert Partitioner
 * Authors:     Arvin Schnell <aschnell@suse.de>
 */
{
    textdomain "storage";

    import "Arch";
    import "PackageCallbacks";
    import "PackageSystem";
    import "Region";
    import "Mode";
    import "Stage";

    include "partitioning/ep-hd-dialogs.ycp";
    include "partitioning/ep-hd-lib.ycp";


    void EpContextMenuHdDisk(string device)
    {
	symbol widget = ContextMenu::Simple([ `item(`id(`add), `icon(StorageIcons::hd_part_icon), _("Add Partition")),
					      `item(`id(`delete), _("Delete")) ]);

	switch (widget)
	{
	    case `add:
		EpCreatePartition(device);
		break;

	    case `delete:
		EpDeleteDisk(device);
		break;
	}
    }


    void EpContextMenuHdPartition(string device)
    {
	symbol widget = ContextMenu::Simple([ `item(`id(`edit), _("Edit")),
					      `item(`id(`resize), _("Resize")),
					      `item(`id(`delete), _("Delete")) ]);

	switch (widget)
	{
	    case `edit:
		EpEditPartition(device);
		break;

	    case `resize:
		EpResizePartition(device);
		break;

	    case `delete:
		EpDeletePartition(device, `overview);
		break;
	}
    }


    void CreateHdMainPanel(any user_data)
    {
	symbol Predicate(map disk, map partition)
	{
	    return StorageFields::PredicateDiskType(disk, partition, [`CT_DMRAID, `CT_DMMULTIPATH, `CT_DISK]);
	}

	boolean IsAvailable ( string client )
	{
	    //in the installed system, we don't care if the client isn't there
	    //as the user will be prompted to install the pkg anyway (in CallConfig)
	    if ( !Stage::initial() )
		return true;
	    //check if the client is in inst-sys
	    else
		return WFM::ClientExists(client);
	}

	list<symbol> fields = StorageSettings::FilterTable([ `device, `udev_path, `udev_id, `size, `format,
							     `type, `fs_type, `label, `mount_point, `mount_by,
							     `start_cyl, `end_cyl, `used_by ]);

	map<string, map> target_map = Storage::GetTargetMap();

	term table_header = StorageFields::TableHeader(fields);
	list<term> table_contents = StorageFields::TableContents(fields, target_map, Predicate);

	term buttons = `HBox(
	    // push button text
	    `PushButton(`id(`rescan), `opt(`key_F6), _("Rescan Disks"))
	);

	buttons = add(buttons, `HStretch());

	list<term> configs = [];

	if (IsAvailable("iscsi-client")) {
	    // menu entry text
	    configs = add(configs, `item(`id(`iscsi), `icon("yast-iscsi-client"), _("Configure &iSCSI...")));
	}

	if (true) {
	    // menu entry text
	    configs = add(configs, `item(`id(`multipath), `icon("yast-iscsi-server"), _("Configure &Multipath...")));
	}

	if (Arch::s390() && IsAvailable("s390")) {
	    // menu entry text
	    configs = add(configs, `item(`id(`dasd), `icon("yast-dasd"),  _("Configure &DASD...")));
	    // menu entry text
	    configs = add(configs, `item(`id(`zfcp), `icon("yast-zfcp"),  _("Configure &zFCP...")));
	    // menu entry text
	    configs = add(configs, `item(`id(`xpram), `icon("yast-xpram"), _("Configure &XPRAM...")));
	}

	if (size(configs) > 0) {
	    // menu button text
	    buttons = add(buttons, `MenuButton(`opt(`key_F7), _("Configure..."), configs));
	}

	UI::ReplaceWidget(`tree_panel,
			  Greasemonkey::Transform(
			      `VBox(
				  // heading
				  `IconAndHeading(_("Hard Disks"), StorageIcons::hd_icon),
				  `Table(`id(`table), `opt(`keepSorting, `notify, `notifyContextMenu),
					 table_header, table_contents),
				  buttons
				  )
			      )
	    );

	// helptext
	string helptext = _("<p>This view shows all hard disks including
iSCSI disks, BIOS RAIDs and Multipath disks and their partitions.</p>");

	Wizard::RestoreHelp(helptext + StorageFields::TableHelptext(fields));
    }


    void HandleHdMainPanel(any user_data, map event)
    {
	boolean CheckAndInstallPackages( list <string> pkgs )
	{
	    if (Stage::initial())
		return true;

	    boolean ret = false;
	    //switch off pkg-mgmt loading progress dialogs,
	    //because it just plain sucks
	    PackageCallbacks::RegisterEmptyProgressCallbacks();
	    ret = PackageSystem::CheckAndInstallPackages(pkgs);
	    PackageCallbacks::RestorePreviousProgressCallbacks();

	    return ret;
	}

	void CallConfig(string text, list<string> pkgs, string call)
	{
	    boolean doit = true;

	    if (!Storage::EqualBackupStates("expert-partitioner", "", true))
	    {
		doit = Popup::YesNo(text);
	    }

	    if (doit)
	    {
		if (pkgs == nil || CheckAndInstallPackages(pkgs))
		{
		    if (call != nil)
			WFM::call(call);
		    RescanDisks();
		    Storage::CreateTargetBackup("expert-partitioner");

		    UpdateMainStatus();
		    UpdateNavigationTree(nil);
		    TreePanel::Create();
		}
	    }
	}


	switch (Event::IsWidgetActivated(event))
	{
	    case `rescan:
		// popup text
		CallConfig(_("Rescaning disks cancels all current changes.
Really rescan disks?"), nil, nil);
		break;
	}

	switch (Event::IsMenu(event))
	{
	    case `iscsi:
		// popup text
		CallConfig(_("Calling iSCSI configuration cancels all current changes.
Really call iSCSI configuration?"), ["yast2-iscsi-client"], "iscsi-client");
		break;

	    case `multipath:
		if ((ProductFeatures::GetBooleanFeature("partitioning", "use_separate_multipath_module") == true) ||
		    (Mode::normal() && WFM::ClientExists("multipath")))
		    // popup text
		    CallConfig(_("Calling Multipath configuration cancels all current changes.
Really call Multipath configuration?"), ["yast2-multipath"], "multipath");
		else
		    // popup text
		    CallConfig(_("Calling Multipath configuration cancels all current changes.
Really call Multipath configuration?"), nil, "multipath-simple");
		break;

	    case `dasd:
		// popup text
		CallConfig(_("Calling DASD configuration cancels all current changes.
Really call DASD configuration?"), ["yast2-s390"], "dasd");
		break;

	    case `zfcp:
		// popup text
		CallConfig(_("Calling zFCP configuration cancels all current changes.
Really call zFCP configuration?"), ["yast2-s390"], "zfcp");
		break;

	    case `xpram:
		// popup text
		CallConfig(_("Calling XPRAM configuration cancels all current changes.
Really call XPRAM configuration?"), ["yast2-s390"], "xpram");
		break;
	}


	switch (Event::IsWidgetContextMenuActivated(event))
	{
	    case `table:
		string device = (string) UI::QueryWidget(`id(`table), `CurrentItem);
		EpContextMenuDevice(device);
		break;
	}
    }


    void CreateHdDiskOverviewTab(any user_data)
    {
	string device = (string) user_data;

	map<string, map> target_map = Storage::GetTargetMap();

	list<symbol> fields = StorageSettings::FilterOverview([ `heading_device, `device, `size, `udev_path,
								`udev_id, `used_by, `heading_hd, `vendor,
								`model, `num_cyl, `cyl_size, `bus, `bios_id,
								`disk_label, `heading_fc, `fc_wwpn, `fc_port_id,
								`fc_fcp_lun ]);

	UI::ReplaceWidget(`tab_panel,
			  `VBox(
			      `HStretch(),
			      StorageFields::Overview(fields, target_map, device),
			      `HBox(
				  // push button text
				  `PushButton(`id(`delete), _("Delete...")),
				  `HStretch(),
				  // push button text
				  `PushButton(`id(`smart), _("Smart...")),
				  // push button text
				  `PushButton(`id(`hdparm), _("HD Parm..."))
				  )
			      )
	    );

	// helptext
	string helptext = _("<p>This view shows detailed information about the
selected hard disk.</p>");

	Wizard::RestoreHelp(helptext + StorageFields::OverviewHelptext(fields));
    }


    void HandleHdDiskOverviewTab(any user_data, map event)
    {
	string disk_device = (string) user_data;

	switch (Event::IsWidgetActivated(event))
	{
	    case `delete:
	    {
		EpDeleteDisk(disk_device);
		break;
	    }

	    case `smart:
	    {
		map<string, map> target_map = Storage::GetTargetMap();
		map disk = target_map[disk_device]:$[];
		if (disk["type"]:`CT_UNKNOWN != `CT_DISK || substring(disk_device, 0, 9) == "/dev/dasd")
		{
		    Popup::Error(_("Smart is not available for this disk."));
		    break;
		}
		DisplayCommandOutput(sformat("/usr/sbin/smartctl --health '%1'", disk_device));
		break;
	    }

	    case `hdparm:
	    {
		map<string, map> target_map = Storage::GetTargetMap();
		map disk = target_map[disk_device]:$[];
		if (disk["type"]:`CT_UNKNOWN != `CT_DISK || substring(disk_device, 0, 9) == "/dev/dasd")
		{
		    Popup::Error(_("HD Parm is not available for this disk."));
		    break;
		}
		DisplayCommandOutput(sformat("/sbin/hdparm -aAgr '%1'", disk_device));
		break;
	    }
	}
    }


    void CreateHdDiskPartitionsTab(any user_data)
    {
	string device = (string) user_data;

	symbol Predicate(map disk, map partition)
	{
	    return StorageFields::PredicateDiskDevice(disk, partition, [ device ]);
	}

	list<symbol> fields = StorageSettings::FilterTable([ `device, `udev_path, `udev_id, `size, `format,
							     `type, `fs_type, `label, `mount_point, `mount_by,
							     `start_cyl, `end_cyl, `used_by ]);

	map<string, map> target_map = Storage::GetTargetMap();

	term table_header = StorageFields::TableHeader(fields);
	list<term> table_contents = StorageFields::TableContents(fields, target_map, Predicate);

	list<term> expert_cmds = [
	    `item(`id(`create_partition_table),
		  // menu entry text
		  _("Create New Partition Table"))
	    ];

	if (Arch::s390() && search(device, "/dev/dasd") == 0)
	{
	    expert_cmds = add(expert_cmds,
			      `item(`id(`dasdfmt),
				    // menu entry text
				    _("Execute dasd&fmt on the DASD Device"))
		);
	}

	map ddata = Storage::GetDisk(target_map, device);
	list <integer> bits = [];
	list <string> labels = [];

	foreach (map part, ddata["partitions"]:[], {
	    if ( part["type"]:`primary != `extended)
	    {
	        list <integer> region = part["region"]:[];
	        integer tmp = 100*Region::Length( region )/ddata["cyl_count"]:1; //in %
		string descr = part["device"]:"" + "\n" + Storage::KByteToHumanStringOmitZeroes(part["size_k"]:0);

		// Guarantee some minimal share (1%) of total graph width to a segment
		// It prevents small partitions e.g. swaps from disappearing completely
		bits = add( bits, (tmp < 1) ? 1 : tmp );
		labels = add( labels, descr);
	    }
	});

	UI::ReplaceWidget(`tab_panel,
			  `VBox(
			      UI::TextMode() ? `Empty() : `BarGraph(`id(`bgraph), bits, labels),
			      `Table(`id(`table), `opt(`keepSorting, `notify, `notifyContextMenu),
				     table_header, table_contents),
			      `HBox(
				  // push button text
				  `PushButton(`id(`add),`opt(`key_F3), _("Add...")),
				  // push button text
				  `PushButton(`id(`edit),`opt(`key_F4), _("Edit...")),
				  // push button text
				  `PushButton(`id(`resize), `opt(`key_F6), _("Resize...")),
				  // push button text
				  `PushButton(`id(`delete), `opt(`key_F5), _("Delete...")),
				  `HStretch(),
				  // menu button text
				  `MenuButton(`opt(`key_F7), _("Expert..."), expert_cmds)
				  )
			      ));

	// helptext
	string helptext = _("<p>This view shows all partitions of the selected
hard disk. If the hard disk is used by e.g. BIOS RAID or multipath no
partitions are shown here.</p>");

	Wizard::RestoreHelp(helptext + StorageFields::TableHelptext(fields));
    }


    void HandleHdDiskPartitionsTab(any user_data, map event)
    {
	string disk_device = (string) user_data;
	string part_device = (string) UI::QueryWidget(`id(`table), `CurrentItem);

	switch (Event::IsWidgetActivated(event))
	{
	    case `add:
		EpCreatePartition(disk_device);
		break;

	    case `edit:
		EpEditPartition(part_device);
		break;

	    case `resize:
		EpResizePartition(part_device);
		break;

	    case `delete:
		EpDeletePartition(part_device, `table);
		break;
	}

	switch (Event::IsMenu(event))
	{
	    case `create_partition_table:
		EpCreatePartitionTable(disk_device);
		break;

	    case `dasdfmt:
		EpDasdfmtDisk(disk_device);
		break;
	}

	switch (Event::IsWidgetContextMenuActivated(event))
	{
	    case `table:
		EpContextMenuDevice(part_device);
		break;
	}

	UI::SetFocus(`id(`table));
    }


    void CreateHdDiskDevicesTab(any user_data)
    {
	string part_device = (string) user_data;

	symbol Predicate(map disk, map partition)
	{
	    return StorageFields::PredicateUsedByDevice(disk, partition, [ part_device ]);
	}

	list<symbol> fields = StorageSettings::FilterTable([ `device, `udev_path, `udev_id, `size,
							     `format, `type, `used_by ]);

	map<string, map> target_map = Storage::GetTargetMap();

	term table_header = StorageFields::TableHeader(fields);
	list<term> table_contents = StorageFields::TableContents(fields, target_map, Predicate);

	UI::ReplaceWidget(`tab_panel,
			  `VBox(
			      `Table(`id(`table), `opt(`keepSorting, `notify),
				     table_header, table_contents)
			      )
	    );

	// helptext
	string helptext = _("<p>This view shows all devices used by the
selected hard disk. The table is non-empty only for BIOS RAIDs and Multipath
Disks.</p>");

	Wizard::RestoreHelp(helptext + StorageFields::TableHelptext(fields));
    }


    void CreateHdDiskPanel(any user_data)
    {
	string device = (string) user_data;

	map<string, map> target_map = Storage::GetTargetMap();

	map<symbol, map> data = $[ `overview : $[ `create : CreateHdDiskOverviewTab,
						  `handle : HandleHdDiskOverviewTab,
						  `user_data : user_data ],
				   `partitions : $[ `create : CreateHdDiskPartitionsTab,
						    `handle : HandleHdDiskPartitionsTab,
						    `user_data : user_data ],
				   `devices : $[ `create : CreateHdDiskDevicesTab,
						 `user_data : user_data ] ];

	UI::ReplaceWidget(`tree_panel,
			  Greasemonkey::Transform(
			      `VBox(
				  // heading
				  `IconAndHeading(sformat(_("Hard Disk: %1"), device), StorageIcons::hd_icon),
				  `DumbTab(`id(`tab), [
					       // tab heading
					       `item(`id(`overview), _("&Overview")),
					       // tab heading
					       `item(`id(`partitions), _("&Partitions")),
					       // tab heading
					       `item(`id(`devices), _("&Used Devices"))
					       ],
					   `ReplacePoint(`id(`tab_panel), TabPanel::empty_panel)
				      )
				  )
			      ));

	TabPanel::Init(data, `partitions);
    }


    void HandleHdDiskPanel(any user_data, map event)
    {
	TabPanel::Handle(event);
    }


    void CreateHdPartitionPanel(any user_data)
    {
	string device = (string) user_data;

	map<string, map> target_map = Storage::GetTargetMap();

	list<symbol> fields = StorageSettings::FilterOverview([ `heading_device, `device, `size, `udev_path,
								`udev_id, `used_by, `fs_id, `heading_filesystem,
								`fs_type, `mount_point, `mount_by, `uuid,
								`label, `encrypted ]);

	UI::ReplaceWidget(`tree_panel,
			  Greasemonkey::Transform(
			      `VBox(
				  `HStretch(),
				  // heading
				  `IconAndHeading(sformat(_("Partition: %1"), device), StorageIcons::hd_part_icon),
				  StorageFields::Overview(fields, target_map, device),
				  `HBox(
				      // push button text
				      `PushButton(`id(`edit), `opt(`key_F4), _("Edit...")),
				      // push button text
				      `PushButton(`id(`resize), `opt(`key_F6), _("Resize...")),
				      // push button text
				      `PushButton(`id(`delete), `opt(`key_F5), _("Delete...")),
				      `HStretch()
				      )
				  )
			      )
	    );

	// helptext
	string helptext = _("<p>This view shows detailed information about the
selected partition.</p>");

	Wizard::RestoreHelp(helptext + StorageFields::OverviewHelptext(fields));
    }


    void HandleHdPartitionPanel(any user_data, map event)
    {
	string part_device = (string) user_data;

	switch (Event::IsWidgetActivated(event))
	{
	    case `edit:
		EpEditPartition(part_device);
		break;

	    case `resize:
		EpResizePartition(part_device);
		break;

	    case `delete:
		EpDeletePartition(part_device, `overview);
		break;
	}

	UI::SetFocus(`id(`text));
    }
}
