/**
 * File:        ep-hd.ycp
 * Package:     yast2-storage
 * Summary:     Expert Partitioner
 * Authors:     Arvin Schnell <aschnell@suse.de>
 *
 * This file must only be included in other Expert Partitioner files ("ep-*.ycp").
 */
{
    textdomain "storage";

    include "partitioning/ep-hd-dialogs.ycp";
    include "partitioning/ep-hd-lib.ycp";


    void EpContextMenuHdDisk(string device)
    {
	symbol widget = ContextMenu::Simple([ `item(`id(`add), `icon(StorageIcons::hd_part_icon), _("Add Partition")),
					      `item(`id(`delete), _("Delete")) ]);

	switch (widget)
	{
	    case `add:
		EpCreatePartition(device);
		break;

	    case `delete:
		EpDeleteDisk(device);
		break;
	}
    }


    void EpContextMenuHdPartition(string device)
    {
	symbol widget = ContextMenu::Simple([ `item(`id(`edit), _("Edit")),
					      `item(`id(`resize), _("Resize")),
					      `item(`id(`delete), _("Delete")) ]);

	switch (widget)
	{
	    case `edit:
		EpEditPartition(device);
		break;

	    case `resize:
		EpResizePartition(device);
		break;

	    case `delete:
		EpDeletePartition(device, `table);
		break;
	}
    }

    term HdButtonBox()
    {
	return `HBox(
	    // push button text
	    `PushButton(`id(`edit),`opt(`key_F4), _("Edit...")),
	    // push button text
	    `PushButton(`id(`resize), `opt(`key_F6), _("Resize...")),
	    // push button text
	    `PushButton(`id(`delete), `opt(`key_F5), _("Delete..."))
	);
    }

    void HandleHdButtons( any user_data, string device, map event )
    {
	string disk = "";
	boolean is_disk = false;

	if (user_data == nil)
	{
	    map dev = Storage::GetDiskPartition( device );
	    disk = (string) dev["disk"]:nil;
	    // FIXME: is this necessary & sufficient condition?
	    is_disk =  dev["nr"]:nil == "";
	}
	else
	{
	    disk = (string) user_data;
	}

	switch (Event::IsWidgetActivated(event))
	{
	    case `add:
		EpCreatePartition( disk );
		break;
	    case `edit:
		if  ( is_disk )
		    TreePanel::SwitchToNew( disk );
		else
		    EpEditPartition( device );
		break;

	    case `resize:
		if  ( is_disk )
		    Popup::Error(_("Hard disks, BIOS RAIDs and multipath
devices cannot be resized."));
		else
		    EpResizePartition ( device );
		break;

	    case `delete:
		if  ( is_disk )
		    EpDeleteDisk( device );
		else
		    EpDeletePartition ( device, UI::WidgetExists(`id(`table)) ? `table : `overview );
		break;
	}
    }

    void CreateHdMainPanel(any user_data)
    {
	symbol Predicate(map disk, map partition)
	{
	    return StorageFields::PredicateDiskType(disk, partition, [`CT_DMRAID, `CT_DMMULTIPATH, `CT_DISK]);
	}



	list<symbol> fields = StorageSettings::FilterTable([ `device, `udev_path, `udev_id, `size, `format,
							     `type, `fs_type, `label, `mount_point, `mount_by,
							     `start_cyl, `end_cyl, `used_by ]);

	map<string, map> target_map = Storage::GetTargetMap();

	term table_header = StorageFields::TableHeader(fields);
	list<term> table_contents = StorageFields::TableContents(fields, target_map, Predicate);

	UI::ReplaceWidget(`tree_panel,
			  Greasemonkey::Transform(
			      `VBox(
				  // heading
				  `IconAndHeading(_("Hard Disks"), StorageIcons::hd_icon),
				  `Table(`id(`table), `opt(`keepSorting, `notify, `notifyContextMenu),
					 table_header, table_contents),
				  `HBox(
					// push button text
					`PushButton(`id(`add),`opt(`key_F3), _("Add Partition...")),
					HdButtonBox(),
					`HStretch()
				  )
			      )
			)
	    );

	// helptext
	string helptext = _("<p>This view shows all hard disks including
iSCSI disks, BIOS RAIDs and Multipath disks and their partitions.</p>");

	Wizard::RestoreHelp(helptext + StorageFields::TableHelptext(fields));
    }


    void HandleHdMainPanel(any user_data, map event)
    {
	string device = (string) UI::QueryWidget(`id(`table), `CurrentItem);

	HandleHdButtons( user_data, device, event );

	switch (Event::IsWidgetContextMenuActivated(event))
	{
	    case `table:
		EpContextMenuDevice(device);
		break;
	}
    }


    void CreateHdDiskOverviewTab(any user_data)
    {
	string device = (string) user_data;

	map<string, map> target_map = Storage::GetTargetMap();

	list<symbol> fields = StorageSettings::FilterOverview([ `heading_device, `device, `size, `udev_path,
								`udev_id, `used_by, `heading_hd, `vendor,
								`model, `num_cyl, `cyl_size, `bus, `bios_id,
								`disk_label, `heading_fc, `fc_wwpn, `fc_port_id,
								`fc_fcp_lun ]);

	UI::ReplaceWidget(`tab_panel,
			  `VBox(
			      `HStretch(),
			      StorageFields::Overview(fields, target_map, device),
			      `HBox(
				  // push button text (do not translate 'SMART', it is the name of the tool)
				  `PushButton(`id(`smart), _("Health Test (SMART)...")),
				  // push button text (do not translate 'hdparm', it is the name of the tool)
				  `PushButton(`id(`hdparm), _("Properties (hdparm)...")),
				  `HStretch()
				  )
			      )
	    );

	// helptext
	string helptext = _("<p>This view shows detailed information about the
selected hard disk.</p>");

	Wizard::RestoreHelp(helptext + StorageFields::OverviewHelptext(fields));
    }


    void HandleHdDiskOverviewTab(any user_data, map event)
    {
	string disk_device = (string) user_data;

	switch (Event::IsWidgetActivated(event))
	{
	    case `smart:
	    {
		map<string, map> target_map = Storage::GetTargetMap();
		map disk = target_map[disk_device]:$[];
		if (disk["type"]:`CT_UNKNOWN != `CT_DISK || substring(disk_device, 0, 9) == "/dev/dasd")
		{
		    Popup::Error(_("SMART is not available for this disk."));
		    break;
		}
		DisplayCommandOutput(sformat("/usr/sbin/smartctl --health '%1'", disk_device));
		break;
	    }

	    case `hdparm:
	    {
		map<string, map> target_map = Storage::GetTargetMap();
		map disk = target_map[disk_device]:$[];
		if (disk["type"]:`CT_UNKNOWN != `CT_DISK || substring(disk_device, 0, 9) == "/dev/dasd")
		{
		    Popup::Error(_("hdparm is not available for this disk."));
		    break;
		}
		DisplayCommandOutput(sformat("/sbin/hdparm -aAgr '%1'", disk_device));
		break;
	    }
	}
    }


    void CreateHdDiskPartitionsTab(any user_data)
    {
	string device = (string) user_data;

	symbol Predicate(map disk, map partition)
	{
	    return StorageFields::PredicateDiskDevice(disk, partition, [ device ]);
	}

	list<symbol> fields = StorageSettings::FilterTable([ `device, `udev_path, `udev_id, `size, `format,
							     `type, `fs_type, `label, `mount_point, `mount_by,
							     `start_cyl, `end_cyl, `used_by ]);

	map<string, map> target_map = Storage::GetTargetMap();

	term table_header = StorageFields::TableHeader(fields);
	list<term> table_contents = StorageFields::TableContents(fields, target_map, Predicate);

	list<term> expert_cmds = [
	    `item(`id(`create_partition_table),
		  // menu entry text
		  _("Create New Partition Table"))
	    ];

	if (Arch::s390() && search(device, "/dev/dasd") == 0)
	{
	    expert_cmds = add(expert_cmds,
			      `item(`id(`dasdfmt),
				    // menu entry text
				    _("Execute dasd&fmt on the DASD Device"))
		);
	}

	term partitions_bargraph = `Empty();

	if (UI::HasSpecialWidget(`BarGraph))
	{
	    map ddata = Storage::GetDisk(target_map, device);

	    if (ddata["used_by"]:`UB_NONE == `UB_NONE)
	    {
		list <integer> bits = [];
		list <string> labels = [];

		foreach (map part, ddata["partitions"]:[], {
		    if (part["type"]:`primary != `extended)
		    {
			list <integer> region = part["region"]:[];
			integer tmp = 100*Region::Length( region )/ddata["cyl_count"]:1; //in %
			string descr = part["device"]:"" + "\n" + Storage::KByteToHumanStringOmitZeroes(part["size_k"]:0);

			// Guarantee some minimal share (1%) of total graph width to a segment
			// It prevents small partitions e.g. swaps from disappearing completely
			bits = add( bits, (tmp < 1) ? 1 : tmp );
			labels = add( labels, descr);
		    }
		});

		partitions_bargraph = `BarGraph(`id(`bgraph), bits, labels);
	    }
	}

	UI::ReplaceWidget(`tab_panel,
			  `VBox(
			      partitions_bargraph,
			      `Table(`id(`table), `opt(`keepSorting, `notify, `notifyContextMenu),
				     table_header, table_contents),
			      `HBox(
				  // push button text
				  `PushButton(`id(`add),`opt(`key_F3), _("Add...")),
				   HdButtonBox(),
				  `HStretch(),
				  // menu button text
				  `MenuButton(`opt(`key_F7), _("Expert..."), expert_cmds)
				  )
			      ));

	// helptext
	string helptext = _("<p>This view shows all partitions of the selected
hard disk. If the hard disk is used by e.g. BIOS RAID or multipath no
partitions are shown here.</p>");

	Wizard::RestoreHelp(helptext + StorageFields::TableHelptext(fields));
    }


    void HandleHdDiskPartitionsTab(any user_data, map event)
    {
	string disk_device = (string) user_data;
	string part_device = (string) UI::QueryWidget(`id(`table), `CurrentItem);

	HandleHdButtons( disk_device, part_device, event );

	switch (Event::IsMenu(event))
	{
	    case `create_partition_table:
		EpCreatePartitionTable(disk_device);
		break;

	    case `dasdfmt:
		EpDasdfmtDisk(disk_device);
		break;
	}

	switch (Event::IsWidgetContextMenuActivated(event))
	{
	    case `table:
		EpContextMenuDevice(part_device);
		break;
	}

	UI::SetFocus(`id(`table));
    }


    void CreateHdDiskDevicesTab(any user_data)
    {
	string part_device = (string) user_data;

	symbol Predicate(map disk, map partition)
	{
	    return StorageFields::PredicateUsedByDevice(disk, partition, [ part_device ]);
	}

	list<symbol> fields = StorageSettings::FilterTable([ `device, `udev_path, `udev_id, `size,
							     `format, `type, `used_by ]);

	map<string, map> target_map = Storage::GetTargetMap();

	term table_header = StorageFields::TableHeader(fields);
	list<term> table_contents = StorageFields::TableContents(fields, target_map, Predicate);

	UI::ReplaceWidget(`tab_panel,
			  `VBox(
			      `Table(`id(`table), `opt(`keepSorting, `notify),
				     table_header, table_contents)
			      )
	    );

	// helptext
	string helptext = _("<p>This view shows all devices used by the
selected hard disk. The table is non-empty only for BIOS RAIDs and Multipath
Disks.</p>");

	Wizard::RestoreHelp(helptext + StorageFields::TableHelptext(fields));
    }


    void CreateHdDiskPanel(any user_data)
    {
	string device = (string) user_data;

	map<string, map> target_map = Storage::GetTargetMap();

	map<symbol, map> data = $[ `overview : $[ `create : CreateHdDiskOverviewTab,
						  `handle : HandleHdDiskOverviewTab,
						  `user_data : user_data ],
				   `partitions : $[ `create : CreateHdDiskPartitionsTab,
						    `handle : HandleHdDiskPartitionsTab,
						    `user_data : user_data ],
				   `devices : $[ `create : CreateHdDiskDevicesTab,
						 `user_data : user_data ] ];

	UI::ReplaceWidget(`tree_panel,
			  Greasemonkey::Transform(
			      `VBox(
				  // heading
				  `IconAndHeading(sformat(_("Hard Disk: %1"), device), StorageIcons::hd_icon),
				  `DumbTab(`id(`tab), [
					       // tab heading
					       `item(`id(`overview), _("&Overview")),
					       // tab heading
					       `item(`id(`partitions), _("&Partitions")),
					       // tab heading
					       `item(`id(`devices), _("&Used Devices"))
					       ],
					   `ReplacePoint(`id(`tab_panel), TabPanel::empty_panel)
				      )
				  )
			      ));

	TabPanel::Init(data, `partitions);
    }


    void HandleHdDiskPanel(any user_data, map event)
    {
	TabPanel::Handle(event);
    }


    void CreateHdPartitionPanel(any user_data)
    {
	string device = (string) user_data;

	map<string, map> target_map = Storage::GetTargetMap();

	list<symbol> fields = StorageSettings::FilterOverview([ `heading_device, `device, `size, `udev_path,
								`udev_id, `used_by, `fs_id, `heading_filesystem,
								`fs_type, `mount_point, `mount_by, `uuid,
								`label, `encrypted ]);

	UI::ReplaceWidget(`tree_panel,
			  Greasemonkey::Transform(
			      `VBox(
				  `HStretch(),
				  // heading
				  `IconAndHeading(sformat(_("Partition: %1"), device), StorageIcons::hd_part_icon),
				  StorageFields::Overview(fields, target_map, device),
				  `HBox(
				      HdButtonBox(),
				      `HStretch()
				      )
				  )
			      )
	    );

	// helptext
	string helptext = _("<p>This view shows detailed information about the
selected partition.</p>");

	Wizard::RestoreHelp(helptext + StorageFields::OverviewHelptext(fields));
    }


    void HandleHdPartitionPanel(any user_data, map event)
    {
	string part_device = (string) user_data;

	HandleHdButtons( nil, part_device, event);
	UI::SetFocus(`id(`text));
    }
}
