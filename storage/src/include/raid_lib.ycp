/*
 * Copyright (c) 2012 Novell, Inc.
 *
 * All Rights Reserved.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as published
 * by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
 * more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, contact Novell, Inc.
 *
 * To contact Novell about this file by physical or electronic mail, you may
 * find current contact information at www.novell.com.
 */

/**
 * File:
 *   raid_lib.ycp
 *
 * Module:
 *    configuration of raid:
 *
 * Summary:
 *
 * Authors:
 *   mike <mike@suse.de>
 *
 * $Id$
 */
{
  import "Partitions";

  textdomain "storage";


/*
 * Get all partitions, we can probably use as raid devices
 * Add needed information: is_raid, disksize
 */
define list<map> get_possible_rds( map<string,map> targetMap )
    ``{
    list<map> ret = [];

    //////////////////////////////////////////////////////////////////////
    // add the devicename i.e /dev/hda1 or /dev/system/usr to partition list
    // and the device key  <subdevice>/<maindevice> i.e. 1//dev/hda

    targetMap = mapmap( string dev, map devmap, targetMap,
	``{
	list<map> partitions = 
	    maplist( map part, devmap["partitions"]:[],
		``{
		part["maindev"] = dev;
		return( part );
		});

	return( $[ dev: add( devmap, "partitions", partitions)] );
	});

    ////////////////////////////////////////////////////////////
    // Look for all partitions:
    // not LVM ( here I mean /dev/<lvm_volumegroup>/<lv> entrys!
    //           there are only the lv's in the targetMap under 
    //           /dev/<lvm_volumegroup>/<lv> !)
    // no mountpoint
    // id 0x83 or 0x8e or 0xfd
    // no RAID devices (this is for experts only, by hand)

    list<map> allret = [];

    list<symbol> allowed_ctypes = [ `CT_DISK, `CT_DMRAID, `CT_DMMULTIPATH ];
    list types_no = [ `lvm, `sw_raid ];
    list fsids = [ Partitions::fsid_lvm, Partitions::fsid_raid, 
                   Partitions::fsid_native ];
    list allowed_enc_types = [ `none ];

    foreach (string dev, map devmap, targetMap, {
	if (contains(allowed_ctypes, devmap["type"]:`CT_UNKNOWN))
	{
	ret = filter( map p, devmap["partitions"]:[],
		      ``( size(p["mount"]:"")==0 &&
			  !contains( types_no, p["type"]:`primary ) &&
			  contains(allowed_enc_types, p["enc_type"]:`none) &&
			  (!Storage::IsUsedBy(p) || p["used_by_type"]:`UB_NONE==`UB_MD) &&
			  (!haskey(p,"fsid")||contains( fsids, p["fsid"]:0 ))));
        allret = (list<map>)merge(allret, ret );
	}
	});
    return( allret );
    };
}
