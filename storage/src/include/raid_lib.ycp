/**
 * File:
 *   raid_lib.ycp
 *
 * Module:
 *    configuration of raid:
 *
 * Summary:
 *
 * Authors:
 *   mike <mike@suse.de>
 *
 * $Id$
 *
 *
 *----------------------
 *  rd or Rd == raid device, a device like hda1 or /dev/system/usr
 *              that belongs to a raid
 */


{
  import "Storage";
  import "Mode";
  import "Partitions";
  import "Wizard";
  textdomain "storage";


/**
 * Build raid dev item list e.g.: [`item (`id ("/dev/md2"), "/dev/md2", false)]
 *
 **/
define list<term> get_raid_devices( map tg, integer raid_nr )
    ``{
    list<term> all_raid_devices = [];
    list<map> partitions = tg["/dev/md","partitions"]:[];

    foreach( map part, partitions, 
	``{
	integer num = part["nr"]:255;
	all_raid_devices = 
	    add( all_raid_devices, 
		 `item( `id(sformat("/dev/md%1", num )),
			Storage::GetDeviceName( "/dev/md", num ), 
			num == raid_nr ));
	});
    return all_raid_devices;
    };


  /**
   * Checks if a RAID is currently created or if it was already
   *
   **/
define boolean IsRaidCreated( map tg, string device, symbol what )
    ``{
    boolean created = false;
    if( what != `wizard )
	{
	list<map> partitions = (list<map>)tg["/dev/md", "partitions"]:[];
	y2milestone( "parts %1", partitions );

	foreach( map part, partitions, 
	    ``{
	    if( part["device"]:""==device && part["create"]:false )
		{
		created = true;
		}
	    });
	}
    else
	{
	created = true;
	}
    y2milestone( "device %1 what %2 created %3", device, what, created );
    return( created );
    };



/**
  * Update Raid ComboBox
  *
  */
define void new_raid_list( list<term> all_raids )
    ``{
    y2milestone( "Update Raid ComboBox: all md devices: %1 " , all_raids );
    UI::ReplaceWidget( `id(`raids_rp) , `ComboBox(`id(`raids), `opt(`notify),
		       // label text
                       _("R&AID:"),all_raids ));
    };


/*
 * Get all partitions, we can probably use as raid devices
 * Add needed information: is_raid, disksize
 */
define list<map> get_possible_rds( map<string,map> targetMap )
    ``{
    list<map> ret = [];

    //////////////////////////////////////////////////////////////////////
    // add the devicename i.e /dev/hda1 or /dev/system/usr to partition list
    // and the device key  <subdevice>/<maindevice> i.e. 1//dev/hda

    targetMap = mapmap( string dev, map devmap, targetMap,
	``{
	list<map> partitions = 
	    maplist( map part, devmap["partitions"]:[],
		``{
		part["maindev"] = dev;
		return( part );
		});

	return( $[ dev: add( devmap, "partitions", partitions)] );
	});

    ////////////////////////////////////////////////////////////
    // Look for all partitions:
    // not LVM ( here I mean /dev/<lvm_volumegroup>/<lv> entrys!
    //           there are only the lv's in the targetMap under 
    //           /dev/<lvm_volumegroup>/<lv> !)
    // no mountpoint
    // id 0x83 or 0x8e or 0xfd
    // no RAID devices (this is for experts only, by hand)

    list<map> allret = [];
    list types_no = [ `lvm, `sw_raid, `evms ];
    list fsids = [ Partitions::fsid_lvm, Partitions::fsid_raid, 
                   Partitions::fsid_native ];
    list ubs = [ `UB_NONE, `UB_MD ];
    foreach( string dev, map devmap, targetMap,
	``{
	ret = filter( map p, devmap["partitions"]:[],
		      ``( size(p["mount"]:"")==0 &&
			  !contains( types_no, p["type"]:`primary ) &&
			  contains( ubs, p["used_by_type"]:`UB_NONE ) && 
			  (!haskey(p,"fsid")||contains( fsids, p["fsid"]:0 ))));
        allret = (list<map>)merge(allret, ret );
	});
    return( allret );
    };




/*
 * @param targetMap
 * @param partition  the raid for which the size is calculated
 * out: size of RAID as string
 */
define string raid_size_str( map partition )
    ``{
    return( ByteToHumanStringWithZero( partition["size_k"]:0*1024 ));
    };


/*
 * in: targetMap: the targetMap ;-)
 * in: partition: the raid for which the size is calculated
 * out: size of RAID in byte
 */
define integer raid_size_byte( map partition )
    ``{
    return( partition["size_k"]:0*1024 );
    };


/*
 * get the number of devices which belong to the raid
 */
define integer getNrOfParts( map<string,map> targetMap, string current_raid )
    ``{
    list<map> partition_list = get_possible_rds( targetMap );
    string dev = "md" + current_raid;

    partition_list = filter( map part, partition_list, 
			     ``( part["used_by"]:""==dev ) );
    return( size( partition_list ) );
    };


/**
 * belongs the the partition "id" already to a raid
 **/
define boolean isItemRd( map<string,map> tg, string id )
    ``{
    map partition = Storage::GetPartition( tg, id );
    return( partition["used_by_type"]:`UB_NONE == `UB_MD );
    };


/**
 * belongs the the partition "id" already to a raid
 * if YES: popup a proper Message and return(false)
 */
define boolean CheckItemIsNotRaid( map<string,map> tg, string id )
    ``{
    y2debug("Check Item is not Raid ");
    // error case:
    if( id!=nil && size(id) > 0 )
	{
	if( !isItemRd(tg,id) )
	    {
	    return( true );
	    }
	// Message popup
	Popup::Message (sformat(_("Item %1 is already a RAID device.
You cannot add it again.
"), id));
	}
    else
	{
	//Message popup
	Popup::Message(_("You have to select one device in the table"));
	}

    return( false );
    };


/**
 *  belongs the the partition "id" already to a raid?
 * if NO: popup a proper Message and return(false)
 **/
define boolean CheckItemIsRaid( map<string,map> tg, string id )
    ``{
    // error case:
    if( id!=nil && size(id) > 0 )
	{
	if( isItemRd(tg,id) )
	    {
	    return( true );
	    }
	// Message popup
	Popup::Message (sformat(_("Item %1 cannot be removed.
It does not belong to a RAID.
"),  id ));
	}
    else
	{
	//Message popup
	Popup::Message (_("You have to select one device in the table"));
	}

    return( false );
    };


  
/**
  *  partition list to widget table
  * in:
  * [  $["fsid":142,
  *	  "fstype":"Linux raid",
  *	  "nr":"var",
  *	  "region":[255, 16],
  *	  "type":`primary],
  *	  $[
  *	   "fsid":131,
  *	   "fstype":"Linux native",
  *	   "nr":4, "region":[271, 844],
  *    ...
  *
  * out:
  * [
  * 	`item(`id("/dev/hda1"), "/dev/hda1 ",   " 2G ",  " LVM ",   "md1"),
  * 	`item(`id("/dev/hda2"), "/dev/hda2 ",   " 1G ",  " Linux ", " ")
  * ];
  **/
define list get_raid_widget_table( list<map> possRdList )
    ``{
    possRdList = 
	sort( map x, map y, possRdList,
	    ``{
	    if( x["maindev"]:"" == y["maindev"]:"" )
		{
		return( x["nr"]:0 < y["nr"]:0 );
		}
	    else
		{
		return( x["maindev"]:"" < y["maindev"]:"");
		}
	    });

    return( maplist( map p, possRdList,
	    ``{
	    return(`item( `id(p["device"]:"--"), p["device"]:"--",
			  ByteToHumanStringWithZero(p["size_k"]:0*1024),
			  p["fstype"]:"--",
			  p["used_by"]:"--"
		        ));
	    }));
    };

    
/**
 * number for /dev/mdX, 0 for /dev/md0, 1 for /dev/md1
 */
define integer get_free_raid_nr( map<string,map> targetMap, integer min )
    ``{
    integer i = min;
    list raid_nrs = maplist( map mdX, targetMap["/dev/md","partitions"]:[],
			     ``(mdX["nr"]:256)) ;
    while( contains(raid_nrs, i) && i < 255)
	{
	i = i+1;
	}
    y2milestone( "get_free_raid_nr ret:%1", i );
    return( i );
    };

/**
 * Add the main device ( "/dev/hda") to the partition map.
 * partition = $[
 *                "nr"	: 1,
 *		      "main_dev": "/dev/hda",
 *              ......
 *              ];
 * Use change !!!!!!!!!
 * @param targetMap all targets
 * @return nil
 */
define map add_main_dev_to_partition_map( map<string,map> targetMap )
    ``{
    foreach( string targetdevice, map target, targetMap, 
	``{
	targetMap[targetdevice,"partitions"] = 
	    maplist( map p, target["partitions"]:[],
		``({
		if( size(p["used_by"]:"")>0 )
		    {
		    p["main_dev"] = targetdevice;
		    }
		return( p );
		}));
	});
    y2debug("targets %1", targetMap );
    return( targetMap );
    };

/**
 * @return list a list with all partition that have a key raid_name != "".
 * @param targetMap all targets
 */
define list<map> all_raid_partitions( map<string,map> targetMap ) 
    ``{
    list<list> ret = 
      (list<list>) maplist( string targetdevice, map target, targetMap,
			    ``( filter( map part, target["partitions"]:[],
					``(part["used_by_type"]:`UB_NONE==`UB_MD))));
    return(list<map>)( flatten(ret) );
    };

define boolean check_raid_possible( map<string,map> targetMap )
    ``{
    integer possible_parts_found = size(get_possible_rds(targetMap));

    if( possible_parts_found < 2 )
        {
        // Translators: the text 'do not format' must match the label in the corresponding popup!
        Popup::Message(_("To use RAID, at least two partitions of type 0xFD (or 0x83)
are required. Change your partition table accordingly.
In most cases, this can be done in the following way:
click 'Create', select 'Do not format', and set the File System ID to 0xFD.
"));

        return false;
        }
    return true;
    }

}

