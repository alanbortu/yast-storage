/**
 * File:	ep-dialogs.ycp
 * Package:	yast2-storage
 * Summary:	Expert Partitioner
 * Authors:	Arvin Schnell <aschnell@suse.de>
 */
{
    include "partitioning/custom_part_lib.ycp";

    textdomain "storage";


    string MiniWorkflowStepFormatMountHelptext()
    {
	// helptext
	string helptext = _("<p>First, choose whether the partition should be
formatted and the desired file system type.</p>");

	// helptext
	helptext = helptext + _("<p>Then, choose whether the partition should
be mounted and enter the mount point (/, /boot, /usr, /var, etc.).</p>");

	return helptext;
    }


    symbol MiniWorkflowStepFormatMount(map<string, any> &orig_data)
    {
	map<string, any> data = orig_data;
	y2milestone("MiniWorkflowStepFormatMount data:%1", data);

        //retrieve all filesystems
	map<symbol, map<symbol, any> > all_filesystems = FileSystems::GetAllFileSystems(true, true);

	list <string> ProposeMountpoints( symbol used_fs, string current_mp )
	{
	    map <symbol, any> fs_data = all_filesystems[used_fs]: $[];

	   //not much choice for swap partitions :)
	   if( used_fs == `swap )
	   {
		return fs_data[ `mountpoints ]:[];
	   }
	   //otherwise, ask notUsedMountPoint, it will filter out
	   //mountpoint already in use + add current mountpoint
	   else
	   {
		list <string> not_used = notUsedMountpoints( Storage::GetTargetMap(), fs_data[ `mountpoints]:[]);
		return ( list <string> ) union( [current_mp], not_used );
	   }
	}


	boolean do_format = data["format"]:false;
	symbol used_fs = data["used_fs"]:`unknown;
	symbol default_crypt_fs = data["type"]:`unknown == `loop ? `luks : `none;
	boolean crypt_fs = data["enc_type"]:default_crypt_fs != `none;
	string mount = data["mount"]:"";
	boolean do_mount = mount != "";

	/* MiniWorkflowStepPartitionSize data:
		$["create":true,
		  "cyl_size":8225280,
		   "device":"/dev/sda1",
		   "disk_device":"/dev/sda",
		   "new":true,
		   "slots":$[`primary:[1, 65]],
		   "type":`primary]
	*/

	//Supply some reasonable defaults for newly created partitions
	//and mark it for formatting, too
	if (data["new"]:false && !data["formatmount_proposed"]:false)
	{
	    data["formatmount_proposed"] = true;

	    //propose new mountpoint and filesystem
	    string mount_point_proposal = SingleMountPointProposal( );
	    used_fs = Partitions::DefaultFs();

	    //special case for boot partition
	    if (mount_point_proposal == Partitions::BootMount())
		used_fs = Partitions::DefaultBootFs();

	    data["format"] = true;
	    data["fsid"] = Partitions::fsid_native;
	    data["used_fs"] = used_fs;

	    //set globals
	    do_format = true;
	    mount = mount_point_proposal;
	    do_mount = mount != "";

	    if (data["type"]:`unknown == `loop)
		do_mount = true;
	}


	term tmp1 = `Empty();
	if (contains([`primary, `extended, `logical], data["type"]:`none))
	{
	    tmp1 = `VBox(`id(`do_not_format_attachment),
			 FsidComboBox(data, FileSystems::GetAllFileSystems(true, true))
		    );
	}

	list mountpoints = ProposeMountpoints( used_fs, mount );

	term contents = `HVSquash(`VStackFrames(
				      `FrameWithMarginBox(_("Formatting Options"),
					     `RadioButtonGroup(`id(`format),
							       `VBox(
								   `LeftRadioButtonWithAttachment(`id(`do_format), `opt(`notify),
												  _("Format partition"),
												  `VBox(`id(`do_format_attachment),
												      FileSystemsComboBox(data, all_filesystems)
												      )),
								   `VSpacing(0.45),
								   `LeftRadioButtonWithAttachment(`id(`do_not_format), `opt(`notify),
												  _("Do not format partition"),
												  tmp1)
								   )
							)
					  ),
				      `FrameWithMarginBox(_("Mounting Options"),
					     `RadioButtonGroup(`id(`mount),
							       `VBox(
								   `LeftRadioButtonWithAttachment(`id(`do_mount), `opt(`notify),
												  _("Mount partition"),
												  `VBox(
												      `id(`do_mount_attachment),
												      `ComboBox(`id(`mount_point), `opt(`editable, `hstretch, `notify),
														_("Mount Point"), mountpoints),
												      `PushButton(`id(`fstab_options), `opt(`hstretch),
														  // button text
														  _("Fs&tab Options..."))
												      )),
								   `VSpacing(0.45),
								   `LeftRadioButton(`id(`do_not_mount), `opt(`notify),
										    _("Do not mount partition"))
								   )
						 )
					  )
				      )
	    );

	MiniWorkflow::SetContents(Greasemonkey::Transform(contents), MiniWorkflowStepFormatMountHelptext());

	MiniWorkflow::SetLastStep(!crypt_fs);

	UI::ChangeWidget(`id(`format), `Value, do_format ? `do_format : `do_not_format);
	UI::ChangeWidget(`id(`do_format_attachment), `Enabled, do_format);
	UI::ChangeWidget(`id(`crypt_fs), `Value, crypt_fs);
	UI::ChangeWidget(`id(`do_not_format_attachment), `Enabled, !do_format);
	UI::ChangeWidget(`id(`mount), `Value, do_mount ? `do_mount : `do_not_mount);
	UI::ChangeWidget(`id(`do_mount_attachment), `Enabled, do_mount);
	UI::ChangeWidget(`id(`mount_point), `Value, mount);

	symbol widget = nil;

	data = HandlePartWidgetChanges(true, widget, all_filesystems, orig_data, data);

	repeat
	{
	    widget = MiniWorkflow::UserInput();

	    if (widget != `back && widget != `abort)
	    {
		data = HandlePartWidgetChanges(false, widget, all_filesystems, orig_data, data);
	    }

	    switch (widget)
	    {
		//user has chosen different filesystem
		case `fs:
		{
		    used_fs = (symbol) UI::QueryWidget(`id(`fs), `Value);

		    //retrieve info about fs user has selected
		    map used_fs_data = all_filesystems[used_fs]:$[];
		    y2milestone("Selected filesystem details %1", used_fs_data);

		    if (used_fs != data["used_fs"]:`none)
		    {
			//set file system type
			data["used_fs"] = used_fs;
			data = filter(string key, any value, data, { return key != "fs_options"; });

			//set file system ID (and update the File System ID widget
			//that is - FsidComboBox)
			data["fsid"] = used_fs_data[`fsid]: Partitions::fsid_native;
			UI::ChangeWidget( `id(`fsid_point), `Value, used_fs_data[`fsid_item]:"");

			//suggest some nice mountpoints if user wants to mount this partition
			if (do_mount)
			{
			    UI::ChangeWidget(`id(`mount_point), `Items, ProposeMountpoints( used_fs, mount ));
			}
		    }
		    break;
		}

		case `crypt_fs:
		    MiniWorkflow::SetLastStep(UI::QueryWidget(`id(`crypt_fs), `Value) != true);
		    break;

		    /* already done in HandlePartWidgetChanges
		case `fs_options:
		    map fs_options = FileSystems::DefaultFormatOptions(data);
		    if (size(fs_options) > 0 && !haskey(data, "fs_options"))
			data["fs_options"] = FileSystems::DefaultFormatOptions(data);

		    map filesystems = FileSystems::GetAllFileSystems(true, true);
		    data["fs_options"] = FileSystemOptions(data["fs_options"]:$[], filesystems[data["used_fs"]:`unknown]:$[]);
		    break;
		    */

		    /* already done in HandlePartWidgetChanges
		case `fstab_options:
		    string fstopt = FileSystems::DefaultFstabOptions(data);
		    if (size(fstopt) > 0 && !haskey(data, "fstopt"))
			data["fstopt"] = fstopt;

		    data = FstabOptions(data, data);
		    break;
		    */

		case `do_format:
		    // TODO
		    data["used_fs"] = (symbol) UI::QueryWidget(`id(`fs), `Value);

		    UI::ChangeWidget(`id(`do_format_attachment), `Enabled, true);
		    UI::ChangeWidget(`id(`do_not_format_attachment), `Enabled, false);
		    MiniWorkflow::SetLastStep(UI::QueryWidget(`id(`crypt_fs), `Value) != true);
		    break;

		case `do_not_format:
		    UI::ChangeWidget(`id(`do_format_attachment), `Enabled, false);
		    UI::ChangeWidget(`id(`do_not_format_attachment), `Enabled, true);
		    MiniWorkflow::SetLastStep(true);
		    break;

		case `fsid_point:
		    // TODO
		    break;

		case `do_mount:
		    do_mount = true;
		    UI::ChangeWidget(`id(`do_mount_attachment), `Enabled, true);
		    //propose mountpoints
		    //UI::ChangeWidget(`id(`mount_point), `Items, ProposeMountpoints( used_fs, mount ));
		    break;

		case `do_not_mount:
		    do_mount = false;
		    UI::ChangeWidget(`id(`do_mount_attachment), `Enabled, false);
		    break;

		case `next:
		    do_format = (boolean) UI::QueryWidget(`id(`do_format), `Value);
		    crypt_fs = (boolean) UI::QueryWidget(`id(`crypt_fs), `Value);
		    do_mount = (boolean) UI::QueryWidget(`id(`do_mount), `Value);
		    mount = (string) UI::QueryWidget(`id(`mount_point), `Value);

		    // TODO: checks

		    if (data["type"]:`unknown == `loop)
		    {
			if (!crypt_fs)
			{
			    // error popup
			    Popup::Error(_("Crypt files must be encrypted."));
			    widget = `again;
			    continue;
			}

			if (data["create_file"]:false && !do_format)
			{
			    // error popup
			    Popup::Error(_("You chose to create the crypt file, but did not specify
that it should be formatted. This does not make sense.

Also check the format option.
"));
			    widget = `again;
			    continue;
			}

			if (!do_mount || mount == "")
			{
			    // error popup
			    Popup::Error(_("Crypt files require a mount point."));
			    widget = `again;
			    continue;
			}
		    }

		    if (do_mount)
		    {
			map ret_mp = CheckOkMount(data["device"]:"error", orig_data, data);
			if (!ret_mp["ok"]:false)
			{
			    if (ret_mp["field"]:`none != `none)
				UI::SetFocus(`id(ret_mp["field"]:`none));
			    widget = `again;
			    continue;
			}
		    }

		    if (do_format)
		    {
			if (!check_ok_fssize(data["size_k"]:0, data))
			{
			    widget = `again;
			    continue;
			}
		    }

		    break;
	    }
	}
	until (widget == `abort || widget == `back || widget == `next);

	if (widget == `next)
	{
	    if (crypt_fs)
		data["enc_type"] = data["format"]:false ? `luks : `twofish;
	    else
		data["enc_type"] = `none;

	    data["format"] = do_format;
	    data["mount"] = do_mount ? mount : "";

	    if (!data["format"]:false)
		data = filter(string key, any value, data, { return key != "fs_options"; });

	    if (contains([`primary, `extended, `logical], data["type"]:`unknown))
		if (data["fsid"]:0 != orig_data["fsid"]:0)
		    data["change_fsid"] = true;

	    if (!do_format || !crypt_fs)
		widget = `finish;

	    orig_data = data;
	}

	y2milestone("MiniWorkflowStepFormatMount data:%1 ret:%2", data, widget);

	return widget;
    }


    string MiniWorkflowStepPasswordHelptext(map<string, any> data)
    {
	integer min_pw_len = data["format"]:false ? 8 : 1;
	boolean empty_pw_allowed = EmptyCryptPwdAllowed(data);

	// helptext
	string helptext = _("<p>
Keep in mind that this file system is only protected when it is not
mounted. Once it is mounted, it is as secure as every other
Linux file system.
</p>");

	if (empty_pw_allowed)
	    // helptext
	    helptext = helptext + _("<p>
This mount point corresponds to a temporary filesystem like /tmp or /var/tmp.
You may leave the crypt password empty. If you do this, the system will create
a random password at system startup for you. This means, you will lose all
data on these filesystems at system shutdown.
</p>
");

        // helptext
        helptext = helptext + _("<p>
If you forget your password, you will lose access to the data on your file system.
Choose your password carefully. A combination of letters and numbers
is recommended. To ensure the password was entered correctly,
enter it twice.
</p>
");

        // helptext, %1 is replaced by integer
        helptext = helptext + sformat(_("<p>
You must distinguish between uppercase and lowercase. A password should have at
least %1 characters and, as a rule, not contain any special characters
(e.g., letters with accents or umlauts).
</p>
"), min_pw_len);

	// helptext
	helptext = helptext + _("<p>
Do not forget this password!
</p>");

	return helptext;
    }


    symbol MiniWorkflowStepPassword(map<string, any> &data)
    {
	y2milestone("MiniWorkflowStepPassword data:%1", data);

	integer min_pw_len = data["format"]:false ? 8 : 1;
	boolean empty_pw_allowed = EmptyCryptPwdAllowed(data);

	string label = _("Don't forget what you enter here!");
	if (empty_pw_allowed)
	    label = label + "\n" + _("Empty password allowed.");

	term contents = `HVSquash(`FrameWithMarginBox(_("Password"),
					 `VBox(
					     `Password(`id(`pw1),
						       // Label: get password for user root
						       // Please use newline if label is longer than 40 characters
						       _("&Enter a password for your file system:"), ""),
					     `Password(`id(`pw2),
						       // Label: get same password again for verification
						       // Please use newline if label is longer than 40 characters
						       _("Reenter the password for &verification:"), ""),
					     `VSpacing(0.5),
					     `Left(`Label(label))
					     )
				      )
	    );

	MiniWorkflow::SetContents(Greasemonkey::Transform(contents), MiniWorkflowStepPasswordHelptext(data));
	MiniWorkflow::SetLastStep(true);

	string pw1 = "";
	string pw2 = "";

	symbol widget = nil;

	repeat
	{
	    UI::ChangeWidget(`id(`pw1), `Value, "");
	    UI::ChangeWidget(`id(`pw2), `Value, "");

	    widget = MiniWorkflow::UserInput();

	    if (widget == `next)
	    {
		pw1 = (string) UI::QueryWidget(`id(`pw1), `Value);
		pw2 = (string) UI::QueryWidget(`id(`pw2), `Value);

		if ( pw1 != pw2 )
		{
		    // popup text
		    Popup::Message(_("The first and the second version\nof the password do not match!\nPlease try again."));
		    widget = `again;
		}
		else if (pw1 == "" && !empty_pw_allowed)
		{
		    // popup text
		    Popup::Message(_("You did not enter a password.
Try again.
"));
		    widget = `again;
		}
		else if (size(pw1) < min_pw_len && !empty_pw_allowed)
		{
		    // popup text
		    Popup::Message(sformat(_("The password must have at least %1 characters.
Try again.
"), min_pw_len));
		    widget = `again;
		}
		else if (size(pw1) >= min_pw_len || empty_pw_allowed)
		{
		    any ret2 = findfirstnotof( pw1, "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ#* ,.;:._-+!$%&/|\?{[()]}@^\\<>" );
		    if ( ret2 != nil && size(pw1)>0 )
		    {
			// popup text
			Popup::Message(_("The password may only contain the following characters:
0..9, a..z, A..Z, and any of \"@#* ,.;:._-+!$%&/|\?{[()]}^\\<>\".
Try again."));
			widget = `again;
		    }
		}
	    }
	}
	until (widget == `abort || widget == `back || widget == `next);

	if (widget == `next)
	{
	    if (data["type"]:`unknown != `loop)
		Storage::UpdateClassified(data["device"]:"", pw1);
	    else
		Storage::UpdateClassified(data["fpath"]:"", pw1);
	    widget = `finish;
	}

	y2milestone("MiniWorkflowStepPassword data:%1 ret:%2", data, widget);

	return widget;
    }


    boolean DlgResize(map <string, any> &data, map <string, any> disk)
    {
	map<string, map> target_map = Storage::GetTargetMap();

	integer cyl_size = disk["cyl_size"]:1;
	integer free_cyl_after = Storage::FreeCylAfter(disk, data);

	string device = data["device"]:"error";
	symbol used_fs = data["used_fs"]:`none;


	integer used_k = FileSystems::MinFsSizeK(used_fs);
	if (!data["create"]:false)
	{
	    if (used_fs != `swap)
	    {
		map free_data = Storage::GetFreeSpace(device, 0, used_fs, true);
		used_k = Integer::Max([ used_k, free_data["used"]:0 / 1024 ]);
	    }
	}

	integer min_free_k = 10*1024;

	integer size_k = data["size_k"]:0;

	// minimal and maximal size for volume
	integer min_size_k = Integer::Min([ used_k + min_free_k, size_k ]);
	integer max_size_k = 0;


	string unit = _("MB");
	integer factor = 1024;

	//Depending on size of the partition,
	//set correct division factor and units
	//and minimum required free space, too
	// TODO: get rid of this unit factor and unit altogether
	void AdjustUnits()
	{
	    if (max_size_k > 20*1024*1024)
	    {
		factor = factor * 1024;
		unit = _("GB");
            }
	}


	string heading = "";


	list <string> BarGraphLabels(list<integer> values_k)
        {
	    string used = "";
	    string free = "";
	    string available = "";

	    switch (data["type"]:`unknown)
	    {
		case `primary:
		case `logical:
		    // Labels for bar graph. "%1" will be replace with a size value.
		    used = sformat(_("Used\nSpace\n%1 "), Storage::KByteToHumanString(values_k[0]:0));
		    if (used_fs == `swap)
			// Labels for bar graph. "%1" will be replace with a size value.
			free = sformat(_("Swap\nSpace\n%1 "), Storage::KByteToHumanString(values_k[1]:0));
		    else
			// Labels for bar graph. "%1" will be replace with a size value.
			free = sformat(_("Free\nSpace\n%1 "), Storage::KByteToHumanString(values_k[1]:0));
		    // Labels for bar graph. "%1" will be replace with a size value.
		    available = sformat(_("Unused\nDisk\n%1 "), Storage::KByteToHumanString(values_k[2]:0));
		    break;

		case `lvm:
		    // Labels for bar graph. "%1" will be replace with a size value.
		    used = sformat(_("LV\nUsed\n%1"), Storage::KByteToHumanString(values_k[0]:0));
		    // Labels for bar graph. "%1" will be replace with a size value.
		    free = sformat(_("LV\nFree\n%1"), Storage::KByteToHumanString(values_k[1]:0));
		    // Labels for bar graph. "%1" will be replace with a size value.
		    available = sformat(_("VG\nFree\n%1"), Storage::KByteToHumanString(values_k[2]:0));
		    break;
	    }

	    return [ used, free, available ];
	}


	string FreeSpaceLabel()
	{
	    if (used_fs == `swap)
		return _("Swap Space");
	    else
		return _("Remaining Free Space");
	}


	switch (data["type"]:`unknown)
	{
	    case `primary:
	    case `logical:
	    {
		// Heading for dialog
		heading = sformat(_("Resize Partition %1"), device);

		/*
		    if (size( size_data ) == 0 || !size_data["ok"]:false)
		    {
			y2error("Failed to retrieve FreeSpace %1, filesystem %2", device, data["used_fs"]:`none);
			//FIXME: Really?
			Popup::Error( sformat( _("Partition %1 cannot be resized\nbecause the filesystem seems to be inconsistent"), device ));
			return false;
		    }
		}
		*/

		min_size_k = Integer::Max([ min_size_k, cyl_size / 1024 ]);
		max_size_k = (cyl_size * free_cyl_after) / 1024;
	    }
	    break;

	    case `lvm:
	    {
		// Heading for dialog
		heading = sformat(_("Resize Logical Volume %1"), device);

		min_size_k = Integer::Max([ min_size_k, disk["pesize"]:0 / 1024 ]);
		max_size_k = size_k + (disk["pe_free"]:0 * disk["pesize"]:0) / 1024;
	    }
	    break;
	}

	y2milestone("used_k:%1 size_k:%2", used_k, size_k);
	y2milestone("min_size_k:%1 max_size_k:%2", min_size_k, max_size_k);


	AdjustUnits();

	integer slider_size_k = size_k / factor;
	integer slider_min_size_k = min_size_k / factor;
	integer slider_max_size_k = max_size_k / factor;


	term content = `Empty();

	if (UI::HasSpecialWidget(`BarGraph) && UI::HasSpecialWidget(`Slider))
	{
	    content = `VBox(
		`BarGraph(`id(`graph), `opt(`vstretch), [ slider_min_size_k, slider_size_k - slider_min_size_k,
							  slider_max_size_k - slider_size_k ],
			  BarGraphLabels([ min_size_k, size_k - min_size_k, max_size_k - size_k ])),
		`Slider(`id(`new_size), `opt(`notify), sformat(_("New Partition Size (in %1)"), unit),
			slider_min_size_k, slider_max_size_k, slider_size_k)
	    );
	}
	else
	{
	    // TODO: something nicer for ncurses, this layout sucks - #410956
	    content = `Frame("",
			     `IntField(`id(`new_size), `opt(`notify), sformat(_("New Partition Size (in %1)"), unit),
				       slider_min_size_k, slider_max_size_k, slider_size_k)
	    );
	}

        UI::OpenDialog(
	    `VBox(
	        `Left(`Heading(heading)),
	        `HSpacing(60),
		 content,
	        `Left(`Label(`id(`free), sformat("%1: %2      ", FreeSpaceLabel(), Storage::KByteToHumanString(size_k - used_k)))),
		`VSpacing(1.0),
	        `Left(`Label(sformat(_("Minimum Partition Size: %1 %2"), Storage::KByteToHumanString(min_size_k), ""))),
	        `Left(`Label(sformat(_("Maximum Partition Size: %1 %2"), Storage::KByteToHumanString(max_size_k), ""))),
	        `HBox(
		   `ButtonBox(
		       `PushButton(`id(`help), `opt(`helpButton), Label::HelpButton()),
		       `PushButton(`id(`cancel), `opt(`cancelButton), Label::CancelButton()),
		       `PushButton(`id(`ok), `opt(`default, `okButton), Label::OKButton())
		   )
		)
	    )
	);

	// help text
	string help_text = _("<p>Choose the new size by draging the slider or by entering a
numeric value in either input field.</p>");

	UI::ChangeWidget(`help, `HelpText, help_text);


	symbol widget = nil;

	integer old_size_k = size_k;

	do {

	    widget = (symbol) UI::UserInput();

	    switch (widget)
	    {
	        case `new_size:
	        {
		    slider_size_k = (integer) UI::QueryWidget(`id(`new_size), `Value);
		    size_k = Integer::Clamp(slider_size_k * factor, min_size_k, max_size_k);

		    UI::ChangeWidget(`id(`graph), `Values, [ slider_min_size_k, slider_size_k - slider_min_size_k,
							     slider_max_size_k - slider_size_k ]);

		    UI::ChangeWidget(`id(`graph), `Labels, BarGraphLabels([ min_size_k, size_k - min_size_k, max_size_k - size_k ]));

		    UI::ChangeWidget(`id(`free), `Value, sformat("%1: %2", FreeSpaceLabel(),
								 Storage::KByteToHumanString(size_k - used_k)));

		    break;
	        }

	        case `ok:
	        {
		    if (size_k != old_size_k)
		    {
			string mountpoint = data["inactive"]:false ? "" : data["mount"]:"";

			//1 - ask & be interactive, 2 - we are on lvm, 3 - cyl.diff, 4 - filesystem, 5 - mountpoint
			if (!CheckResizePossible(false, false, size_k - old_size_k, used_fs, mountpoint))
			{
			    //FIXME: To check whether the part. can be resized only
			    //after user tries to do that is stupid - in some cases
			    //we can tell beforehand, thus user should never get to this
			    //point (e.g. when the partition is mounted)
			    y2error("Resizing the partition is not possible");
			    widget = `again;
			    continue;
			}

			switch (data["type"]:`unknown)
			{
			    case `primary:
			    case `logical:
				data["region", 1] = Integer::Clamp(PartedSizeToCly((tofloat(size_k*1024)), cyl_size),
								   1, data["region", 1]:0 + free_cyl_after);
				data["resize"] = true;
				break;

			    case `lvm:
				data["size_k"] = size_k;
				break;
			}
		    }
		    break;
	        }

		case `cancel:
		    break;
	    }

	} while (widget != `cancel && widget != `ok);

	UI::CloseDialog();

	return widget == `ok;
    }


    void DisplayCommandOutput(string command)
    {
	// TODO: maybe use LogView.ycp, but here we want to wait until the command has finished
	// TODO: better error handling

	UI::OpenDialog(`VBox(
			   // label for log view
			   `MinWidth(60, `LogView(`id(`log), "Out&put of " + command, 15, 0)),
			   `PushButton(`opt(`default), Label::CloseButton())
			   ));

	map tmp = (map) SCR::Execute(.target.bash_output, command);

	string lines = tmp["stderr"]:"" != "" ? tmp["stderr"]:"" : tmp["stdout"]:"";
	UI::ChangeWidget(`id(`log), `Value, lines);

	UI::UserInput();
	UI::CloseDialog();
    }


    void RescanDisks()
    {
	UI::OpenDialog(`opt(`decorated),
		       // popup text
		       `MarginBox(2, 1, `Label(_("Rescanning disks..."))));

	Storage::ReReadTargetMap();

	UI::CloseDialog();
    }
}
