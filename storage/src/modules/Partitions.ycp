/**
 * Module: 		Partitions.ycp
 *
 * Authors:		Thomas Fehr (fehr@suse.de)
 *
 * Purpose: 		Provides information about partitions
 *
 * $Id$
 */
{
    module "Partitions";

    textdomain "storage";

    import "Arch";
    import "Mode";
    import "AsciiFile";

    // The filesystem ids for the partitions
    global integer fsid_empty    = 0;
    global integer fsid_native   = 131;
    global integer fsid_swap     = 130;
    global integer fsid_lvm      = 142;
    global integer fsid_raid     = 253;
    global integer fsid_hibernation = 160;
    global integer fsid_extended = 5;
    global integer fsid_extended_win = 15;
    global integer fsid_fat16    = 6;
    global integer fsid_prep_chrp_boot = 0x41;
    global integer fsid_root = fsid_native;
    global integer fsid_boot = fsid_native;

    global boolean no_fsid_menu = false;

    // filesystems for /win
    global list fsid_wintypes = [ 6, 11, 12, 14 ]; /* FAT32, Win95-Fat32, Win95LBA, Win95-Fat16  */

    // filesystems for /dos
    global list fsid_dostypes = [ 1, 4 ];          /* FAT12, FAT16  */

    // filesystems for /windows
    global list fsid_ntfstypes = [ 7 ];            /* NTFS  */

    // filesystems mounted read-only
    global list fsid_readonly = [ 7 ];

    // filesystems skipped on sparc and axp
    global list fsid_skipped = [ 0, 5 ];

    global integer minimal_needed_disksize = 400 * 1024 * 1024;  // for installation of a minimal system
    global integer minimal_needed_bootsize = 12  * 1024 * 1024;  // for installation

    global symbol default_fs      = `reiser;
    global symbol default_boot_fs = `ext2;

    global define Partitions()
    ``{
	import "Boot";
	if (Arch::ia64 || Boot::LoaderType == "milo")
	{
	    fsid_boot = fsid_fat16;
	    default_boot_fs = `fat16;
	}
    }

    global define boolean IsDosPartition( integer fsid )
    ``{
	return (contains( fsid_dostypes, fsid)
		|| contains( fsid_wintypes, fsid));
    }

    global define boolean IsDosWinNtPartition( integer fsid )
    ``{
    return( IsDosPartition( fsid ) || 
            contains( fsid_ntfstypes, fsid ));
    }

    global define boolean UseParted()
    ``{
    boolean ret = true;
    if( Arch::i386 || Arch::x86_64 )
	ret = false;
    y2milestone( "UseParted ret:%1", ret );
    return( ret );
    }

    global define boolean PartitionIdParted( integer fsid )
    ``{
    boolean ret = true;
    ret = contains( [ fsid_lvm, fsid_raid, fsid_swap, fsid_native, fsid_fat16 ],
                    fsid );
    y2milestone( "PartitionIdParted id:%1 ret:%2", fsid, ret );
    return( ret );
    }

    global define boolean IsResizable( integer fsid )
    ``{
    boolean ret = false;
    ret = IsDosPartition(fsid) || fsid == fsid_swap || fsid == fsid_native;
    y2milestone( "IsResizable fsid:%1 ret:%2", fsid, ret );
    return( ret );
    }

    global define boolean IsLinuxPartition( integer fsid )
    ``{
	return ( fsid==fsid_native || fsid==fsid_swap || fsid==fsid_lvm ||
	         fsid==fsid_raid );
    };

  //////////////////////////////////////////////////////////////////////////
  // mount partition and look how much free space is available
  // size: size of partition
  //////////////////////////////////////////////////////////////////////////

  global define map GetFreeSpace( string device, integer testsize )
  ``{
      integer used = 0;
      integer free = 0;

      if ( Mode::test )
      {
	  integer wf =  tointeger(tofloat(testsize) * 0.6);
	  integer wu =  tointeger(tofloat(testsize) * 0.4);
	  integer ls =  tointeger(tofloat(testsize) * 0.5);
	  return( $[ "free"  : wf,
		   "used"    : wu,
		   "linux_size"  : ls,
		   "new_size": (wu + wf - ls) ] );
      }

      // mount the partition to execute some checks
      //
      boolean mount_ret = SCR::Execute(.target.mount, [device, "/mnt", Installation::mountlog]);

      if ( !mount_ret)
      {
	  y2error( "Current device <%1> could not be mounted. Canceled", device );
	  return( nil );	// abort installation
      }
      else y2milestone( "Current device <%1> mounted on /mnt.", device );

      // get usage information for the partition via df
      //
      list df_result = SCR::Read(.run.df);

      SCR::Execute(.target.umount, device);

      y2debug( ".run.df: %1", df_result );

      // filter out headline and other invalid entries
      df_result = filter( `part, df_result, ``( substring ( lookup( part, "spec", "" ), 0, 1 ) == "/" ) );

      boolean ok = false;

      foreach( `part, df_result,
      ``{
	  if ( lookup( part, "spec", "" ) == device )	// find right entry
	  {
	      // get the usage values
	      //
	      used = tointeger( lookup( part, "used", "-1" ));
	      free = tointeger( lookup( part, "free", "-1" ));

	      if ( used != -1 && free != -1 )
	      {
		  used = used * 1024;	// Byte
		  free = free * 1024;	// Byte

		  ok = true;
		  y2milestone( ".run.df: used: <%1> free:<%2>", used, free );
	      }
	  }
      });

      integer linux_size = 0;
      integer min_linux_size = 0;

      if( free > 300000000  && free < 600000000 )
      {
	  linux_size = free - 75000000;
	  min_linux_size = linux_size;
      }
      else if ( free < 1000000000 )
      {
	  linux_size = free - 200000000;
	  min_linux_size = 300000000;
      }
      else if ( free < 2000000000 )
      {
	  linux_size = free - 300000000;
	  min_linux_size = 500000000;
      }
      else if ( free < 3000000000 )
      {
	  linux_size = free - 800000000;
	  min_linux_size = 500000000;
      }
      else
      {
	  linux_size = free - ( free / 3 );
	  min_linux_size = 500000000;
      }

      integer new_size = used + free - linux_size;

      if (ok)
      {
	  return( $[ "free":free,
		   "used":used,
		   "linux_size":linux_size,
		   "max_win_size":used + free - min_linux_size,
		   "new_size":new_size ] );
      }
      else
      {
	  return( nil );
      }
  };


global define list mountedPartitionsOnDisk( string dev_str, list mounts_read )
    ``{

    list mounts = filter(`mount, mounts_read,
                         ``( issubstring(mount["spec"]:"", dev_str )));

    if( Mode::test )
        SCR::Write(.dumpto.tmp.mounts1, mounts );

    // reset
    if( mounts == nil ) mounts = [];

    return mounts;
    }

global define string MountedOn( string partition_str, list mounts_read )
    ``{

    list mounts = filter( `mount, mounts_read,
                          ``( mount["spec"]:""==partition_str) );

    if( Mode::test )
        SCR::Write(.dumpto.tmp.mount_part, mounts );

    if( size( mounts) > 0 )
        return lookup( select( mounts , 0, $[]), "file", "");
    return "";
    };

/**
 *	Return a list with all mounted partition
 *  @return list
 */
global define list CurMounted() 
    ``{
    list mounts = SCR::Read(.proc.mounts);
    list swaps  = SCR::Read(.proc.swaps );
    list mtab   = SCR::Read(.etc.mtab );

    foreach( `swap, swaps, 
	``{
	map swap_entry = $[
			   "file" : "swap",
			   "spec" :  swap["file"]:""
	    ];

	mounts = add( mounts, swap_entry );

	});

    map mtab_root = find( `mount, mtab, ``( mount["file"]:"" == "/" ));
    map root_map  = find( `mount, mounts, ``( mount["spec"]:"" == "/dev/root"));
    root_map["spec"] = mtab_root["spec"]:"";
    mounts = filter( `mount, mounts, ``( mount["spec"]:"" != "/dev/root"));
    mounts = add( mounts, root_map );
    list ret = [];
    foreach( `p, mounts, ``{ 
	if( find( p["spec"]:"", "/dev/loop" )>=0 )
	    {
	    string cmd = sformat( "/sbin/losetup %1", p["spec"]:"" );
	    map bash_call = SCR::Execute (.target.bash_output, cmd, $[] );
	    if( bash_call["exit"]:1 == 0)
		{
		string text = bash_call["stdout"]:"";
		if( find( text, ")" )>0 )
		    {
		    text = substring( text, 0, find( text, ")" ) );
		    if( find( text, "(" )>0 )
			{
			text = substring( text, find( text, "(" )+1 );
			p["loop_on"] = text;
			}
		    }
		}
	    }
	ret = add( ret, p );
	});

    y2debug( "all mounts %1", ret);
    return ret;
    };

global define map GetFstab( string pathname )
    ``{
    map file = $[];
    AsciiFile::SetComment( file, "^[ \t]*#" );
    AsciiFile::SetDelimiter( file, " \t" );
    AsciiFile::SetListWidth( file, [ 20, 20, 10, 21, 1, 1 ] );
    AsciiFile::ReadFile( file, pathname );
    return( file );
    };

global define map GetCrypto( string pathname )
    ``{
    map file = $[];
    AsciiFile::SetComment( file, "^[ \t]*#" );
    AsciiFile::SetDelimiter( file, " \t" );
    AsciiFile::SetListWidth( file, [ 11, 15, 20, 10, 10, 1 ] );
    AsciiFile::ReadFile( file, pathname );
    return( file );
    };

global define string ToHexString( integer num ) 
    ``{
    string to_hex = "0123456789ABCDEF";
    string ret = sformat("0x%1%2", substring( to_hex, num/16, 1 ),
                         substring( to_hex, num%16, 1 ) );
    return( ret );
    }

global define string FsIdToString( integer fs_id ) 
    ``{
    if ( fs_id == 0xa7) return( "NeXTSTEP");
    if ( fs_id == 0xb7) return( "BSDI fs");
    if ( fs_id == 0xb8) return( "BSDI swap");
    if ( fs_id == 0xc1) return( "DRDOS/sec");
    if ( fs_id == 0xc4) return( "DRDOS/sec");
    if ( fs_id == 0xc6) return( "DRDOS/sec");
    if ( fs_id == 0xc7) return( "Syrinx");
    if ( fs_id == 0xda) return( "Non-Fs data");
    if ( fs_id == 0xdb) return( "CP/M / CTOS");
    if ( fs_id == 0xde) return( "Dell Utility");
    if ( fs_id == 0xe1) return( "DOS access");
    if ( fs_id == 0xe3) return( "DOS R/O");
    if ( fs_id == 0xe4) return( "SpeedStor");
    if ( fs_id == 0xeb) return( "BeOS fs");
    if ( fs_id == 0xee) return( "EFI GPT");
    if ( fs_id == 0xef) return( "EFI (FAT-12/16)");
    if ( fs_id == 0xf1) return( "SpeedStor");
    if ( fs_id == 0xf4) return( "SpeedStor");
    if ( fs_id == 0xf2) return( "DOS secondary ");
    if ( fs_id == 0xfd) return( "Linux RAID");
    if ( fs_id == 0xfe) return( "LANstep");
    if ( fs_id == 0xff) return( "BBT");
    if ( fs_id == 0x0)  return( "empty");
    if ( fs_id == 0x1)  return( "FAT12");
    if ( fs_id == 0x2)  return( "XENIX root");
    if ( fs_id == 0x3)  return( "XENIX usr");
    if ( fs_id == 0x4)  return( "FAT16 <32M");
    if ( fs_id == 0x5)  return( "Extended");
    if ( fs_id == 0x6)  return( "FAT16");
    if ( fs_id == 0x7)  return( "HPFS/NTFS");
    if ( fs_id == 0x8)  return( "AIX");
    if ( fs_id == 0x9)  return( "AIX boot");
    if ( fs_id == 0xa)  return( "OS/2 boot manager");
    if ( fs_id == 0xb)  return( "Win95 FAT32");
    if ( fs_id == 0xc)  return( "Win95 FAT32");
    if ( fs_id == 0xe)  return( "Win95 FAT16");
    if ( fs_id == 0xf)  return( "Win95 Erw. LBA");
    if ( fs_id == 0x10) return( "OPUS");
    if ( fs_id == 0x11) return( "Hidden FAT12");
    if ( fs_id == 0x12) return( "Compaq diag");
    if ( fs_id == 0x14) return( "Hidden FAT16");
    if ( fs_id == 0x16) return( "Hidden FAT16");
    if ( fs_id == 0x17) return( "Hidden HPFS/NTFS");
    if ( fs_id == 0x18) return( "AST Windows");
    if ( fs_id == 0x1b) return( "Hidden Win95");
    if ( fs_id == 0x1c) return( "Hidden Win95");
    if ( fs_id == 0x1e) return( "Hidden Win95");
    if ( fs_id == 0x24) return( "NEC DOS");
    if ( fs_id == 0x39) return( "Plan 9");
    if ( fs_id == 0x3c) return( "PartitionMagic");
    if ( fs_id == 0x40) return( "Venix 80286");
    if ( fs_id == 0x41) return( "PPC PReP Boot");
    if ( fs_id == 0x42) return( "SFS");
    if ( fs_id == 0x4d) return( "QNX4.x");
    if ( fs_id == 0x4e) return( "QNX4.x 2nd par");
    if ( fs_id == 0x4f) return( "QNX4.x 3rd par");
    if ( fs_id == 0x50) return( "OnTrack DM");
    if ( fs_id == 0x51) return( "OnTrack DM6");
    if ( fs_id == 0x52) return( "CP/M");
    if ( fs_id == 0x53) return( "OnTrack DM6");
    if ( fs_id == 0x54) return( "OnTrack DM6");
    if ( fs_id == 0x55) return( "EZ-Drive");
    if ( fs_id == 0x56) return( "Golden Bow");
    if ( fs_id == 0x5c) return( "Priam Edisk");
    if ( fs_id == 0x61) return( "SpeedStor");
    if ( fs_id == 0x63) return( "GNU HURD");
    if ( fs_id == 0x64) return( "Novell Netware");
    if ( fs_id == 0x65) return( "Novell Netware");
    if ( fs_id == 0x70) return( "DiskSecure");
    if ( fs_id == 0x75) return( "PC/IX");
    if ( fs_id == 0x80) return( "Old Minix");
    if ( fs_id == 0x81) return( "Minix");
    if ( fs_id == 0x82) return( "Linux swap");
    if ( fs_id == 0x83) return( "Linux native");
    if ( fs_id == 0x84) return( "OS/2 hidden");
    if ( fs_id == 0x85) return( "Linux extended");
    if ( fs_id == 0x86) return( "NTFS volume");
    if ( fs_id == 0x87) return( "NTFS volume");
    if ( fs_id == 0x8e) return( "Linux LVM");
    if ( fs_id == 0x93) return( "Amoeba");
    if ( fs_id == 0x94) return( "Amoeba BBT");
    if ( fs_id == 0x9f) return( "BSD/OS");
    if ( fs_id == 0xa0) return( "Hibernation");
    if ( fs_id == 0xa5) return( "BSD/386");
    return( "unknown" );
    };

}
