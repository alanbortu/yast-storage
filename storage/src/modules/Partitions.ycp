/**
 * Module: 		Partitions.ycp
 *
 * Authors:		Thomas Fehr (fehr@suse.de)
 *
 * Purpose: 		Provides information about partitions
 *
 * $Id$
 */
{
    module "Partitions";

    import "Arch";

    // The filesystem ids for the partitions
    global integer fsid_empty    = 0;
    global integer fsid_native   = 131;
    global integer fsid_swap     = 130;
    global integer fsid_lvm      = 142;
    global integer fsid_raid     = 253;
    global integer fsid_hibernation = 160;
    global integer fsid_extended = 5;
    global integer fsid_extended_win = 15;
    global integer fsid_fat16    = 6;
    global integer fsid_prep_chrp_boot = 0x41;
    global integer fsid_root = fsid_native;
    global integer fsid_boot = fsid_native;

    // filesystems for /win
    global list fsid_wintypes = [ 6, 11, 12, 14 ]; /* FAT32, Win95-Fat32, Win95LBA, Win95-Fat16  */

    // filesystems for /dos
    global list fsid_dostypes = [ 1, 4 ];          /* FAT12, FAT16  */

    // filesystems for /windows
    global list fsid_ntfstypes = [ 7 ];            /* NTFS  */

    // filesystems mounted read-only
    global list fsid_readonly = [ 7 ];

    // filesystems skipped on sparc and axp
    global list fsid_skipped = [ 0, 5 ];

    global integer minimal_needed_disksize = 400 * 1024 * 1024;  // for installation of a minimal system
    global integer minimal_needed_bootsize = 12  * 1024 * 1024;  // for installation

    global symbol default_fs      = `reiser;
    global symbol default_boot_fs = `ext2;

    global define Partitions()
    ``{
	import "Boot";
	if (Arch::ia64
	    || Boot::LoaderType == "milo")
	{
	    fsid_boot = fsid_fat16;
	    default_boot_fs = `fat16;
	}
    }

    global define boolean IsDosPartition( integer fsid )
    ``{
	return (contains( fsid_dostypes, fsid)
		|| contains( fsid_wintypes, fsid));
    }

    global define boolean IsDosWinNtPartition( integer fsid )
    ``{
    return( IsDosPartition( fsid ) || 
            contains( fsid_ntfstypes, fsid ));
    }

    global define boolean UseParted()
    ``{
    boolean ret = true;
    if( Arch::i386 )
	ret = false;
    y2milestone( "UseParted ret:%1", ret );
    ret = true;
    return( ret );
    }

    global define boolean PartitionIdParted( integer fsid )
    ``{
    boolean ret = true;
    ret = contains( [ fsid_lvm, fsid_raid, fsid_swap, fsid_native, fsid_fat16 ],
                    fsid );
    y2milestone( "PartitionIdParted id:%1 ret:%2", fsid, ret );
    return( ret );
    }

    global define boolean IsResizable( integer fsid )
    ``{
    boolean ret = false;
    ret = IsDosPartition(fsid) || fsid == fsid_swap || fsid == fsid_native;
    y2milestone( "IsResizable fsid:%1 ret:%2", fsid, ret );
    return( ret );
    }

    global define boolean IsLinuxPartition( integer fsid )
    ``{
	return ( fsid==fsid_native || fsid==fsid_swap || fsid==fsid_lvm ||
	         fsid==fsid_raid );
    };

  //////////////////////////////////////////////////////////////////////////
  // mount partition and look how much free space is available
  // size: size of partition
  //////////////////////////////////////////////////////////////////////////

  global define map GetFreeSpace( string device, integer testsize )
  ``{
      integer used = 0;
      integer free = 0;

      if ( Mode::test )
      {
	  integer wf =  tointeger(tofloat(testsize) * 0.6);
	  integer wu =  tointeger(tofloat(testsize) * 0.4);
	  integer ls =  tointeger(tofloat(testsize) * 0.5);
	  return( $[ "free"  : wf,
		   "used"    : wu,
		   "linux_size"  : ls,
		   "new_size": (wu + wf - ls) ] );
      }

      // mount the partition to execute some checks
      //
      boolean mount_ret = SCR::Execute(.target.mount, [device, "/mnt", Installation::mountlog]);

      if ( !mount_ret)
      {
	  y2error( "Current device <%1> could not be mounted. Canceled", device );
	  return( nil );	// abort installation
      }
      else y2milestone( "Current device <%1> mounted on /mnt.", device );

      // get usage information for the partition via df
      //
      list df_result = SCR::Read(.run.df);

      SCR::Execute(.target.umount, device);

      y2debug( ".run.df: %1", df_result );

      // filter out headline and other invalid entries
      df_result = filter( `part, df_result, ``( substring ( lookup( part, "spec", "" ), 0, 1 ) == "/" ) );

      boolean ok = false;

      foreach( `part, df_result,
      ``{
	  if ( lookup( part, "spec", "" ) == device )	// find right entry
	  {
	      // get the usage values
	      //
	      used = tointeger( lookup( part, "used", "-1" ));
	      free = tointeger( lookup( part, "free", "-1" ));

	      if ( used != -1 && free != -1 )
	      {
		  used = used * 1024;	// Byte
		  free = free * 1024;	// Byte

		  ok = true;
		  y2milestone( ".run.df: used: <%1> free:<%2>", used, free );
	      }
	  }
      });

      integer linux_size = 0;
      integer min_linux_size = 0;

      if( free > 300000000  && free < 600000000 )
      {
	  linux_size = free - 75000000;
	  min_linux_size = linux_size;
      }
      else if ( free < 1000000000 )
      {
	  linux_size = free - 200000000;
	  min_linux_size = 300000000;
      }
      else if ( free < 2000000000 )
      {
	  linux_size = free - 300000000;
	  min_linux_size = 500000000;
      }
      else if ( free < 3000000000 )
      {
	  linux_size = free - 800000000;
	  min_linux_size = 500000000;
      }
      else
      {
	  linux_size = free - ( free / 3 );
	  min_linux_size = 500000000;
      }

      integer new_size = used + free - linux_size;

      if (ok)
      {
	  return( $[ "free":free,
		   "used":used,
		   "linux_size":linux_size,
		   "max_win_size":used + free - min_linux_size,
		   "new_size":new_size ] );
      }
      else
      {
	  return( nil );
      }
  };

}
