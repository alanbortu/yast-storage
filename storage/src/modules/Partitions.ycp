/**
 * Module: 		Partitions.ycp
 *
 * Authors:		Thomas Fehr (fehr@suse.de)
 *
 * Purpose: 		Provides information about partitions
 *
 * $Id$
 */
{
    module "Partitions";

    textdomain "storage";

    import "Arch";
    import "Mode";
    import "AsciiFile";

    // The filesystem ids for the partitions
    global integer fsid_empty    = 0;
    global integer fsid_native   = 131;
    global integer fsid_swap     = 130;
    global integer fsid_lvm      = 142;
    global integer fsid_raid     = 253;
    global integer fsid_hibernation = 160;
    global integer fsid_extended = 5;
    global integer fsid_extended_win = 15;
    global integer fsid_fat16    = 6;
    global integer fsid_prep_chrp_boot = 0x41;
    global integer fsid_root = fsid_native;
    global integer fsid_boot = fsid_native;

    global boolean no_fsid_menu = false;

    // filesystems for /win
    global list fsid_wintypes = [ 6, 11, 12, 14 ]; /* FAT32, Win95-Fat32, Win95LBA, Win95-Fat16  */

    // filesystems for /dos
    global list fsid_dostypes = [ 1, 4 ];          /* FAT12, FAT16  */

    // filesystems for /windows
    global list fsid_ntfstypes = [ 7 ];            /* NTFS  */

    // filesystems mounted read-only
    global list fsid_readonly = [ 7 ];

    // filesystems skipped on sparc and axp
    global list fsid_skipped = [ 0, 5 ];

    global integer minimal_needed_disksize = 400 * 1024 * 1024;  // for installation of a minimal system
    global integer minimal_needed_bootsize = 12  * 1024 * 1024;  // for installation

    global symbol default_fs      = `reiser;
    global symbol default_boot_fs = `ext2;

    global define Partitions()
    ``{
	import "Boot";
	if (Arch::ia64 || Boot::LoaderType == "milo")
	{
	    fsid_boot = fsid_fat16;
	    default_boot_fs = `fat16;
	}
    }

    global define boolean IsDosPartition( integer fsid )
    ``{
	return (contains( fsid_dostypes, fsid)
		|| contains( fsid_wintypes, fsid));
    }

    global define boolean IsDosWinNtPartition( integer fsid )
    ``{
    return( IsDosPartition( fsid ) || 
            contains( fsid_ntfstypes, fsid ));
    }

    global define boolean UseParted()
    ``{
    boolean ret = true;
    if( Arch::i386 || Arch::x86_64 )
	ret = false;
    y2milestone( "UseParted ret:%1", ret );
    return( ret );
    }

    global define boolean PartitionIdParted( integer fsid )
    ``{
    boolean ret = true;
    ret = contains( [ fsid_lvm, fsid_raid, fsid_swap, fsid_native, fsid_fat16 ],
                    fsid );
    y2milestone( "PartitionIdParted id:%1 ret:%2", fsid, ret );
    return( ret );
    }

    global define boolean IsResizable( integer fsid )
    ``{
    boolean ret = false;
    ret = IsDosPartition(fsid) || fsid == fsid_swap || fsid == fsid_native;
    y2milestone( "IsResizable fsid:%1 ret:%2", fsid, ret );
    return( ret );
    }

    global define boolean IsLinuxPartition( integer fsid )
    ``{
	return ( fsid==fsid_native || fsid==fsid_swap || fsid==fsid_lvm ||
	         fsid==fsid_raid );
    };

  //////////////////////////////////////////////////////////////////////////
  // mount partition and look how much free space is available
  // size: size of partition
  //////////////////////////////////////////////////////////////////////////

  global define map GetFreeSpace( string device, integer testsize )
  ``{
      integer used = 0;
      integer free = 0;

      if ( Mode::test )
      {
	  integer wf =  tointeger(tofloat(testsize) * 0.6);
	  integer wu =  tointeger(tofloat(testsize) * 0.4);
	  integer ls =  tointeger(tofloat(testsize) * 0.5);
	  return( $[ "free"  : wf,
		   "used"    : wu,
		   "linux_size"  : ls,
		   "new_size": (wu + wf - ls) ] );
      }

      // mount the partition to execute some checks
      //
      boolean mount_ret = SCR::Execute(.target.mount, [device, "/mnt", Installation::mountlog]);

      if ( !mount_ret)
      {
	  y2error( "Current device <%1> could not be mounted. Canceled", device );
	  return( nil );	// abort installation
      }
      else y2milestone( "Current device <%1> mounted on /mnt.", device );

      // get usage information for the partition via df
      //
      list df_result = SCR::Read(.run.df);

      SCR::Execute(.target.umount, device);

      y2debug( ".run.df: %1", df_result );

      // filter out headline and other invalid entries
      df_result = filter( `part, df_result, ``( substring ( lookup( part, "spec", "" ), 0, 1 ) == "/" ) );

      boolean ok = false;

      foreach( `part, df_result,
      ``{
	  if ( lookup( part, "spec", "" ) == device )	// find right entry
	  {
	      // get the usage values
	      //
	      used = tointeger( lookup( part, "used", "-1" ));
	      free = tointeger( lookup( part, "free", "-1" ));

	      if ( used != -1 && free != -1 )
	      {
		  used = used * 1024;	// Byte
		  free = free * 1024;	// Byte

		  ok = true;
		  y2milestone( ".run.df: used: <%1> free:<%2>", used, free );
	      }
	  }
      });

      integer linux_size = 0;
      integer min_linux_size = 0;

      if( free > 300000000  && free < 600000000 )
      {
	  linux_size = free - 75000000;
	  min_linux_size = linux_size;
      }
      else if ( free < 1000000000 )
      {
	  linux_size = free - 200000000;
	  min_linux_size = 300000000;
      }
      else if ( free < 2000000000 )
      {
	  linux_size = free - 300000000;
	  min_linux_size = 500000000;
      }
      else if ( free < 3000000000 )
      {
	  linux_size = free - 800000000;
	  min_linux_size = 500000000;
      }
      else
      {
	  linux_size = free - ( free / 3 );
	  min_linux_size = 500000000;
      }

      integer new_size = used + free - linux_size;

      if (ok)
      {
	  return( $[ "free":free,
		   "used":used,
		   "linux_size":linux_size,
		   "max_win_size":used + free - min_linux_size,
		   "new_size":new_size ] );
      }
      else
      {
	  return( nil );
      }
  };


global define list mountedPartitionsOnDisk( string dev_str, list mounts_read )
    ``{

    list mounts = filter(`mount, mounts_read,
                         ``( issubstring(mount["spec"]:"", dev_str )));

    if( Mode::test )
        SCR::Write(.dumpto.tmp.mounts1, mounts );

    // reset
    if( mounts == nil ) mounts = [];

    return mounts;
    }

global define string MountedOn( string partition_str, list mounts_read )
    ``{

    list mounts = filter( `mount, mounts_read,
                          ``( mount["spec"]:""==partition_str) );

    if( Mode::test )
        SCR::Write(.dumpto.tmp.mount_part, mounts );

    if( size( mounts) > 0 )
        return lookup( select( mounts , 0, $[]), "file", "");
    return "";
    };

/**
 *	Return a list with all mounted partition
 *  @return list
 */
global define list CurMounted() 
    ``{
    list mounts = SCR::Read(.proc.mounts);
    list swaps  = SCR::Read(.proc.swaps );
    list mtab   = SCR::Read(.etc.mtab );

    foreach( `swap, swaps, 
	``{
	map swap_entry = $[
			   "file" : "swap",
			   "spec" :  swap["file"]:""
	    ];

	mounts = add( mounts, swap_entry );

	});

    map mtab_root = find( `mount, mtab, ``( mount["file"]:"" == "/" ));
    map root_map  = find( `mount, mounts, ``( mount["spec"]:"" == "/dev/root"));
    root_map["spec"] = mtab_root["spec"]:"";
    mounts = filter( `mount, mounts, ``( mount["spec"]:"" != "/dev/root"));
    mounts = add( mounts, root_map );
    list ret = [];
    foreach( `p, mounts, ``{ 
	if( find( p["spec"]:"", "/dev/loop" )>=0 )
	    {
	    string cmd = sformat( "/sbin/losetup %1", p["spec"]:"" );
	    map bash_call = SCR::Execute (.target.bash_output, cmd, $[] );
	    if( bash_call["exit"]:1 == 0)
		{
		string text = bash_call["stdout"]:"";
		if( find( text, ")" )>0 )
		    {
		    text = substring( text, 0, find( text, ")" ) );
		    if( find( text, "(" )>0 )
			{
			text = substring( text, find( text, "(" )+1 );
			p["loop_on"] = text;
			}
		    }
		}
	    }
	ret = add( ret, p );
	});

    y2debug( "all mounts %1", ret);
    return ret;
    };

global define map GetFstab( string pathname )
    ``{
    map file = $[];
    AsciiFile::SetComment( file, "^[ \t]*#" );
    AsciiFile::SetDelimiter( file, " \t" );
    AsciiFile::SetListWidth( file, [ 25, 15, 10, 20, 1, 1 ] );
    AsciiFile::ReadFile( file, pathname );
    return( file );
    };

global define map GetCrypto( string pathname )
    ``{
    map file = $[];
    AsciiFile::SetComment( file, "^[ \t]*#" );
    AsciiFile::SetDelimiter( file, " \t" );
    AsciiFile::SetListWidth( file, [ 12, 30, 15, 10, 10, 20 ] );
    AsciiFile::ReadFile( file, pathname );
    return( file );
    };

}
