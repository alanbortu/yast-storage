/**
 * Module: 		Storage.ycp
 *
 * Authors:		Johannes Buchhold (jbuch@suse.de)
 *
 * Purpose: 		These module contains all settings/information which
 * are needed to partitioning the harddisk. Futhermore it contains a interface
 * to * access and modify the partitioning settings.
 *
 * Todo: Translate
 * Diese Modul enthält alle Informationen die für die Partitionierung der
 * Festplatten erforderlich sind. Diese Informationen bestehen aus der
 * Beschreibung, der vor der Partitionierung vorhandenen Platteneinstellungen,
 * und der Art und Weise wie diese verändert werden soll.
 * Alle nötigen Zugriffsfunktionen auf diese Datenstruktur sind ebenfalls in
 * diesem Modul enthalten. Der Zugriff auf die Speicherung der
 * Partitionseinstellungen läuft * also nur über dieses Modul.
 * Der Zufriff und die Rückgabe von Teilen der Partitionsdatenstruktur
 * wurde versucht * "intelligent" zu gestallten und ist im einzelen bei den
 * entspechenden Funktionen * näher erklärt.
 *
 * $Id$
 */
{

  module "Storage";
  textdomain "storage";

  import "Arch";
  import "AsciiFile";
  import "Encoding";
  import "Directory";
  import "FileSystems";
  import "Installation";
  import "Label";
  import "Mode";
  import "Partitions";
  import "Popup";
  import "Misc";
  import "HTML";
  import "StorageDevices";
  import "Stage";
  import "Hotplug";

  import "LibStorage";
  import "LibStorage::StorageInterface";
  import "LibStorage::FsCapabilities";
  import "LibStorage::VolumeInfo";
  import "LibStorage::PartitionInfo";
  import "LibStorage::LvmLvInfo";
  import "LibStorage::EvmsInfo";
  import "LibStorage::MdInfo";
  import "LibStorage::LoopInfo";
  import "LibStorage::DmInfo";
  import "LibStorage::ContainerInfo";
  import "LibStorage::DiskInfo";
  import "LibStorage::LvmVgInfo";
  import "LibStorage::EvmsCoInfo";

map<string,any> conv_ctype = 
    $[ "def_sym" : `CT_UNKNOWN,
       "def_int" : LibStorage::CUNKNOWN(),
       "m" : $[ LibStorage::DISK() : `CT_DISK,
                LibStorage::MD() : `CT_MD,
                LibStorage::LOOP() : `CT_LOOP,
                LibStorage::LVM() : `CT_LVM,
                LibStorage::EVMS() : `CT_EVMS,
                LibStorage::DM() : `CT_DM
	      ]
     ];

map<string,any> conv_usedby = 
    $[ "def_sym" : `UB_NONE,
       "def_int" : LibStorage::UB_NONE(),
       "m" : $[ LibStorage::UB_LVM() : `UB_LVM,
                LibStorage::UB_MD() : `UB_MD,
                LibStorage::UB_EVMS() : `UB_EVMS,
                LibStorage::UB_DM() : `DM
	      ]
     ];

map<string,any> conv_ptype = 
    $[ "def_sym" : `primary,
       "def_int" : LibStorage::PRIMARY(),
       "m" : $[ LibStorage::LOGICAL() : `logical,
                LibStorage::EXTENDED() : `extended
	      ]
     ];

map<string,any> conv_fs = 
    $[ "def_sym" : `unknown,
       "def_int" : LibStorage::FSUNKNOWN(),
       "m" : $[ LibStorage::REISERFS() : `reiser,
                LibStorage::EXT2() : `ext2,
                LibStorage::EXT3() : `ext3,
                LibStorage::VFAT() : `vfat,
                LibStorage::XFS() : `xfs,
                LibStorage::JFS() : `jfs,
                LibStorage::NTFS() : `ntfs,
                LibStorage::SWAP() : `swap,
                LibStorage::FSNONE() : `none
	      ]
     ];

map<string,any> conv_mountby = 
    $[ "def_sym" : `device,
       "def_int" : LibStorage::MOUNTBY_DEVICE(),
       "m" : $[ LibStorage::MOUNTBY_UUID() : `uuid,
                LibStorage::MOUNTBY_LABEL() : `label
	      ]
     ];

map<string,any> conv_encryption = 
    $[ "def_sym" : `none,
       "def_int" : LibStorage::ENC_NONE(),
       "m" : $[ LibStorage::ENC_TWOFISH() : `twofish,
                LibStorage::ENC_TWOFISH_OLD() : `twofish_old,
                LibStorage::ENC_TWOFISH256_OLD() : `twofish_256_old,
                LibStorage::ENC_UNKNOWN() : `unknown,
	      ]
     ];

map<string,any> conv_mdtype = 
    $[ "def_sym" : `raid_unknown,
       "def_int" : LibStorage::RAID_UNK(),
       "m" : $[ LibStorage::RAID0() : `raid0,
                LibStorage::RAID1() : `raid1,
                LibStorage::RAID5() : `raid5,
                LibStorage::RAID6() : `raid6,
                LibStorage::RAID10() : `raid10,
                LibStorage::MULTIPATH() : `multipath
	      ]
     ];

map<string,integer> conv_mdstring = 
    $[ "raid0" : LibStorage::RAID0(),
       "raid1" : LibStorage::RAID1(),
       "raid5" : LibStorage::RAID5(),
       "raid6" : LibStorage::RAID6(),
       "raid10" : LibStorage::RAID10(),
       "multipath" : LibStorage::MULTIPATH() ];

map<string,any> conv_mdparity = 
    $[ "def_sym" : `par_none,
       "def_int" : LibStorage::PAR_NONE(),
       "m" : $[ LibStorage::LEFT_ASYMMETRIC() : `left_asymmetric,
                LibStorage::LEFT_SYMMETRIC() : `left_symmetric,
                LibStorage::RIGHT_ASYMMETRIC() : `right_asymmetric,
                LibStorage::RIGHT_SYMMETRIC() : `right_symmetric
	      ]
     ];

map<string,integer> conv_parstring = 
    $[ "left_asymmetric" : LibStorage::LEFT_ASYMMETRIC(),
       "left_symmetric" : LibStorage::LEFT_SYMMETRIC(),
       "right_asymmetric" : LibStorage::RIGHT_ASYMMETRIC(),
       "right_symmetric" : LibStorage::RIGHT_SYMMETRIC() ];

global boolean DoCheckEvmsNonEvms = true;
global boolean DoCheckEvmsLvm = true;
map DiskMapVersion = $[];
map DiskMap = $[];
map ClassifiedSettings = $[];
map type_order = $[ `CT_DISK : 0, `CT_MD : 1, `CT_LOOP : 2, `CT_DM : 3,
                    `CT_LVM : 4, `CT_EVMS : 5 ];

 /*
  include "storage/routines.ycp";
 */
  /**
   * Get Device Name
   * @param disk Disk
   * @param any partition
   * @return string device name
   */
global define string GetDeviceName( string disk, any partition )
    {
      string ret = disk;

      if( is( partition, integer ) )
	  {
  	  if( find( disk, "/dev/cciss/" )==0 ||
  	      find( disk, "/dev/ida/" )==0 ||
  	      find( disk, "/dev/ataraid/" )==0 ||
  	      find( disk, "/dev/etherd/" )==0 ||
  	      find( disk, "/dev/rd/" )==0 )
  	      {
  	      ret = ret + "p";
  	      }
  	  ret = ret + sformat( "%1", partition );
	  }
      else if( size( (string)partition )>0 )
          {
  	  ret = ret + "/" + (string)partition;
	  }
      return( ret );
  };


    /* Storage = TargetMap 
    /* Storage = $[ "targets" 			: $[],
		    "lvm_view_all_mnt"    	: true,
		    "whole_disk"    		: false,
		    "must_reread_partitions"   	: false,
		    "win_device"   		: false,
		    "raidtab_created"   	: false,
		    "use_lvm"   		: false,
		    "testsuite"   		: false,
		    "do_resize"    		: "",
		    "part_proposal_mode"        : "",
		    "part_proposal_first"       : true,
		    "focus"		       	: key
		    ]
    */

    global boolean ZeroNewPartitions = false;

    map  StorageMap	= $[];
    map<integer,map>  StorageMaps	= $[];

    /* stringkeys for access  to the Storage map */
    string lvm_view_all_mnt_key  	= "lvm_view_all_mnt";
    string targets_key 			= "targets";
    string targets_backup_key 		= "targets_backup";
    string targets_backup_l_key 	= "targets_l_backup";
    string targets_backup_m_key 	= "targets_m_backup";
    string part_mode_key 		= "part_mode";
    string part_disk_key  		= "part_disk";
    string whole_disk_key 		= "whole_disk";
    string raidtab_created_key 		= "raidtab_created";
    string testsuite_key       		= "testsuite";
    string do_resize_key 		= "do_resize";
    string win_device_key	 	= "win_device";
    string custom_display_key	 	= "custom_display";
    string part_proposal_mode_key	= "part_proposal_mode";
    string part_proposal_first_key	= "part_proposal_first";
    string part_proposal_active_key	= "part_proposal_active";
    string use_lvm_key			= "use_lvm";

    string storage_map_key		= "storage_map";
    string storage_type_key     	= "storage_type";
    string storage_doc_key		= "storage_doc";
    symbol record_key			= `record;
    symbol custom_key			= `custom;
    boolean lvm_initialized             = false;
    boolean probe_done             	= false;
    symbol  exit_key               	= `next;
    string  last_used              	= "";
    boolean force_disk_probe            = false;
    any sint                            = nil;
    list<map> conts                     = [];

/**
*
*/
global define map GetDiskPartition( string device )
    ``{
    map ret = $[];
    integer dlen = 0;
    boolean as_string = false;

    if( find( device, "/dev/hd" )==0 ||
	find( device, "/dev/sd" )==0 ||
	find( device, "/dev/ed" )==0 ||
	find( device, "/dev/iseries/vd" )==0 )
	{
	dlen = findfirstof( device, "0123456789" );
	if( dlen == nil )
	    {
	    dlen = size(device);
	    }
	}
    else if( find( device, "/dev/md" )==0 )
	{
	dlen = 7;
	}
    else if( find( device, "/dev/loop" )==0 )
	{
	dlen = 9;
	}
    else if( find( device, "/dev/i2o/hd" )==0 )
	{
	dlen = 12;
	}
    else if( find( device, "/dev/rd/" )==0 ||
	     find( device, "/dev/cciss/" )==0 ||
	     find( device, "/dev/ataraid/" )==0 ||
	     find( device, "/dev/etherd/" )==0 ||
	     find( device, "/dev/ida/" )==0 )
	{
	integer pos = findlastof( device, "p" );
	dlen = size(device);
	if( pos!=nil )
	    {
	    dlen = pos;
	    }
	}
    else if( find( device, "/dev/dasd" )==0 )
	{
	dlen = size(device);
	if( findfirstof( device, "0123456789" )>0 )
	    {
	    dlen = dlen-1;
	    }
	}
    else
	{
	as_string = true;
	if( size( splitstring(device, "/"))>3 )
	    {
	    integer pos = findlastof( device, "/" );
	    if( pos!=nil )
		{
		dlen = pos;
		}
	    }
	else
	    {
	    dlen = size(device);
	    }
	}
    ret = add( ret, "disk", substring( device, 0, dlen ) );
    device = substring( device, dlen );
    if( size(device)>0 && findfirstof( device, "/p" )==0 )
	{
	device = substring( device, 1 );
	}
    ret["nr"] = 0;
    if( as_string )
	{
	ret["nr"] = device;
	}
    else
	{
	if( size(device)>0 )
	    {
	    ret["nr"] = tointeger(device);
	    }
	}
    if( size(ret["disk"]:"")>0 && ret["nr"]:(any)1 == 0 )
	{
	ret["nr"] = "";
	}
    return( ret );
    };

void UpdateChangeTime()
    {
    integer change_time = time();
    StorageMap["targets_time"] = change_time;
    }

/* return partition <device> of map <tg> */
global define map<string,any> GetPartition( map<string,map> tg, string device )
    ``{
    map<string,any> ret = $[];
    map tmp = GetDiskPartition( device );
    string disk = tmp["disk"]:"";
    if( find(device, "/dev/evms")==0 && !haskey( tg, disk ) )
	{
	disk = "/dev/evms";
	}
    y2debug( "GetPartition device=%1", device );
    list< map<string,any> > part = (list< map<string,any> >)
	filter( map<string, any> pi, tg[disk,"partitions"]:[],
	        ``(pi["device"]:""==device ));
    ret = part[0]:$[];
    y2debug( "GetPartition ret=%1", ret );
    return( ret );
    }

/* return disk <device> belongs to in map <tg> */
global define map<string,any> GetDisk( map<string,map> tg, string device )
    ``{
    map<string,any> ret = $[];
    map tmp = GetDiskPartition( device );
    string disk = tmp["disk"]:"";
    if( find(device, "/dev/evms")==0 && !haskey( tg, disk ) )
	{
	disk = "/dev/evms";
	}
    y2debug( "GetDisk disk=%1", disk );
    return( (map<string,any>)tg[disk]:$[] );
    }


/* set <part>, return changed map <tg> */
global define map<string,map> SetPartition( map<string,map> tg, map part )
    ``{
    y2milestone( "SetPartition part=%1", part );
    map tmp = GetDiskPartition( part["device"]:"" );
    y2milestone( "SetPartition tmp=%1", tmp );
    string disk = tmp["disk"]:"";
    if( find(part["device"]:"", "/dev/evms")==0 && !haskey( tg, disk ) )
	{
	disk = "/dev/evms";
	}
    list r_part = filter(map p, tg[disk,"partitions"]:[],
			  ``(p["device"]:"" != part["device"]:""));
    r_part = add( r_part, part );
    tg[disk,"partitions"] = r_part;
    return( tg );
    }

/**
 * Find next free loop device.
 * @return string loop_dev ( e.g.: /dev/loop1 )
 */
global define string GetLoopDev( integer start )
    ``{
    if( Mode::test () )
	return "/dev/loop2";

    integer max_loop_dev= 15;
    integer loop_dev_nb = start;
    boolean found_free  = false;
    string  loop_dev    = "";

    while( !found_free && loop_dev_nb <= max_loop_dev )
	{
	loop_dev = sformat("/dev/loop%1", loop_dev_nb );
	loop_dev_nb = loop_dev_nb + 1;

	// Test loop dev
	if( SCR::Execute(.target.bash , "/sbin/losetup 2>/dev/null " + loop_dev ) != 0 )
	    found_free = true;
	}

    if( !found_free )
	{
	loop_dev = "";
	// internal error popup
	Popup::Error( _("Too many loop devices (cryptofs ...)") );
	y2error( "Too many loop devices");
	}

    y2milestone("ret \"%1\"",loop_dev);

    return( loop_dev );
    };

global define void SetMdOn( boolean on )
    ``{
    y2milestone( "SetMdOn on %1", on );
    if( on )
	{
	SCR::Write( .md.activate, "" );
	SCR::Write( .lvm.activate, "" );
	}
    else
	{
	SCR::Write( .lvm.deactivate, "" );
	SCR::Write( .md.deactivate, "" );
	}
    y2milestone( "return" );
    }

/** 
 * Get List of swap partitions
 * @return list List of swap partitions
 */
global define list SwappingPartitions()``{
    list ret = [];
    SCR::UnmountAgent (.proc.swaps);
    list<map> swaps = filter(map e, (list<map>) SCR::Read( .proc.swaps ),
                         ``(e["type"]:""=="partition"));
    ret = maplist(map e, swaps, ``(e["file"]:"") );
    y2milestone( "SwappingPartitions %1", ret );
    return( ret );
    }

global define list GetDestroyedLvmVgs( map<string,map> target )
    ``{
    list vgs = [];
    foreach(string diskdev, map disk, target,
	``{
	foreach( map p, disk["partitions"]:[],
	    ``{
	    if( p["used_by_type"]:`UB_NONE==`UB_LVM && p["format"]:false )
		{
		vgs = union( vgs, [ p["used_by"]:"" ] );
		}
	    });
	});
    vgs = sort( vgs );
    y2milestone( "GetDestroyedLvmVgs %1", vgs );
    return( vgs );
    }

global define map<string,map> DeleteDestroyedLvmVgs( map<string,map> target )
    ``{
    list<string> vgs = maplist( string s, (list<string>)GetDestroyedLvmVgs( target ), 
				``("/dev/"+s));
    y2milestone( "DeleteDestroyedLvmVgs %1", vgs );
    foreach( string dev, vgs,
	``{
	if( haskey( target, dev ))
	    target[dev,"delete"] = true;
	target[dev,"partitions"] = maplist( map p, target[dev,"partitions"]:[],
					    ``{ 
					    if( haskey( p, "mount" ))
						p = remove( p, "mount" ); 
					    return( p );
					    });
	y2milestone( "DeleteDestroyedLvmVgs %1: %2", dev, target[dev]:$[] );
	});
    return( target );
    }

global define map GetFreeSpace( string device, integer testsize,
                                symbol used_fs, boolean verbose )
    ``{
    if( Mode::test () )
	{
	integer wf =  tointeger(tofloat(testsize) * 0.6);
	integer wu =  tointeger(tofloat(testsize) * 0.4);
	integer ls =  tointeger(tofloat(testsize) * 0.5);
	return( $[ "free"  : wf, "used"    : wu,
		   "linux_size"  : ls, "new_size": (wu + wf - ls) ] );
	}

    integer used = 0;
    integer resize_free = 0;
    integer df_free = 0;
    boolean win_disk = false;

    boolean r = false;
    r = LibStorage::StorageInterface::getFreeInfo( sint, device, resize_free,
                                                   df_free, used, win_disk );

    if( r )
	{
	resize_free = resize_free * 1024;	// Byte
	df_free = df_free * 1024;	// Byte
	used = used * 1024;	// Byte
	}

    if( used_fs == `ntfs && !r && verbose )
	{
	string cmd = sformat("ntfsresize -f -i %1", device );
	y2milestone( "Executing cmd:%1", cmd );
	map bcall = (map) SCR::Execute( .target.bash_output, cmd, 
					$[ "LC_MESSAGES" :"POSIX"] );
	y2milestone( "Executing ret:%1", bcall );
	string tmp = _("Resize Not Possible:") + "\n\n";
	tmp = tmp + bcall["stdout"]:"" + bcall["stderr"]:"";
	Popup::Error( tmp );
	}

    integer linux_size = 0;
    integer min_linux_size = 0;
    integer add_free = df_free - resize_free;

    if( resize_free < 300000000 )
	{
	linux_size = 0;
	min_linux_size = 0;
	}
    else if( resize_free < 600000000 )
	{
	linux_size = resize_free;
	if( add_free < 75000000 )
	    {
	    linux_size = linux_size - 75000000 + add_free;
	    }
	min_linux_size = linux_size;
	}
    else if ( resize_free < 1000000000 )
	{
	linux_size = resize_free;
	if( add_free < 200000000 )
	    {
	    linux_size = linux_size - 200000000 + add_free;
	    }
	min_linux_size = 300000000;
	}
    else if ( resize_free < 2000000000 )
	{
	linux_size = resize_free;
	if( add_free < 300000000 )
	    {
	    linux_size = linux_size - 300000000 + add_free;
	    }
	min_linux_size = 500000000;
	}
    else if ( resize_free < 3000000000 )
	{
	linux_size = resize_free;
	if( add_free < 800000000 )
	    {
	    linux_size = linux_size - 800000000 + add_free;
	    }
	min_linux_size = 500000000;
	}
    else
	{
	linux_size = resize_free;
	if( add_free < resize_free/3 )
	    {
	    linux_size = linux_size - resize_free/3 + add_free;
	    }
	min_linux_size = 500000000;
	}

    integer new_size = used + add_free + resize_free - linux_size;

    map ret = $[ "free": (resize_free>0?resize_free:0),
		 "df_free" : df_free,
		 "used":used,
		 "win_disk":win_disk,
		 "linux_size":linux_size,
		 "max_win_size":used + resize_free + add_free - min_linux_size,
		 "ntfs" : (used_fs == `ntfs),
		 "new_size":new_size ];
    y2milestone( "GetFreeSpace ret %1", ret );
    return( ret );
    };

global define map<string,map> AddWinInfo( map<string,map> targets )
    ``{
    y2milestone( "AddWinInfo called" );
    foreach(string disk, map data, targets,
	``{
	targets[disk,"partitions"] = 
	    maplist(map p, data["partitions"]:[],
		``{
		if( Partitions::IsDosWinNtPartition(p["fsid"]:0) &&
		    contains( [ `ntfs, `vfat ], p["used_fs"]:`none ))
		    {
		    p["winfo"] = GetFreeSpace( p["device"]:"", 0, 
		                               p["used_fs"]:`none, false );
		    y2milestone( "AddWinInfo %1", p );
		    }
		return( p );
		});
	});
    return( targets );
    };

global define string SaveDumpPath( string name )``{
    string ret = Directory::tmpdir + "/" + name;
    y2debug( "name=%1 path=%2", name, ret );
    return ret;
    }

map lenc = $[ "el" : "iso8859-7",
              "hu" : "iso8859-2",
              "cs" : "iso8859-2",
              "hr" : "iso8859-2",
              "sl" : "iso8859-2",
              "sk" : "iso8859-2",
              "en" : "iso8859-1",
              "tr" : "iso8859-9",
	      "lt" : "iso8859-13",
	      "bg" : "iso8859-5",
	      "ru" : "iso8859-5"];

global define string LangTypicalEncoding()
    ``{
    string lang = Encoding::GetEncLang();
    string enc = "utf8";
    if( !Encoding::GetUtf8Lang() )
	{
	enc = "iso8859-15";
	lang = substring(lang, 0, 2);
	lang = tolower(lang);
	if( haskey( lenc, lang ) )
	    {
	    enc = lenc[lang]:"";
	    }
	}
    y2milestone( "LangTypicalEncoding lang %1 ret %2", lang, enc );
    return( enc );
    }

//  add mount point for all mounted partitions
global define map<string,map> AddMountPointInfo( map<string,map> target )
    ``{
    list<map> mounts = Partitions::CurMounted();
    foreach(string diskdev, map disk, target,
	``{
	// variable renamed due to some interpreter problems
	list<map> tmp2 = disk["partitions"]:[];
	tmp2 = maplist(map part, tmp2,
	    ``{
	    map mt = find(map mp, mounts, ``(mp["spec"]:" "==part["device"]:"" ||
					   mp["loop_on"]:" "==part["device"]:""));
	    if( mt != nil )
		{
		part["mount"] = mt["file"]:"";
		if( part["noauto"]:false )
		    {
		    part["active"] = true;
		    }
		}
	    return( part );
	    });
	disk["partitions"] = tmp2;
	target[diskdev] = disk;
	});
    return( target );
    }

global define list FindFstabLines( map fstab, string mount, string device,
                                   string uuid, string label )
    ``{
    list<integer> lines = [];
    if( size(mount)>0 && mount != "swap" )
	{
	lines = AsciiFile::FindLineField( fstab, 1, mount );
	}
    if( size(lines)==0 )
	{
	lines = AsciiFile::FindLineField( fstab, 0, device );
	}
    if( size(lines)>1 )
	{
	uuid = "UUID=" + uuid;
	label = "LABEL=" + label;
	map<integer,map> tlines = AsciiFile::GetLines( fstab, lines );
	map<integer,map> nlist = filter(integer num, map line, tlines,
			    ``( line["fields",0]:"" == device ||
				line["fields",0]:"" == uuid ||
				line["fields",0]:"" == label ));
	if( size(nlist)>0 )
	    {
	    lines = maplist( integer num, map line, nlist, ``(num));
	    }
	}
    y2milestone( "lines %1", lines );
    return( lines );
    };

//  add info gotten from /etc/fstab to targetMap
global define map<string,map> AddFstabInfo( map<string,map> target, boolean lineno )
    ``{
    y2milestone( "lineno=%1", lineno );
    map fstab = Partitions::GetFstab( "/etc/fstab" );
    map crtab = Partitions::GetCrypto( "/etc/cryptotab" );
    foreach(string diskdev, map disk, target,
	``{
	list new_part = [];
	foreach(map part, disk["partitions"]:[],
	    ``{
	    list<string> rem = [];
	    if( lineno )
		{
		rem = [ "fstabline", "crtabline" ];
		}
	    else
		{
		rem = [ "mountby", "fstopt" ];
		}
	    part = (map<string,any>)filter(string key, any val, (map<string,any>)part, ``(!contains( rem, key )));
	    string mp = part["mount"]:"";
	    if( size(part["ori_mount"]:"")>0 )
		{
		mp = part["ori_mount"]:"";
		}
	    list lines = [];
	    lines = FindFstabLines( fstab, mp, part["device"]:"",
	                            part["uuid"]:"", part["label"]:"" );
	    if( size(lines)>0 )
		{
		if( lineno )
		    {
		    part["fstabline"] = lines[0]:-1;
		    }
		else
		    {
		    map entry = AsciiFile::GetLine( fstab, lines[0]:-1 );
		    if( entry["fields",3]:"defaults" != "defaults" )
			{
			part["fstopt"] = entry["fields",3]:"";
			}
		    if( find(entry["fields",0]:"", "UUID=") > -1 )
			{
			part["mountby"] = `uuid;
			}
		    else if( find(entry["fields",0]:"", "LABEL=") > -1 )
			{
			part["mountby"] = `label;
			}
		    }
		}
	    lines = AsciiFile::FindLineField( crtab, 2, mp );
	    if( size(lines)==0 && diskdev!="/dev/loop" )
		{
		lines = AsciiFile::FindLineField( crtab, 1, part["device"]:"" );
		}
	    if( size(lines)==0 && diskdev=="/dev/loop" )
		{
		lines = AsciiFile::FindLineField( crtab, 0, part["device"]:"" );
		}
	    if( size(lines)>0 )
		{
		if( lineno )
		    {
		    part["crtabline"] = lines[0]:-1;
		    }
		else
		    {
		    map entry = AsciiFile::GetLine( crtab, lines[0]:-1 );
		    if( entry["fields",5]:"defaults" != "defaults" )
			{
			part["fstopt"] = entry["fields",5]:"";
			}
		    }
		}
	    y2milestone( "part=%1", part );
	    new_part = add( new_part, part );
	    });
	target[diskdev] = disk;
	target[diskdev,"partitions"] = new_part;
	});
    return( target );
    }

symbol toSymbol( map<string,any> conv, integer val )
    {
    return( conv["m",val]:(conv["def_sym"]:`invalid_conv_map) );
    }

integer fromSymbol( map<string,any> conv, symbol val )
    {
    integer ret = conv["def_int"]:-1;
    foreach( integer i, symbol s, conv["m"]:$[],
	``{
	if( s==val )
	    ret = i;
	});
    return( ret );
    }

global define boolean CheckBackupState( string who )
    {
    y2milestone( "CheckBackupStates who:%1", who );
    boolean ret = LibStorage::StorageInterface::checkBackupState( sint, who );
    y2milestone( "CheckBackupStates ret:%1", ret );
    return( ret );
    }

map volumeMap( any vinfo, map p )
    {
    y2milestone( "volumeMap vinfo:%1 p:%2", vinfo, p );
    p["device"] = LibStorage::VolumeInfo::swig_device_get(vinfo);
    p["size_k"] = LibStorage::VolumeInfo::swig_sizeK_get(vinfo);
    p["name"] = LibStorage::VolumeInfo::swig_name_get(vinfo);
    integer t = LibStorage::VolumeInfo::swig_fs_get(vinfo);
    symbol fs = toSymbol( conv_fs, t );
    y2milestone( "volumeMap t:%1 fs:%2", t, fs );
    p["detected_fs"] = fs;
    if( fs != `unknown )
	p["used_fs"] = fs;
    boolean tbool = LibStorage::VolumeInfo::swig_format_get(vinfo);
    if( tbool )
	p["format"] = true;
    tbool = LibStorage::VolumeInfo::swig_create_get(vinfo);
    if( tbool )
	p["create"] = true;
    string tmp = LibStorage::VolumeInfo::swig_mount_get(vinfo);
    if( size(tmp)>0 )
	{
	p["mount"] = tmp;
	tbool = LibStorage::VolumeInfo::swig_is_mounted_get(vinfo);
	if( !tbool )
	    p["inactive"] = true;
	t = LibStorage::VolumeInfo::swig_mount_by_get(vinfo);
	if( t!=LibStorage::MOUNTBY_DEVICE() )
	    {
	    p["mountby"] = toSymbol( conv_mountby, t );
	    }
	}
    t = LibStorage::VolumeInfo::swig_usedBy_get(vinfo);
    if( t!=LibStorage::UB_NONE() )
	{
	p["used_by_type"] = toSymbol( conv_usedby, t );
	p["used_by"] = LibStorage::VolumeInfo::swig_usedByName_get(vinfo);
	}
    tmp = LibStorage::VolumeInfo::swig_fstab_options_get(vinfo);
    if( size(tmp)>0 )
	{
	p["fstopt"] = tmp;
	if( find( string s, splitstring( tmp, "," ), ``(s=="noauto") )!=nil )
	    p["noauto"] = true;
	}
    tmp = LibStorage::VolumeInfo::swig_mkfs_options_get(vinfo);
    if( size(tmp)>0 )
	p["mkfs_opt"] = tmp;
    tmp = LibStorage::VolumeInfo::swig_uuid_get(vinfo);
    if( size(tmp)>0 )
	p["uuid"] = tmp;
    tmp = LibStorage::VolumeInfo::swig_label_get(vinfo);
    if( size(tmp)>0 )
	p["label"] = tmp;
    t = LibStorage::VolumeInfo::swig_encryption_get(vinfo);
    if( t!=LibStorage::ENC_NONE() )
	{
	p["enc_type"] = toSymbol( conv_encryption, t );
	}
    y2milestone( "volumeMap vinfo:%1 p:%2", vinfo, p );
    return( p );
    }

map getContainerInfo( map c )
    {
    y2milestone( "getContainerInfo %1", c );
    integer ret = 0;
    integer t = 0;
    any vinfo = LibStorage::VolumeInfo::new("LibStorage::VolumeInfo");
    if( c["type"]:`CT_UNKNOWN == `CT_DISK )
	{
	list<any> pinfos = [];
	any infos = LibStorage::DiskInfo::new("LibStorage::DiskInfo");
	string d = c["device"]:"";
	ret = LibStorage::StorageInterface::getDiskInfo( sint, d, infos );
	if( ret==0 )
	    {
	    c["size_k"] = LibStorage::DiskInfo::swig_sizeK_get(infos);
	    c["cyl_size"] = LibStorage::DiskInfo::swig_cylSizeB_get(infos);
	    c["cyl_count"] = LibStorage::DiskInfo::swig_cyl_get(infos);
	    c["label"] = LibStorage::DiskInfo::swig_disklabel_get(infos);
	    c["max_logical"] = LibStorage::DiskInfo::swig_maxLogical_get(infos);
	    c["max_primary"] = LibStorage::DiskInfo::swig_maxPrimary_get(infos);
	    }
	else
	    y2warning( "disk \"%1\" ret:%2", c["device"]:"", ret );
	c["partitions"] = [];
	ret = LibStorage::StorageInterface::getPartitionInfo( sint, d, pinfos );
	y2milestone( "getContainerInfo ret:%1 size:%2 pinfos:%3", 
	             ret, size(pinfos), pinfos );
	foreach( any info, pinfos, 
	    ``{
	    y2milestone( "getContainerInfo info:%1", info );
	    string tmp = "";
	    map p = $[];
	    vinfo = LibStorage::PartitionInfo::swig_v_get(info);
	    y2milestone( "getContainerInfo vinfo:%1", vinfo );
	    p = volumeMap( vinfo, p );
	    p["nr"] = LibStorage::PartitionInfo::swig_nr_get(info);
	    p["fsid"] = LibStorage::PartitionInfo::swig_id_get(info);
	    p["fstype"] = Partitions::FsIdToString( p["fsid"]:0 );
	    p["region"] = [ LibStorage::PartitionInfo::swig_cylStart_get(info),
			    LibStorage::PartitionInfo::swig_cylSize_get(info) ];
	    t = LibStorage::PartitionInfo::swig_partitionType_get(info);
	    p["type"] = toSymbol( conv_ptype, t );
	    boolean boot = LibStorage::PartitionInfo::swig_boot_get(info);
	    if( boot )
		p["boot"] = true;
	    c["partitions"] = add( c["partitions"]:[], p );
	    });
	pinfos = [];
	ret = LibStorage::StorageInterface::getPartitionInfo( sint, d, pinfos );
	}
    else if( c["type"]:`CT_UNKNOWN == `CT_LVM )
	{
	list<any> pinfos = [];
	any infos = LibStorage::LvmVgInfo::new("LibStorage::LvmVgInfo");
	string n = c["name"]:"";
	ret = LibStorage::StorageInterface::getLvmVgInfo( sint, n, infos );
	if( ret==0 )
	    {
	    c["size_k"] = LibStorage::LvmVgInfo::swig_sizeK_get(infos);
	    c["cyl_size"] = 1024*LibStorage::LvmVgInfo::swig_peSize_get(infos);
	    c["cyl_count"] = LibStorage::LvmVgInfo::swig_peCount_get(infos);
	    c["pe_free"] = LibStorage::LvmVgInfo::swig_peFree_get(infos);
	    c["lvm2"] = LibStorage::LvmVgInfo::swig_lvm2_get(infos);
	    list<string> ls = splitstring( LibStorage::LvmVgInfo::swig_devices_get(infos), " " );
	    y2milestone( "ls=%1", ls );
	    c["devices"] = ls;
	    ls = splitstring( LibStorage::LvmVgInfo::swig_devices_add_get(infos), " " );
	    if( size(ls)>0 )
		c["devices_add"] = ls;
	    ls = splitstring( LibStorage::LvmVgInfo::swig_devices_rem_get(infos), " " );
	    if( size(ls)>0 )
		c["devices_rem"] = ls;
	    }
	else
	    y2warning( "LVM Vg \"%1\" ret:%2", c["name"]:"", ret );
	ret = LibStorage::StorageInterface::getLvmLvInfo( sint, n, pinfos );
	foreach( any info, pinfos, 
	    ``{
	    map p = $[];
	    vinfo = LibStorage::LvmLvInfo::swig_v_get(info);
	    p = volumeMap( vinfo, p );
	    p["stripes"] = LibStorage::LvmLvInfo::swig_stripe_get(info);
	    t = LibStorage::LvmLvInfo::swig_stripe_size_get(info);
	    if( t>0 )
		p["stripesize"] = t;
	    p["type"] = `lvm;
	    p["fstype"] = Partitions::lv_name;
	    c["partitions"] = add( c["partitions"]:[], p );
	    });
	}
    else if( c["type"]:`CT_UNKNOWN == `CT_EVMS )
	{
	list<any> pinfos = [];
	any infos = LibStorage::EvmsCoInfo::new("LibStorage::EvmsCoInfo");
	string n = c["name"]:"";
	c["is_container"] = size(c["name"]:"")>0;
	if( c["is_container"]:false )
	    {
	    ret = LibStorage::StorageInterface::getEvmsCoInfo( sint, n, infos );
	    if( ret==0 )
		{
		c["size_k"] = LibStorage::EvmsCoInfo::swig_sizeK_get(infos);
		c["cyl_size"] = 1024*LibStorage::EvmsCoInfo::swig_peSize_get(infos);
		c["cyl_count"] = LibStorage::EvmsCoInfo::swig_peCount_get(infos);
		c["pe_free"] = LibStorage::EvmsCoInfo::swig_peFree_get(infos);
		c["lvm2"] = LibStorage::EvmsCoInfo::swig_lvm2_get(infos);
		list<string> ls = splitstring( LibStorage::EvmsCoInfo::swig_devices_get(infos), " " );
		c["devices"] = ls;
		ls = splitstring( LibStorage::EvmsCoInfo::swig_devices_add_get(infos), " " );
		if( size(ls)>0 )
		    c["devices_add"] = ls;
		ls = splitstring( LibStorage::EvmsCoInfo::swig_devices_rem_get(infos), " " );
		if( size(ls)>0 )
		    c["devices_add"] = ls;
		}
	    else
		y2warning( "EVMS Co \"%1\" ret:%2", c["name"]:"", ret );
	    }
	ret = LibStorage::StorageInterface::getEvmsInfo( sint, n, pinfos );
	if( ret<0 )
	    y2warning( "getEvmsInfo ret:%1", ret );
	y2milestone( "getContainerInfo n:%1 ret=%2", n, ret );
	foreach( any info, pinfos, 
	    ``{
	    map p = $[];
	    vinfo = LibStorage::EvmsInfo::swig_v_get(info);
	    p = volumeMap( vinfo, p );
	    p["stripes"] = LibStorage::EvmsInfo::swig_stripe_get(info);
	    t = LibStorage::EvmsInfo::swig_stripe_size_get(info);
	    if( t>0 )
		p["stripesize"] = t;
	    boolean tbool = LibStorage::EvmsInfo::swig_compatible_get(info);
	    if( !tbool )
		p["evms_native"] = true;
	    p["type"] = `evms;
	    p["fstype"] = Partitions::evms_name;
	    y2milestone( "partition %1", p );
	    c["partitions"] = add( c["partitions"]:[], p );
	    });
	}
    else if( c["type"]:`CT_UNKNOWN == `CT_MD )
	{
	list<any> pinfos = [];
	ret = LibStorage::StorageInterface::getMdInfo( sint, pinfos );
	if( ret<0 )
	    y2warning( "getMdInfo ret:%1", ret );
	foreach( any info, pinfos, 
	    ``{
	    map p = $[];
	    vinfo = LibStorage::MdInfo::swig_v_get(info);
	    p = volumeMap( vinfo, p );
	    p["nr"] = LibStorage::MdInfo::swig_nr_get(info);
	    y2milestone( "MdInfo p=%1", p );
	    integer t = LibStorage::MdInfo::swig_type_get(info);
	    y2milestone( "MdInfo t=%1", t );
	    p["raid_type"] = substring( sformat( "%1", toSymbol( conv_mdtype, t )), 1 );
	    y2milestone( "MdInfo p=%1", p );
	    if( p["raid_type"]:""=="raid5" )
		{
		t = LibStorage::MdInfo::swig_parity_get(info);
		symbol pt = toSymbol( conv_mdparity, t );
		if( pt != `par_none )
		    p["parity_algorithm"] = substring( sformat( "%1", pt), 1 );
		}
	    y2milestone( "MdInfo p=%1", p );
	    p["type"] = `sw_raid;
	    p["fstype"] = Partitions::raid_name;
	    y2milestone( "MdInfo p=%1", p );
	    t = LibStorage::MdInfo::swig_chunk_get(info);
	    if( t>0 )
		{
		p["chunk_size"] = t;
		}
	    y2milestone( "MdInfo string ls=%1", LibStorage::MdInfo::swig_devices_get(info) );
	    list<string> ls = splitstring( LibStorage::MdInfo::swig_devices_get(info), " " );
	    y2milestone( "MdInfo ls=%1", ls );
	    p["devices"] = ls;
	    y2milestone( "getContainerInfo MdInfo p:%1", p );
	    c["partitions"] = add( c["partitions"]:[], p );
	    });
	}
    else if( c["type"]:`CT_UNKNOWN == `CT_LOOP )
	{
	list<any> pinfos = [];
	ret = LibStorage::StorageInterface::getLoopInfo( sint, pinfos );
	if( ret<0 )
	    y2warning( "getLoopInfo ret:%1", ret );
	foreach( any info, pinfos, 
	    ``{
	    map p = $[];
	    vinfo = LibStorage::LoopInfo::swig_v_get(info);
	    p = volumeMap( vinfo, p );
	    p["nr"] = LibStorage::LoopInfo::swig_nr_get(info);
	    p["type"] = `loop;
	    p["fstype"] = Partitions::loop_name;
	    p["fpath"] = LibStorage::LoopInfo::swig_file_get(info);
	    c["partitions"] = add( c["partitions"]:[], p );
	    });
	}
    else if( c["type"]:`CT_UNKNOWN == `CT_DM )
	{
	list<any> pinfos = [];
	ret = LibStorage::StorageInterface::getDmInfo( sint, pinfos );
	if( ret<0 )
	    y2warning( "getDmInfo ret:%1", ret );
	foreach( any info, pinfos, 
	    ``{
	    map p = $[];
	    vinfo = LibStorage::DmInfo::swig_v_get(info);
	    p = volumeMap( vinfo, p );
	    p["nr"] = LibStorage::DmInfo::swig_nr_get(info);
	    p["type"] = `dm;
	    p["fstype"] = Partitions::dm_name;
	    c["partitions"] = add( c["partitions"]:[], p );
	    });
	}
    //y2milestone ("getContainerInfo container %1", remove( c, "partitions" ) );
    y2milestone ("getContainerInfo container %1", c );
    return( c );
    }

map toDiskMap( map disk, map cinfo )
    {
    list<string> l = [ "size_k", "cyl_size", "cyl_count", "label",
		       "max_logical", "max_primary", "type", 
		       "used_by_type", "used_by", "partitions" ];
    foreach( string s, l,
	``{
	if( haskey( cinfo, s ) )
	    disk[s] = cinfo[s]:(any)0;
	});
    if( cinfo["readonly"]:false )
	disk["readonly"] = true;
    return( disk );
    }

list<map> getContainers()
    ``{
    list<map> ret = [];
    list<any> cinfos = [];
    LibStorage::StorageInterface::getContainers( sint, cinfos );
    foreach( any info, cinfos, 
	``{
	map c = $[];
	c["name"] = LibStorage::ContainerInfo::swig_name_get(info);
	c["device"] = LibStorage::ContainerInfo::swig_device_get(info);
	integer t = LibStorage::ContainerInfo::swig_type_get(info);
	c["type"] = toSymbol( conv_ctype, t );
	t = LibStorage::ContainerInfo::swig_usedBy_get(info);
	if( t!=LibStorage::UB_NONE() )
	    {
	    c["used_by_type"] = toSymbol( conv_usedby, t );
	    c["used_by"] = LibStorage::ContainerInfo::swig_usedByName_get(info);
	    }
	boolean b = LibStorage::ContainerInfo::swig_readonly_get(info);
	if( b )
	    c["readonly"] = true;
	ret = add( ret, c );
	});
    y2milestone( "getContainers ret:%1", ret );
    return( ret );
    };

integer count=0;

global void UpdateTargetMap()
    {
    conts = getContainers();
    list<string> rem_keys = [];
    map<string,map> tg = StorageMap[targets_key]:$[];
    SCR::Write(.target.ycp, "/tmp/upd_all_bef_"+sformat("%1",count), StorageMap[targets_key]:$[] );
    foreach( string dev, map disk, tg,
	``{
	map c = $[];
	c = find( map c, conts, ``(c["device"]:""==dev) );
	if( c==nil )
	    rem_keys = add( rem_keys, dev );
	else if( c["type"]:`CT_UNKNONW==`CT_DISK )
	    {
	    tg[dev] = toDiskMap( tg[dev]:$[], getContainerInfo( c ) );
	    y2milestone( "UpdateTargetMap dev:%1 is:%2", dev, tg[dev]:$[] );
	    }
	else
	    {
	    tg[dev] = getContainerInfo(c);
	    y2milestone( "UpdateTargetMap dev:%1 is:%2", dev, tg[dev]:$[] );
	    }
	});
    y2milestone( "UpdateTargetMap rem_keys:%1 count:%2", rem_keys, count );
    foreach( string dev, rem_keys, ``{tg=remove(tg,dev);});
    foreach( map c, conts, 
	``{
	if( c["type"]:`CT_UNKNOWN!=`CT_DISK && !haskey( tg, c["device"]:"" ))
	    {
	    tg[c["device"]:""] = getContainerInfo(c);
	    y2milestone( "UpdateTargetMap dev:%1 is:%2", c["device"]:"", 
	                 tg[c["device"]:""]:$[] );
	    }
	});
    StorageMap[targets_key] = tg;
    UpdateChangeTime();
    SCR::Write(.target.ycp, "/tmp/upd_all_aft_"+sformat("%1",count), StorageMap[targets_key]:$[] );
    count = count+1;
    }

define void UpdateTargetMapDisk( string dev )
    {
    y2milestone( "UpdateTargetMapDisk" );
    conts = getContainers();
    map c = $[];
    c = find( map c, conts, ``(c["device"]:""==dev) );
    map tg = StorageMap[targets_key]:$[];
    SCR::Write(.target.ycp, "/tmp/upd_disk_bef_"+sformat("%1",count), StorageMap[targets_key]:$[] );
    if( c==nil )
	tg = remove( tg, dev );
    else if( c["type"]:`CT_UNKNONW==`CT_DISK )
	{
	tg[dev] = toDiskMap( tg[dev]:$[], getContainerInfo( c ) );
	}
    else
	{
	tg[dev] = getContainerInfo(c);
	}
    StorageMap[targets_key] = tg;
    UpdateChangeTime();
    SCR::Write(.target.ycp, "/tmp/upd_disk_aft_"+sformat("%1",count), StorageMap[targets_key]:$[] );
    count = count+1;
    }

define void UpdateTargetMapDev( string dev )
    {
    map<string,map> tg = StorageMap[targets_key]:$[];
    SCR::Write(.target.ycp, "/tmp/upd_dev_bef_"+sformat("%1",count), tg );
    string cdev="";
    foreach( string key, map d, tg,
	``{
	if( size(cdev)==0 && 
	    find( map p, d["partitions"]:[], ``(p["device"]:""==dev))!=nil )
	    cdev = d["device"]:"";
	});
    map c = $[];
    c = find( map c, conts, ``(c["device"]:""==cdev) );
    map disk = $[];
    if( c!=nil )
	{
	disk = getContainerInfo( c );
	}
    if( c!=nil && haskey( tg, cdev ))
	{
	list<map> partitions = tg[cdev,"partitions"]:[];
	boolean found = false;
	partitions = maplist( map p, partitions,
	    ``{
	    if( p["device"]:"" == dev )
		{
		map pp = find( map q, disk["partitions"]:[], 
			       ``(q["device"]:""==dev));
		if( pp!=nil )
		    {
		    found = true;
		    p = pp;
		    }
		}
	    return( p );
	    });
	tg[disk["device"]:"","partitions"] = partitions;
	if( !found )
	    y2error( "UpdateTargetMapDev not found %1", dev );
	}
    else
	y2error( "UpdateTargetMapDev key %1 not found in target", disk["device"]:"" );
    StorageMap[targets_key] = tg;
    UpdateChangeTime();
    SCR::Write(.target.ycp, "/tmp/upd_dev_aft_"+sformat("%1",count), StorageMap[targets_key]:$[] );
    count = count+1;
    }

global define map getDiskInfo( string device, map disk )
    {
    map c = $[];
    c = find( map p, conts, ``(p["device"]:""==device ));
    y2milestone( "getDiskInfo c:%1", c );
    if( c!=nil )
	{
	disk = toDiskMap( disk, getContainerInfo( c ) );
	}
    y2milestone( "getDiskInfo ret:%1", disk );
    return( disk );
    }

global define void SaveExitKey( symbol key )
    ``{
    if( key == `next || key == `back )
	{
	exit_key = key;
	y2milestone( "Exit Key %1", exit_key );
	}
    };

global define symbol GetExitKey()
    ``{
    return( exit_key );
    };

global define void SetLastUsed( string device )
    {
    if( size(device)>0 )
	last_used = device;
    }

global define string GetLastUsed()
    {
    return( last_used );
    }

global define map FindFstabEntry( map fstab, string mount, string device,
			          string uuid, string label )
    {
    map ret = $[];
    list lines = [];
    lines = FindFstabLines( fstab, mount, device, uuid, label );
    y2milestone( "mount=%1 device=%2 uuid=%3 label=%4", mount, device, uuid,
                 label );
    if( size(lines)>0 )
	{
	map entry = AsciiFile::GetLine( fstab, lines[0]:-1 );
	ret = $[ "spec" : entry["fields",0]:"",
	         "file" : entry["fields",1]:"",
	         "vfstype" : entry["fields",2]:"",
	         "mntops" : entry["fields",3]:"",
	         "freq" : entry["fields",4]:0,
	         "passno" : entry["fields",5]:0 ];
	}
    y2milestone( "ret %1", ret );
    return( ret );
    }

global define map GetOndiskTarget()
    {
    map ret = $[];
    if( size(StorageMap[targets_backup_key,"initial"]:$[])>0 )
	{
	ret = (map)eval( StorageMap[targets_backup_key,"initial"]:$[] );
	}
    return( ret );
    }

global define map<string,map> GetTargetMap();


global define void CreateTargetBackup(string who)
    {
    string t = "targetMap_s_" + who + "_" + sformat("%1",count);
    count = count+1;
    SCR::Write(.target.ycp, Storage::SaveDumpPath(t), GetTargetMap() );
    y2milestone( "CreateTargetBackup who:%1", who );
    integer ret = LibStorage::StorageInterface::createBackupState( sint, who );
    if( ret<0 )
	y2error( "CreateTargetBackup sint ret %1", ret );
    }

global define void DisposeTargetBackup(string who)
    {
    y2milestone( "DisposeTargetBackup who:%1", who );
    integer ret = LibStorage::StorageInterface::removeBackupState( sint, who );
    if( ret<0 )
	y2error( "DisposeTargetBackup sint ret %1", ret );
    }

global define boolean EqualBackupStates( string s1, string s2, boolean vb )
    {
    y2milestone( "EqualBackupStates s1:\"%1\" s2:\"%2\" verbose:%3", 
                 s1, s2, vb );
    boolean ret = LibStorage::StorageInterface::equalBackupStates( sint, s1, 
                                                                   s2, vb );
    y2milestone( "EqualBackupStates ret:%1", ret );
    return( ret );
    }

global define void RestoreTargetBackup( string who )
    {
    y2milestone( "RestoreTargetBackup who:%1", who );
    integer ret = LibStorage::StorageInterface::restoreBackupState( sint, who );
    if( ret<0 )
	y2error( "RestoreTargetBackup sint ret %1", ret );
    UpdateTargetMap();
    string t = "targetMap_r_" + who;
    SCR::Write(.target.ycp, Storage::SaveDumpPath(t), GetTargetMap() );
    }

global define void ResetOndiskTarget()
    {
    RestoreTargetBackup( "initial" );
    }

global define integer GetTargetChangeTime() 
    {
    return( StorageMap["targets_time"]:0 );
    }

global define boolean GetPartProposalActive()
    {
    return StorageMap[part_proposal_active_key]:true;
    };

global define void SetPartProposalActive( boolean value )
    {
    StorageMap[part_proposal_active_key] = value;
    };

global define string GetPartMode()
    {
    y2milestone( "GetPartMode %1", StorageMap[part_mode_key]:"" );
    return StorageMap[part_mode_key]:"";
    };

global define void SetPartMode( string value )
    {
    y2milestone( "SetPartMode %1", value );
    StorageMap[part_mode_key] = value;
    };

global define boolean GetCustomDisplay()
    {
    return StorageMap[custom_display_key]:false;
    };

global define void SetCustomDisplay( boolean value )
    {
    StorageMap[custom_display_key] = value;
    };

global define string GetPartDisk()
    {
    return StorageMap[part_disk_key]:"";
    };

global define void SetPartDisk( string value )
    {
    StorageMap[part_disk_key] = value;
    };


  global define boolean GetTestsuite()``{
      return StorageMap[testsuite_key]:false;
  }

  global define void SetTestsuite( boolean value ) ``{
      StorageMap = add( StorageMap, testsuite_key, value );
  }

  global define boolean GetLvmViewAllMnt()``{
      return StorageMap[lvm_view_all_mnt_key]:true;
  }

  global define void SetLvmViewAllMnt( boolean value ) ``{
      StorageMap = add( StorageMap, lvm_view_all_mnt_key, value );
  }

  global define boolean GetRaidtabCreated()``{
      return StorageMap[raidtab_created_key]:false;
  }

  global define void SetRaidtabCreated( boolean value ) ``{
      StorageMap = add( StorageMap, raidtab_created_key, value );
  }

  global define string GetDoResize()``{
      return StorageMap[do_resize_key]:"NO";
  }

  global define void SetDoResize( string value ) ``{
      StorageMap = add( StorageMap, do_resize_key, value );
  }

  global define string GetPartProposalMode()``{
      return StorageMap[part_proposal_mode_key]:"accept";
  }

  global define void SetPartProposalMode( string value ) ``{
      StorageMap = add( StorageMap, part_proposal_mode_key, value );
  }

  global define boolean GetWholeDisk()``{
      return StorageMap[whole_disk_key]:false;
  }

  global define void SetWholeDisk( boolean value ) ``{
      StorageMap = add( StorageMap, whole_disk_key, value );
  }

  global define boolean GetPartProposalFirst()``{
      return StorageMap[part_proposal_first_key]:true;
  }

  global define void SetPartProposalFirst( boolean value ) ``{
      StorageMap = add( StorageMap, part_proposal_first_key, value );
  }

  global define boolean GetWinDevice()``{
      return StorageMap[win_device_key]:false;
  }

  global define void SetWinDevice( boolean value ) ``{
      StorageMap = add( StorageMap, win_device_key, value );
    }




    /* StorageMaps =  [
       1: $[  storage_map_key		: 	$[ Storage_01],
              storage_type_key		:	`record,
	      ],
       2, $[ storage_map_key		: 	$[ Storage_02],
             storage_type_key		: 	`custom,
             storage_doc_key 		:	"create partition /dev/hda2"
	     ],
       3: $[ storage_map_key		:       $[ Storage_03 ],
             storage_type_key		:	`custom,
	     storage_doc_key		:	"delete partition /dev/hda1"
	     ],
       4: $[ storage_map_key		: 	$[ Storage_04 ],
             storage_type_key		: 	`record
	     ]
	];
    */



    /* Record - Rollback - Commit */
    /* update focus and Storage - StorageStack */

    /* Find the next free position in the map StorageMaps
     * @return integer
     */
    define integer NextStorageMapsPos() ``{
	return (size( StorageMaps) + 1);
    }


    define integer FindLastRecordEntry() ``{
	map<integer,any> all_record_entries = (map<integer,any>)filter (integer key, map entry , StorageMaps, ``( entry[storage_type_key]:custom_key == record_key ));
	list<integer> all_record_keys   = (list<integer>) maplist(integer key, any entry , all_record_entries,  ``(  key ));

	if( size( all_record_entries ) > 0 )
	    return sort(integer x, integer y, all_record_keys , ``(y < x))[0]:1;
	else return 0;
    }


    define void Rollback2Pos(integer pos ) ``{
	StorageMap = StorageMaps[pos,storage_map_key]:$[];
	StorageMaps = filter(integer key, map entry, StorageMaps, ``( key < pos ));
    }


    define void AddEntry2StorageMaps(symbol type_key, string doc )``{
	map storage_maps_entry = $[];

	storage_maps_entry = add(storage_maps_entry, storage_map_key  , StorageMap    );
	storage_maps_entry = add(storage_maps_entry, storage_type_key , type_key   );

	if( doc != "" )
	    storage_maps_entry = add(storage_maps_entry, storage_type_key , doc    );

	StorageMaps = add( StorageMaps, NextStorageMapsPos(), storage_maps_entry );
    }


    /**
     *
     * @return boolean
     */
    global define void Record()``{
	AddEntry2StorageMaps( record_key, "");
    }

    /**
     *
     * @return boolean
     */
    global define boolean Rollback()``{
	integer last_record_entry =  FindLastRecordEntry();
	if( last_record_entry != 0 )
	{
	    Rollback2Pos( last_record_entry );
	    return true;
	}
	else
	{
	    return false;
	}
    }

    /**
     *
     *	@return boolean
     */
global define boolean Commit()
    ``{
    integer last_record_entry = FindLastRecordEntry();
    if( last_record_entry != 0 )
	{
	StorageMaps = filter( integer key, map entry, StorageMaps,
			      ``( key < last_record_entry ));
	return true;
	}
    else
	{
	return false;
	}
    }

define any createInterface()
    {
    any ret = LibStorage::createStorageInterface(false, false, true);
    if( ZeroNewPartitions )
	LibStorage::StorageInterface::setZeroNewPartitions(ret,true);
    return( ret );
    }

global define void Storage()
    ``{
    y2milestone( "constructor Storage()" );
    StorageMap[targets_backup_key] = $[];
    StorageMap[targets_backup_l_key] = $[];
    StorageMap[targets_backup_m_key] = $[];
    if( Mode::normal () )
	{
	Storage::SetPartMode( "CUSTOM" );
	Storage::SetPartProposalActive( false  );
	}
    lvm_initialized = false;
    LibStorage::initDefaultLogger ();
    sint = createInterface();
    if( Stage::initial() )
	{
	LibStorage::StorageInterface::setDetectMountedVolumes(sint,false);
	LibStorage::StorageInterface::setRootPrefix( sint, 
	                                             Installation::destdir );
	}
    conts = getContainers();
    y2milestone( "conts:%1", conts );
    }


    /* Dev definitions

       dev     = maindev  | subdev
       maindev = "disk"   | "vg"	| "md" (raiddev)
       subdev  = "part"   | "lv" 	| "raid"

       e.g.: 	"disk" = "/dev/hda"	| "dev/sda"	| "/dev/hdd"  | ...
                "vg"   = "/dev/system" 	| "dev/group"   | ...
		"md"   = "/dev/md"  (only)
		"part" = "1//dev/hda"	| "2//dev/sda"	| ..
		"lv"   = "usr//dev/system" | "home//dev/system"
    */


    /* Key definitions

       key = maindevkey | subdevkey + maindevkey

       maindevkey	= key( disk | vg | md   )
       subdevkey	= key( part | lv | raid )
       subdevkey        = maindevkey + subdevindex | "all"

       subdevindex 	= 1 | 2 | "home" | "usr" | ..

       e.g.:
       maindevkey	= "/dev/hda"	| "/dev/md"	| "/dev/system"		| "all"
       subdevkey	= "1//dev/hda"	| "1//dev/md"	| "home//dev/system" 	| "all"


   */



    /*
     * @param key maindevkey or subdevkey e.g.:  "/dev/hda" or  "1//dev/hda"
     * @return boolean
     */
    global define boolean IsKeyMainDevKey(string key )``{
	if(  substring( key, 0, 1) == "/" )
	    return true;
	return false;

	/* TODO regexpmatch dont't work at the moment */
	//return regexpmatch( key, "/dev/.*" );
    }

    /* key - maindevkey - subdevkey defines */

    /*
     * Build a subdevkey with a maindevkey and a subdevindex.
     * subdevkey = subdevkey + "/" + maindevkey
     * @param maindevkey e.g.: /dev/hda
     * @param subdevkey e.g.: 1, "usr" ..
     * @return string "1//dev/hda" or "usr//dev/system" or "" by error
     */
    global define string GetSubDevKey(string maindevkey, any subdevindex )``{
	if( ! IsKeyMainDevKey( maindevkey ) )
	{
	    return "";
	}

	return sformat("%1/%2",subdevindex, maindevkey);
    }


    /*
     * Find a subdevkey in a key and return the subdevkey is one found else return nil.
     * @param key e.g.: "1//dev/hda" or "usr//dev/system" ..
     * @return string e.g.: "1" or "usr" ..
     */
    global define string GetSubDevIndex( string key )``{

	integer column = findfirstof( key, "/" );

	if ( column != nil )
	{
	    return( substring( key, 0, column));
	}
	else
	{
	    return( nil );
	}
    }


    /*
     * @param key maindevkey or subdevkey e.g.:  "/dev/hda" or  "1//dev/hda"
     * @return string maindev e.g.: "/dev/hda" or "/dev/system"
     */
    global define string GetMainDevKey( string key )``{

	if( IsKeyMainDevKey( key ) )
	    return key;

	integer column = findfirstof( key, "/" );

	if ( column != nil )
	{
	    return( substring( key, column+1));
	}
	else
	{
	    return( nil );
	}
    }





    /*
     * @param key maindevkey or subdevkey e.g.:  "/dev/hda" or  "1//dev/hda"
     * @return boolean
     */
    global define boolean IsKeySubDevKey(string key)``{

	if(  substring( key, 0, 1) != "/" )
	    return true;
	return false;

	/* TODO regexpmatch don't work at the moment */
	//return regexpmatch( key, ".*//dev/.*"  );
    }


    /* MainDev defines ------------------------------------------------------------------
    /* partition_defines -> isDisk */
    /* partition_defines -> isRaid */
    /* partition_defines -> isLVM  */
    symbol sw_raid_type_key = `sw_raid;
    symbol lvm_type_key	    = `lvm;
    symbol extended_type_key= `extended;





    global define boolean DelMainDev(string maindevkey )``{

	return false;
    }


global define map<string,map> RemoveAllPartEntry( map<string,map> tg, string skey, string value )
    ``{
    map<string,map> new_tg = tg;

    foreach(string dev, map disk, tg,
	``{
	boolean changed = false;
	list new_partitions = [];
	foreach (map partition, disk["partitions"]:[],
	    ``{
	    if( partition[skey]:"" == value )
		{
		partition = filter(string key, any value_inner, (map<string,any>)partition, ``( key != skey));
		changed = true;
		}
	    new_partitions = add( new_partitions , partition);
	    });

	if( changed )
	    {
	    disk["partitions"] = new_partitions;
	    new_tg[dev] = disk;
	    }
	});
    return( new_tg );
    };

global define list<map> RenumberS390Partitions( string dname,
                                                list<map> partitions )
    ``{
    integer cnt = 1;
    partitions = sort( map a, map b, partitions, 
                       ``(a["region",0]:0<b["region",0]:0));
    partitions = maplist( map p, partitions,
	``{
	if( p["nr"]:0 != cnt )
	    {
	    if( !haskey( p, "ori_nr" ) )
		{
		p["ori_nr"] = p["nr"]:0;
		}
	    p["nr"] = cnt;
	    p["device"] = GetDeviceName( dname, cnt );
	    }
	cnt = cnt+1;
	return( p );
	});
    y2milestone( "RenumberS390Partions %1", partitions ); 
    return( partitions );
    }

global define map<string, map> 
RenameTgDevices( map<string, map> tg, map<string, string> ren )
    ``{
    y2milestone( "RenameTgDevices ren:%1", ren );
    foreach( string dev, map co, tg,
	``{
	if( find( dev, "/dev/evms/" ) == 0 )
	    {
	    y2milestone( "RenameTgDevices before added:%1 removed:%2",
	                 co["added"]:[], co["removed"]:[] );
	    if( size(co["added"]:[])>0 )
		{
		co["added"] = 
		    maplist( string d, co["added"]:[], 
			     ``(haskey( ren, d )?(ren[d]:""):d));
		}
	    if( size(co["removed"]:[])>0 )
		{
		co["removed"] = 
		    maplist( string d, co["removed"]:[], 
			     ``(haskey( ren, d )?(ren[d]:""):d));
		}
	    y2milestone( "RenameTgDevices after added:%1 removed:%2",
	                 co["added"]:[], co["removed"]:[] );
	    tg[dev] = co;
	    }
	});
    return( tg );
    }

global define map<integer, map> 
RenameMtDevices( map<integer, map> mt, map<string, string> ren )
    ``{
    y2milestone( "RenameMtDevices ren:%1", ren );
    foreach( integer num, map entry, mt,
	``{
	if( entry["type"]:""=="create_vg" && size(entry["devices"]:[])>0 )
	    {
	    y2milestone( "RenameMtDevices before entry:%1", entry );
	    entry["devices"] = 
		maplist( string d, entry["devices"]:[], 
			 ``(haskey( ren, d )?(ren[d]:""):d));
	    y2milestone( "RenameMtDevices after entry:%1", entry );
	    mt[num] = entry;
	    }
	if( (entry["type"]:""=="create_pv" || entry["type"]:""=="remove_pv") &&
	    haskey( ren, entry["device"]:"" ))
	    {
	    y2milestone( "RenameMtDevices before entry:%1", entry );
	    entry["device"] = ren[entry["device"]:""]:"";
	    y2milestone( "RenameMtDevices after entry:%1", entry );
	    mt[num] = entry;
	    }
	});
    return( mt );
    }

global map NextPartition( string disk, symbol ptype )
    {
    y2milestone( "NextPartition disk:%1 ptype:%2", disk, ptype );
    map ret = $[];
    integer pt = fromSymbol(conv_ptype,ptype);
    y2milestone( "NextPartition type:%1 pt:%2", ptype, pt );
    integer num = 0;
    string dev = "";
    integer r = LibStorage::StorageInterface::nextFreePartition( sint, disk, 
                                                                 pt, num, dev );
    if( r<0 )
	y2error( "NextPartition ret %1", r );
    ret["device"] = dev;
    ret["nr"] = num;
    y2milestone( "NextPartition sint ret:%1 map:%2", r, ret );
    return( ret );
    }

global boolean CreatePartition( string disk, string device, symbol ptype, 
                                integer id, integer start, integer len )
    {
    y2milestone( "CreatePartition disk:%1 device:%2 ptype:%3 id:%4 start:%5 len:%6", 
                 disk, device, ptype, id, start, len );
    string cdev = "";
    integer pt = fromSymbol(conv_ptype,ptype);
    y2milestone( "CreatePartition type:%1 pt:%2", ptype, pt );
    integer ret = LibStorage::StorageInterface::createPartition( sint, disk, pt,
								 start, len,
								 cdev );
    if( device!=cdev )
	y2error( "CreatePartition device:%1 cdev:%2", device, cdev );
    if( ret<0 )
	y2error( "CreatePartition ret %1", ret );
    ret = LibStorage::StorageInterface::changePartitionId( sint, device, 
							   id );
    if( ret<0 )
	y2error( "CreatePartition ret %1", ret );
    y2milestone( "CreatePartition sint ret:%1", ret );
    UpdateTargetMapDisk( disk );
    return( ret==0 );
    }

global boolean UpdatePartition( string device, integer start, integer len )
    {
    y2milestone( "UpdatePartition device:%1 start:%2 len:%3", 
                 device, start, len );
    integer ret = 0;
    ret = LibStorage::StorageInterface::updatePartitionArea( sint, device, 
							     start, len );
    if( ret<0 )
	y2error( "UpdatePartition sint ret %1", ret );
    UpdateTargetMapDev( device );
    return( ret==0 );
    }

global boolean SetPartitionMount( string device, string mp )
    {
    y2milestone( "SetPartitionMount device:%1 mp:%2", device, mp );
    integer ret = 0;
    ret = LibStorage::StorageInterface::changeMountPoint( sint, device, mp );
    if( ret<0 )
	y2error( "SetPartitionMount sint ret %1", ret );
    UpdateTargetMapDev( device );
    return( ret==0 );
    }

global boolean SetPartitionFormat( string device, boolean format, symbol fs )
    {
    y2milestone( "SetPartitionFormat device:%1 format:%2 fs:%3", device, 
                 format, fs );
    integer ret = 0;
    integer tmp = fromSymbol( conv_fs, fs );
    y2milestone( "SetPartitionFormat fs:%1", tmp );
    ret = LibStorage::StorageInterface::changeFormatVolume( sint, device, 
                                                            format, tmp );
    if( ret<0 )
	y2error( "SetPartitionFormat sint ret %1", ret );
    UpdateTargetMapDev( device );
    return( ret==0 );
    }

global boolean SetPartitionId( string device, integer id )
    {
    y2milestone( "SetPartitionId device:%1 id:%2", device, id );
    integer ret = 0;
    ret = LibStorage::StorageInterface::changePartitionId( sint, device, id );
    if( ret<0 )
	y2error( "SetPartitionId sint ret %1", ret );
    UpdateTargetMapDev( device );
    return( ret==0 );
    }

global boolean UnchangePartitionId( string device )
    {
    y2milestone( "UnchangePartitionId device:%1", device );
    integer ret = 0;
    ret = LibStorage::StorageInterface::forgetChangePartitionId( sint, device );
    if( ret<0 )
	y2error( "UnchangePartitionId sint ret %1", ret );
    UpdateTargetMapDev( device );
    return( ret==0 );
    }

global boolean ResizeVolume( string device, string disk, integer new_size )
    {
    y2milestone( "ResizeVolume device:%1 disk:%2 new_size:%3", device, disk,
                 new_size );
    integer ret = 0;
    ret = LibStorage::StorageInterface::resizeVolume( sint, device, 
                                                      (new_size+1023)/1024 );
    if( ret<0 )
	y2error( "ResizeVolume sint ret %1", ret );
    UpdateTargetMapDisk( disk );
    return( ret==0 );
    }

global boolean ChangeVolumeProperties( map part )
    {
    integer ret = 0;
    integer tmp = 0;
    boolean changed = false;
    string ts = "";
    string dev = part["device"]:"";
    any vinfo = LibStorage::VolumeInfo::new("LibStorage::VolumeInfo");
    ret = LibStorage::StorageInterface::getVolume( sint, dev, vinfo );
    if( ret!=0 )
	y2error( "ChangeVolumeProperties device:%1 not found", dev );
    map curr = $[];
    if( ret==0 )
	{
	curr = volumeMap( vinfo, curr );
	}
    if( ret==0 && part["mount"]:"" != curr["mount"]:"" )
	{
	changed = true;
	ts = part["mount"]:"";
	ret = LibStorage::StorageInterface::changeMountPoint( sint, dev, ts );
	if( ret<0 )
	    y2error( "ChangeVolumeProperties sint ret %1", ret );
	else
	    y2milestone( "ChangeVolumeProperties sint ret:%1", ret );
	}
    if( ret==0 &&
        (part["format"]:false != curr["format"]:false || 
         part["used_fs"]:`none != curr["used_fs"]:`none) )
	{
	changed = true;
	tmp = fromSymbol(conv_fs,part["used_fs"]:`none);
	y2milestone( "ChangeVolumeProperties fs:%1 symbol:%2", tmp, part["used_fs"]:`none );
	ret = LibStorage::StorageInterface::changeFormatVolume( sint, dev, 
								part["format"]:false,
								tmp );
	if( ret<0 )
	    y2error( "ChangeVolumeProperties sint ret %1", ret );
	else
	    y2milestone( "ChangeVolumeProperties sint ret:%1", ret );
	}
    if( ret==0 && 
        size(part["mount"]:"")>0 && part["fstopt"]:"" != curr["fstopt"]:"" )
	{
	changed = true;
	ts = part["fstopt"]:"";
	ret = LibStorage::StorageInterface::changeFstabOptions( sint, dev, ts );
	if( ret<0 )
	    y2error( "ChangeVolumeProperties sint ret %1", ret );
	else
	    y2milestone( "ChangeVolumeProperties sint ret:%1", ret );
	}
    if( ret==0 && part["mountby"]:`device != curr["mountby"]:`device )
	{
	changed = true;
	tmp = fromSymbol(conv_mountby,part["mountby"]:`device);
	y2milestone( "ChangeVolumeProperties mby:%1", tmp );
	ret = LibStorage::StorageInterface::changeMountBy( sint, dev, tmp );
	if( ret<0 )
	    y2error( "ChangeVolumeProperties sint ret %1", ret );
	else
	    y2milestone( "ChangeVolumeProperties sint ret:%1", ret );
	}
    if( ret==0 && part["label"]:"" != curr["label"]:"" )
	{
	changed = true;
	ts = part["label"]:"";
	ret = LibStorage::StorageInterface::changeLabelVolume( sint, dev, ts );
	if( ret<0 )
	    y2error( "ChangeVolumeProperties sint ret %1", ret );
	else
	    y2milestone( "ChangeVolumeProperties sint ret:%1", ret );
	}
    if( ret==0 && 
        part["format"]:false && part["mkfs_opt"]:"" != curr["mkfs_opt"]:"" )
	{
	changed = true;
	ts = part["mkfs_opt"]:"";
	ret = LibStorage::StorageInterface::changeLabelVolume( sint, dev, ts );
	if( ret<0 )
	    y2error( "ChangeVolumeProperties sint ret %1", ret );
	else
	    y2milestone( "ChangeVolumeProperties sint ret:%1", ret );
	}
    if( ret==0 &&
        part["enc_type"]:`none != `none && haskey( ClassifiedSettings, dev ) )
	{
	changed = true;
        if( size(ClassifiedSettings[dev]:"")>0 )
	    {
	    string pwd = ClassifiedSettings["dev"]:"";
	    ret = LibStorage::StorageInterface::setCryptPassword( sint, dev, 
								  pwd );
	    if( ret<0 )
		y2error( "ChangeVolumeProperties sint ret %1", ret );
	    else
		y2milestone( "ChangeVolumeProperties sint ret:%1", ret );
	    }
        ClassifiedSettings = remove( ClassifiedSettings, dev );
	}
    if( ret==0 && part["enc_type"]:`none != curr["enc_type"]:`none )
	{
	changed = true;
	tmp = fromSymbol(conv_encryption,part["enc_type"]:`none);
	ret = LibStorage::StorageInterface::setCrypt( sint, dev, part["enc_type"]:`none!=`none  );
	if( ret<0 )
	    {
	    y2error( "ChangeVolumeProperties sint ret %1", ret );
	    if( !part["format"]:false && part["enc_type"]:`none!=`none )
		Popup::Error( sformat(_("Could not set encryption.
System error code is %1.

Maybe the crypt password you provided was wrong."), ret ));
	    LibStorage::StorageInterface::forgetCryptPassword( sint, dev );
	    }
	else
	    y2milestone( "ChangeVolumeProperties sint ret:%1", ret );
	}
    if( ret==0 )
	{
	y2debug( "ChangeVolumeProperties changed:%1 part:%2", changed, part );
	if( changed )
	    UpdateTargetMapDev( dev );
	}
    return( ret==0 );
    }

global boolean DeleteDevice( string disk, string device )
    {
    y2milestone( "DeleteDevice disk:%1 device:%2", disk, device );
    integer ret = LibStorage::StorageInterface::removeVolume( sint, device );
    if( ret<0 )
	y2error( "DeleteDevice sint ret %1", ret );
    UpdateTargetMap();
    return( ret==0 );
    }

global boolean DeleteLvmVg( string name )
    {
    y2milestone( "DeleteLvmVg name:%1", name );
    integer ret = LibStorage::StorageInterface::removeLvmVg( sint, name );
    if( ret<0 )
	y2error( "DeleteLvmVg sint ret %1", ret );
    UpdateTargetMap();
    return( ret==0 );
    }

global boolean CreateLvmVg( string name, integer pesize, boolean lvm2 )
    {
    y2milestone( "CreateLvmVg name:%1 pesize:%2 lvm2:%3", name, pesize, lvm2 );
    list<string> devs = [];
    integer ret = 0;
    ret = LibStorage::StorageInterface::createLvmVg( sint, name, pesize/1024,
                                                     !lvm2, devs );
    if( ret<0 )
	y2error( "CreateLvmVg sint ret %1", ret );
    UpdateTargetMap();
    return( ret==0 );
    }

global boolean ExtendLvmVg( string name, string device )
    {
    y2milestone( "ExtendLvmVg name:%1 device:%2", name, device );
    integer ret = 0;
    list<string> devs = [ device ];
    ret = LibStorage::StorageInterface::extendLvmVg( sint, name, devs );
    if( ret<0 )
	y2error( "ExtendLvmVg sint ret %1", ret );
    UpdateTargetMap();
    return( ret==0 );
    }

global boolean ReduceLvmVg( string name, string device )
    {
    y2milestone( "ReduceLvmVg name:%1 device:%2", name, device );
    integer ret = 0;
    list<string> devs = [ device ];
    ret = LibStorage::StorageInterface::shrinkLvmVg( sint, name, devs );
    if( ret<0 )
	y2error( "ReduceLvmVg sint ret %1", ret );
    UpdateTargetMap();
    return( ret==0 );
    }

global boolean CreateLvmLv( string vgname, string lvname, integer sizeK,
                            integer stripe )
    {
    y2milestone( "CreateLvmLv vg:%1 name:%2 sizeK:%3 stripe:%4", vgname, 
                 lvname, sizeK, stripe );
    integer ret = 0;
    string dummy = "";
    ret = LibStorage::StorageInterface::createLvmLv( sint, vgname, lvname, 
                                                     (sizeK+1023)/1024, stripe,
						     dummy );
    if( ret<0 )
	y2error( "CreateLvmLv sint ret %1", ret );
    UpdateTargetMapDisk( "/dev/"+vgname );
    return( ret==0 );
    }

global boolean ChangeLvStripeSize( string vgname, string lvname, 
				   integer stripeSize )
    {
    y2milestone( "ChangeLvStripeSize vg:%1 name:%2 stripeSize:%3", vgname, 
                 lvname, stripeSize );
    integer ret = 0;
    string dummy = "";
    ret = LibStorage::StorageInterface::changeLvStripeSize( sint, vgname, 
                                                            lvname, 
							    stripeSize );
    if( ret<0 )
	y2error( "ChangeLvStripeSize sint ret %1", ret );
    UpdateTargetMapDisk( "/dev/"+vgname );
    return( ret==0 );
    }

global boolean DeleteEvmsCo( string name )
    {
    y2milestone( "DeleteEvmsCo name:%1", name );
    integer ret = LibStorage::StorageInterface::removeEvmsContainer( sint, name );
    if( ret<0 )
	y2error( "DeleteEvmsCo sint ret %1", ret );
    UpdateTargetMap();
    return( ret==0 );
    }

global boolean CreateMd( integer nr, string type )
    {
    y2milestone( "CreateMd nr:%1 type:%2", nr, type );
    integer ret = 0;
    integer tmp = conv_mdstring[type]:0;
    list<string> dummy = [];
    string rd = sformat("/dev/md%1", nr );
    ret = LibStorage::StorageInterface::createMd( sint, rd, tmp, dummy );
    if( ret<0 )
	y2error( "CreateMd sint ret %1", ret );
    UpdateTargetMapDisk( "/dev/md" );
    return( ret==0 );
    }

global boolean ExtendMd( integer nr, string dev )
    {
    y2milestone( "ExtendMd nr:%1 dev:%2", nr, dev );
    integer ret = 0;
    string rd = sformat("/dev/md%1", nr );
    ret = LibStorage::StorageInterface::extendMd( sint, rd, dev );
    if( ret<0 )
	y2error( "ExtendMd sint ret %1", ret );
    UpdateTargetMap();
    return( ret==0 );
    }

global boolean ShrinkMd( integer nr, string dev )
    {
    y2milestone( "ShrinkMd nr:%1 dev:%2", nr, dev );
    integer ret = 0;
    string rd = sformat("/dev/md%1", nr );
    ret = LibStorage::StorageInterface::shrinkMd( sint, rd, dev );
    if( ret<0 )
	y2error( "ShrinkMd sint ret %1", ret );
    UpdateTargetMap();
    return( ret==0 );
    }

global boolean ChangeMdType( integer nr, string mdtype )
    {
    y2milestone( "ChangeMdType nr:%1 mdtype:%2", nr, mdtype );
    integer ret = 0;
    string rd = sformat("/dev/md%1", nr );
    integer tmp = conv_mdstring[mdtype]:0;
    ret = LibStorage::StorageInterface::changeMdType( sint, rd, tmp );
    if( ret<0 )
	y2error( "ChangeMdType sint ret %1", ret );
    UpdateTargetMapDev( rd );
    return( ret==0 );
    }

global boolean ChangeMdParity( integer nr, string ptype )
    {
    y2milestone( "ChangeMdParity nr:%1 parity:%2", nr, ptype );
    integer ret = 0;
    string rd = sformat("/dev/md%1", nr );
    integer tmp = conv_mdstring[ptype]:0;
    ret = LibStorage::StorageInterface::changeMdParity( sint, rd, tmp );
    if( ret<0 )
	y2error( "ChangeMdParity sint ret %1", ret );
    UpdateTargetMapDev( rd );
    return( ret==0 );
    }

global boolean ChangeMdChunk( integer nr, integer chunk )
    {
    y2milestone( "ChangeMdChunk nr:%1 chunk:%2", nr, chunk );
    integer ret = 0;
    string rd = sformat("/dev/md%1", nr );
    ret = LibStorage::StorageInterface::changeMdChunk( sint, rd, chunk );
    if( ret<0 )
	y2error( "ChangeMdChunk sint ret %1", ret );
    UpdateTargetMapDev( rd );
    return( ret==0 );
    }

global integer CheckMd( integer nr )
    {
    y2milestone( "CheckMd nr:%1", nr );
    integer ret = 0;
    string rd = sformat("/dev/md%1", nr );
    ret = LibStorage::StorageInterface::checkMd( sint, rd );
    if( ret!=0 )
	y2milestone( "CheckMd sint ret %1", ret );
    return( ret );
    }

global string CreateLoop( string file, boolean create, integer sizeK,
                          string mp )
    {
    y2milestone( "CreateLoop file:%1 create:%2 sizeK:%3 mp:%4", file, create,
                 sizeK, mp );
    string dev = "";
    integer ret = -9999;
    if( haskey( ClassifiedSettings, "create_loop" ))
	{
	string pwd = ClassifiedSettings["create_loop"]:"";
	integer ret = LibStorage::StorageInterface::createFileLoop( sint, file,
								    !create,
								    sizeK,
								    mp, pwd,
								    dev );
	ClassifiedSettings = remove( ClassifiedSettings, "create_loop" );
	}
    if( ret<0 )
	y2error( "CreateLoop sint ret %1", ret );
    UpdateTargetMapDisk( "/dev/loop" );
    y2milestone( "CreateLoop dev:%1", dev );
    return( dev );
    }

global boolean DeleteLoop( string disk, string file, boolean remove_file )
    {
    y2milestone( "DeleteLoop disk:%1 file:%2 remove_file:%3", disk, file, 
                 remove_file );
    integer ret = LibStorage::StorageInterface::removeFileLoop( sint, file,
                                                                remove_file );
    if( ret<0 )
	y2error( "DeleteLoop sint ret %1", ret );
    UpdateTargetMapDisk( disk );
    return( ret==0 );
    }

global string GetCryptPwd( string device )
    {
    string pwd="";
    y2milestone( "GetCryptPwd device:%1", device );
    if( size(ClassifiedSettings[device]:"")>0 )
	pwd = ClassifiedSettings[device]:"";
    else
	{
	integer ret = 0;
	ret = LibStorage::StorageInterface::getCryptPassword( sint, device,
							      pwd );
	if( ret<0 )
	    y2error( "GetCryptPwd sint ret %1", ret );
	}
    y2milestone( "GetCryptPwd empty:%1", size(pwd)==0 );
    return( pwd );
    }

global boolean SetCryptPwd( string device, string pwd )
    {
    y2milestone( "SetCryptKey device:%1", device );
    integer ret = LibStorage::StorageInterface::setCryptPassword( sint, device,
                                                                  pwd );
    y2milestone( "SetCryptPwd sint ret %1", ret );
    if( ret==LibStorage::STORAGE_VOLUME_NOT_FOUND() )
	ClassifiedSettings[device] = pwd;
    else if( ret<0 )
	y2error( "SetCryptPwd sint ret %1", ret );
    y2milestone( "ClassifiedSettings %1", ClassifiedSettings );
    return( ret==0 );
    }


/**
 * Delete the partition table and disk label of device
 * @param string the device to be deleted
 * @return integer
 */
global define boolean DeletePartitionTable(string disk)
    ``{
    y2milestone( "DeletePartitionTable %1", disk );
    string label = LibStorage::StorageInterface::defaultDiskLabel( sint );
    y2milestone( "DeletePartitionTable label:%1", label );
    integer ret = 
	LibStorage::StorageInterface::destroyPartitionTable( sint, disk, 
	                                                     label );
    if( ret<0 ) 
	y2error( "DeletePartitionTable sint ret %1", ret );
    UpdateTargetMapDisk( disk ); 
    return( ret==0 );
    }

global define boolean CreateAny( symbol ctype, map d, map& p )
    {
    boolean ret = true;
    if( ctype == `CT_DISK )
	{
	ret = Storage::CreatePartition( d["device"]:"", p["device"]:"",
				        p["type"]:`primary, 
				        p["fsid"]:Partitions::fsid_native,
				        p["region",0]:0, p["region",1]:0 );
	}
    else if( ctype == `CT_MD )
	{
	ret = Storage::CreateMd( p["nr"]:0, p["raid_type"]:"raid1" );
	if( ret && haskey( p, "chunk_size" ))
	    Storage::ChangeMdChunk( p["nr"]:0, p["chunk_size"]:4 );
	if( ret && p["raid_type"]:""=="raid5" && 
	    haskey( p, "parity_algorithm" ))
	    Storage::ChangeMdParity( p["nr"]:0, 
	                             p["parity_algorithm"]:"" );
	foreach( string d, p["devices"]:[], 
		 ``{ret=Storage::ExtendMd( p["nr"]:0, d )&&ret;});
	}
    else if( ctype == `CT_LOOP )
	{
	string dev = Storage::CreateLoop( p["fpath"]:"", p["create_file"]:false,
					  p["size_k"]:0, p["mount"]:"" );
	ret = size(dev)>0;
	if( ret )
	    p["device"] = dev;
	}
    else if( ctype == `CT_LVM )
	{
	ret = Storage::CreateLvmLv( d["name"]:"", p["name"]:"", p["size_k"]:0, 
				    p["stripes"]:1 );
	if( ret && p["stripes"]:1>1 && p["stripesize"]:0>0 )
	    {
	    Storage::ChangeLvStripeSize( d["name"]:"", p["name"]:"",
	                                 p["stripesize"]:0 );
	    }
	}
    /* FIXME Evms 
    else if( ctype == `CT_EVMS ) */
    y2milestone( "CreateAny ret:%1", ret );
    return( ret );
    }

/**
 * Search in the list partitions for windows partitions and add the key
 * "mount" to the found windows partitions.
 * @parm partitions the partitions list
 * @parm primary handle primary or logical partitions
 * @return list new partitions with windows mountpoints
 */
define void AddMountPointsForWinParts( list<map> partitions, boolean primary, 
                                       integer max_prim, integer& foreign_nr )
    ``{
    if( !Arch::i386 () && !Arch::ia64 () && !Arch::x86_64 () )
	return;

    string foreign_ids = "CDEFGHIJKLMNOPQRSTUVW";

    list<map> new_partitions = [];

    foreach(map partition, partitions,
	``{
	map new_partition = partition;
	integer fsid      = partition["fsid"]:Partitions::fsid_native;
	integer partnum = 0;
	if( haskey( partition, "nr") && is( partition["nr"]:(any)0, integer ) )
	    {
	    partnum = partition["nr"]:0;
	    }

	if( !haskey( partition, "mount") && 
	    ((partnum<=max_prim)==primary) &&
	    Partitions::IsDosWinNtPartition(fsid) &&
	    contains( [`vfat, `ntfs], partition["used_fs"]:`none ))
	    {
	    string mntops = "users,gid=users,umask=0002";
	    string enc = LangTypicalEncoding();
	    string code = Encoding::GetCodePage(enc);
	    if( size(enc)>0 )
		{
		if( partition["used_fs"]:`none != `ntfs )
		    {
		    if( enc=="utf8" )
			mntops = mntops + ",utf8=true";
		    else
			mntops = mntops + ",iocharset=" + enc;
		    }
		else
		    mntops = mntops + ",nls=" + enc;
		}
	    if( size(code)>0 && code != "437" &&
	        partition["used_fs"]:`none!=`ntfs )
		{
		mntops = mntops + ",codepage=" + code;
		}
	    if( partition["used_fs"]:`none == `ntfs )
		{
		mntops = "ro," + mntops;
		}
	    new_partition["fstopt"] = mntops;
	    if( contains( Partitions::fsid_dostypes, fsid ))
		{
		new_partition["mount"] =
		    "/dos/" + substring (foreign_ids, foreign_nr, 1);
		foreign_nr = foreign_nr + 1;
		}
	    else
		{
		new_partition["mount"] =
		    "/windows/" + substring (foreign_ids, foreign_nr, 1);
		foreign_nr = foreign_nr + 1;
		}
	    ChangeVolumeProperties( new_partition );
	    y2milestone( "win part %1", new_partition );
	    }
	});
    };

global define void AddMountPointsForWin( map<string,map> targets )
    ``{
    y2milestone( "AddMountPointsForWin called" );
    integer foreign_nr = 0;

    foreach(string disk, map data, targets,
	``{
	AddMountPointsForWinParts( data["partitions"]:[], true, 
	                           data["max_primary"]:4, foreign_nr );
	});
    foreach(string disk, map data, targets,
	``{
	AddMountPointsForWinParts( data["partitions"]:[], false, 
	                           data["max_primary"]:4, foreign_nr );
	});
    }

/**
 * mark swap-partitions with pseudo Mountpoint swap in targetMap
 * @param target Disk map
 * @return map<string,map> modified target
 */
global define map<string,map> AddSwapMp( map<string,map> target )
    ``{
    list swaps = [];
    if( !Stage::initial() )
	swaps = SwappingPartitions();
    y2milestone( "AddSwapMp swaps %1", swaps );
    foreach(string diskdev, map disk, target,
	``{
	 disk["partitions"] = maplist(map part, disk["partitions"]:[],
				 ``{
				 if( (Stage::initial() &&
				      !Partitions::IsDosWinNtPartition(part["fsid"]:0) &&
				      part["detected_fs"]:`unknown==`swap &&
				      !part["old_swap"]:false &&
				      find( diskdev, "/dev/evms" )!=0 ) ||
				     (!Stage::initial() &&
				      contains( swaps, part["device"]:"" )))
				     {
				     part["mount"] = "swap";
				     ChangeVolumeProperties( part );
				     y2milestone( "AddSwapMp %1", part );
				     }
				 return( part );
				 });
	target[diskdev] = disk;
	});
    return( target );
    }

global define map<string,map> GetTargetMap()
    ``{
    map<string,map> tmp = $[];
    boolean changed = false;
    if( !probe_done && !Mode::config() )
	{
	y2milestone ("probing StorageDevices force:%1", force_disk_probe );
	tmp = (map<string,map>)StorageDevices::Probe(true);
	force_disk_probe = false;
	y2milestone ("probing done" );
	if( size(tmp)>0 )
	    {
	    probe_done = true;
	    lvm_initialized = true;
	    changed = true;
	    foreach( string dev, map disk, tmp,
		``{
		disk = getDiskInfo( dev, disk );
		integer s = disk["cyl_count"]:0 * disk["cyl_size"]:0;
		disk["name"] = disk["dname"]:"" + 
		   Partitions::ByteToHumanString( s ) + ", " + 
		   disk["device"]:"" + ", ";
		if( size( disk["vendor"]:"")>0 )
		    disk["name"] = disk["name"]:"" + disk["vendor"]:"" + "-";
		disk["name"] = disk["name"]:"" + disk["model"]:"";
		if( haskey( disk, "dname" ))
		    disk = remove( disk, "dname" );
		tmp[dev] = disk;
		});
	    foreach( map c, conts,
		``{
		if( c["type"]:`CT_UNKNOWN!=`CT_DISK )
		    tmp[c["device"]:""] = getContainerInfo( c );
		});
	    SCR::Write(.target.ycp, "/tmp/tmp2", tmp );
	    StorageMap[targets_key] = tmp;
	    }
	}
    if( changed )
	{
	tmp = StorageMap[targets_key]:$[];
	SCR::Write(.target.ycp, Storage::SaveDumpPath("targetMap_i"), tmp );
	y2milestone ("AddSwapMp" );
	tmp = AddSwapMp( tmp );
	CreateTargetBackup( "initial" );
	if( Stage::initial() || Mode::repair() )
	    {
	    AddMountPointsForWin( tmp );
	    }
	StorageMap[targets_key] = GetTargetMap();
	SCR::Write(.target.ycp, Storage::SaveDumpPath("targetMap_ii"), tmp );
	y2milestone ("changed done" );
	}
    return StorageMap[targets_key]:$[];
    };

global define void SetTargetMap( map<string,map> target )
    {
    SCR::Write(.target.ycp, Storage::SaveDumpPath("targetMap_set_"+sformat("%1",count)), target );
    count = count+1;
    integer old_change_time = StorageMap["targets_time"]:0;
    CreateTargetBackup("tmp_set");
    map<string,map> tg = GetTargetMap();
    list<string> keys = maplist( string k, any e, tg, ``(k));
    keys = sort( string a, string b, keys, 
                 ``( type_order[tg[a,"type"]:`CT_UNKNOWN]:6 >
		     type_order[tg[b,"type"]:`CT_UNKNOWN]:6 ));
    y2milestone( "SetTargetMap keys %1", keys );
    foreach( string k, keys,
	``{
	list<map> dps = filter( map p, tg[k,"partitions"]:[], 
	                        ``(p["create"]:false));
	if( size(dps)>0 && haskey( dps[0]:$[], "nr" ))
	    {
	    y2milestone( "SetTargetMap dps:%1", dps );
	    dps = sort( map a, map b, dps, ``(a["nr"]:0>b["nr"]:0));
	    y2milestone( "SetTargetMap dps:%1", dps );
	    }
	foreach( map p, dps, ``{DeleteDevice( k, p["device"]:"" );});
	if( tg[k,"create"]:false )
	    {
	    if( tg[k,"type"]:`CT_UNKNOWN==`CT_LVM )
		DeleteLvmVg( tg[k,"name"]:"" );
	    else if( tg[k,"type"]:`CT_UNKNOWN==`CT_EVMS )
		DeleteEvmsCo( tg[k,"name"]:"" );
	    }
	});
    keys = maplist( string k, any e, target, ``(k));
    keys = sort( string a, string b, keys, 
                 ``( type_order[target[a,"type"]:`CT_UNKNOWN]:6 >
		     type_order[target[b,"type"]:`CT_UNKNOWN]:6 ));
    y2milestone( "SetTargetMap keys %1", keys );
    foreach( string k, keys,
	``{
	list<map> dps = filter( map p, target[k,"partitions"]:[], 
	                        ``(p["delete"]:false));
	if( size(dps)>0 && haskey( dps[0]:$[], "nr" ))
	    {
	    dps = sort( map a, map b, dps, ``(a["nr"]:0>b["nr"]:0));
	    }
	foreach( map p, dps, ``{DeleteDevice( k, p["device"]:"" );});
	if( target[k,"delete"]:false )
	    {
	    if( target[k,"type"]:`CT_UNKNOWN==`CT_LVM )
		DeleteLvmVg( target[k,"name"]:"" );
	    else if( target[k,"type"]:`CT_UNKNOWN==`CT_EVMS )
		DeleteEvmsCo( target[k,"name"]:"" );
	    }
	});
    keys = maplist( string k, any e, target, ``(k));
    keys = sort( string a, string b, keys, 
                 ``( type_order[target[a,"type"]:`CT_UNKNOWN]:6 <
		     type_order[target[b,"type"]:`CT_UNKNOWN]:6 ));
    y2milestone( "SetTargetMap keys %1", keys );
    foreach( string k, keys,
	``{
	if( !target[k,"delete"]:false && target[k,"create"]:false )
	    {
	    if( target[k,"type"]:`CT_UNKNOWN==`CT_LVM )
		{
		CreateLvmVg( target[k,"name"]:"", target[k,"pesize"]:0,
		             target[k,"lvm2"]:true );
		list<string> ls = 
		    (list<string>)union( target[k,"devices"]:[],
				         target[k,"devices_add"]:[] );
		foreach( string d, ls,
			 ``{Storage::ExtendLvmVg( target[k,"name"]:"", d );});
		}
	    /* FIXME Evms 
	    else if( target[k,"type"]:`CT_UNKNOWN==`CT_EVMS )
		CreateEvmsCo( target[k,"name"]:"", target[k,"pesize"]:0,
		              target[k,"lvm2"]:true ); */
	    }
	list<map> dps = filter( map p, target[k,"partitions"]:[], 
	                        ``(!p["delete"]:false) );
	if( size(dps)>0 && haskey( dps[0]:$[], "nr" ))
	    dps = sort( map a, map b, dps, ``(a["nr"]:0<b["nr"]:0));
	foreach( map p, dps,
	    ``{
	    if( p["create"]:false )
		{
		CreateAny( target[k,"type"]:`CT_UNKNOWN, target[k]:$[], p );
		}
	    ChangeVolumeProperties( p );
	    });
	});
    boolean changed = !EqualBackupStates( "tmp_set", "", true );
    y2milestone( "SetTargetMap changed:%1", changed );
    if( !changed )
	StorageMap["targets_time"] = old_change_time;
    DisposeTargetBackup("tmp_set");
    };

global define map<string,map> ReReadTargetMap()
    ``{
    y2milestone("start reread");
    probe_done = false;
    lvm_initialized = false;
    if( sint != nil )
	LibStorage::destroyStorageInterface (sint);
    sint = createInterface();
    conts = getContainers();
    force_disk_probe = true;
    return GetTargetMap();
    };

global integer CommitChanges()
    {
    y2milestone( "CommitChanges" );
    integer ret = LibStorage::StorageInterface::commit( sint );
    if( ret<0 )
	y2error( "CommitChanges sint ret %1", ret );
    return( ret );
    }

global string DeviceMounted( string dev )
    {
    string ret = "";
    LibStorage::StorageInterface::checkDeviceMounted( sint, dev, ret );
    if( size(ret)>0 )
	y2milestone( "DeviceMounted %1 at %2", dev, ret );
    return( ret );
    }

global boolean Umount( string dev )
    {
    boolean ret = LibStorage::StorageInterface::umountDevice( sint, dev );
    y2milestone( "Umount %1 ret %2", dev, ret );
    return( ret );
    }

global boolean Mount( string dev, string mp )
    {
    boolean ret = LibStorage::StorageInterface::mountDevice( sint, dev, mp );
    y2milestone( "Mount %1 to %2 ret %3", dev, mp, ret );
    return( ret );
    }

global list<map> mountedPartitionsOnDisk( string disk )
    {
    map<string,any> d = GetDisk( GetTargetMap(), disk );
    list<map> ret = filter( map p, d["partitions"]:[], 
                            ``(size(DeviceMounted(p["device"]:""))>0));
    return( ret );
    }

global string ChangeText()
    {
    list<string> l = LibStorage::StorageInterface::getCommitActions( sint, true );
    string ret = "";
    if( size(l)>0 )
	ret = HTML::List( l );
    return( ret );
    }

global string LastAction()
    {
    string ret = LibStorage::StorageInterface::getLastAction( sint );
    return( ret );
    }

global void SetZeroNewPartitions( boolean val )
    {
    y2milestone( "SetZeroNewPartitions val:%1", val );
    LibStorage::StorageInterface::setZeroNewPartitions( sint, val );
    }

/* GetMountPoints()
 * collect mountpoint:device as map to get a sorted list
 * @returns: map of lists, the map key is the mount point,
 *		usually starting with a "/". Exception is "swap"
 *	For directory mount points (key starting with /) the value
 *  is a list [partitionName, fsid, targetdevice, raid_type]
 *  For swap mount points, the value is a list of lists:
 *  [[partitionName, fsid, targetdevice, raid_type], ...]
 *
 */
global define map GetMountPoints()
    ``{
    map mountPoints = $[];
    list swapPoints = [];
    map<string,map> tg = GetTargetMap();
    foreach ( string targetdevice, map target, tg,
	``{
	list<map> partitions = target["partitions"]:[];
	foreach (map partition, partitions,
	    ``{
	    string partitionName =
		GetDeviceName( targetdevice, partition["nr"]:(any)0);
	    string mountPoint = partition["mount"]:"";
	    integer fsid = partition["fsid"]:0;
	    if (mountPoint != "")
		{
		string raid_type = "";
		if( partition["type"]:`undefined == `sw_raid )
		    {
		    raid_type = partition["raid_type"]:"";
		    }
		// partition has a mount point
		if (mountPoint == "swap")
		    {
		    swapPoints = add( swapPoints,
				      [partitionName, fsid, targetdevice, raid_type]);
		    }
		else
		    {
		    mountPoints = add( mountPoints, mountPoint,
		                       [partitionName, fsid, targetdevice, raid_type]);
		    }
		}
	    });
	});
    if (size (swapPoints) > 0)
	mountPoints = add (mountPoints, "swap", swapPoints);
    if( !Stage::initial () )
	{
	list<map> cm = filter(map e, Partitions::CurMounted(),
			      ``(find(e["spec"]:"","/dev/")==0));
	foreach(map e, cm,
	    ``{
	    if( !haskey( mountPoints, e["file"]:"" ) )
		{
		map p = GetPartition( tg, e["spec"]:"" );
		if( size(p)>0 )
		    {
		    string raid_type = "";
		    if( p["type"]:`undefined == `sw_raid )
			{
			raid_type = p["raid_type"]:"";
			}
		    map d = GetDiskPartition( e["spec"]:"" );
		    mountPoints[e["file"]:""] =
			[ p["device"]:"", p["fsid"]:0, d["disk"]:"", raid_type ];
		    }
		}
	    });
	}
    y2milestone( "ret %1", mountPoints );
    return mountPoints;
    }

global define string
GetIdSmaller( string disk, integer delim )
    ``{
    string ret = disk;
    map<string,map> tg = GetTargetMap();
    list<map> ps = filter( map p, tg[disk,"partitions"]:[], ``(p["nr"]:0<delim));
    ps = sort( map a, map b, ps, ``(a["nr"]:(any)0>b["nr"]:(any)0));
    if( size(ps)>0 )
	ret = GetSubDevKey( disk, ps[0,"nr"]:(any)0 );
    y2milestone( "GetIdSmaller disk:%1 delim:%2 ret:%3",
                 disk, delim, ret );
    return( ret );
    }


/* set <key> in partition <device> to the given <value> and return changed map <tg> */
global define map<string,map> SetPartitionData( map<string,map> tg, 
                                                string device, string key, 
						any value )
    ``{
    y2milestone( "SetPartitionData device=%1 key=%2 value=%3", device, key, 
                 value );
    map tmp = GetDiskPartition( device );
    string disk = tmp["disk"]:"";
    list r_part = filter(map part, tg[disk,"partitions"]:[],
			  ``(part["device"]:"" != device ));
    if( size(r_part)!=size(tg[disk,"partitions"]:[]) )
	{
	map p = filter( map part, tg[disk,"partitions"]:[],
		        ``(part["device"]:"" == device ))[0]:$[];
	if( size(p)>0 )
	    {
	    p[key] = value;
	    r_part    = add( r_part, p );
	    tg[disk,"partitions"] = r_part;
	    }
	}
    return( tg );
    }

/* remove <key> in partition <device> and return changed map <tg> */
global define map<string,map> DelPartitionData( map<string,map> tg, 
                                                string device, string key)
    ``{
    y2debug( "device=%1, key=%2", device, key );
    map tmp = GetDiskPartition( device );
    string disk = tmp["disk"]:"";
    list r_part = filter(map part, tg[disk,"partitions"]:[],
			  ``(part["device"]:"" != device ));
    if( size(r_part)!=size(tg[disk,"partitions"]:[]) )
	{
	map p = filter( map part, tg[disk,"partitions"]:[],
			``(part["device"]:"" == device ))[0]:$[];
	if( size(p)>0 )
	    {
	    p = filter(string k, any e, (map<string,any>)p, ``(k != key) );
	    r_part    = add( r_part, p );
	    tg[disk,"partitions"] = r_part;
	    }
	}
    return( tg );
    }





    /* maindevkey = all | maindevkey
       what = "all"		|
              "assigned_raid"	| "assigned_vg"  | "not_assigned" | "assigned"
	      "delete" | "no_delete"
	      "edit_possible"	| "delete_possible" |
	      "display_possible" |
	      "assign_raid_possible" | "assign_vg_possible"
	      "no_virtal" 	| "virtual"
      how = "all"	| "key_list"  | "index_list" (   raid_lib -> get_possible_rds  )
    */




/* Contain the current key ( subdevkey ) for all wizards */
string WizardKey = "";

global define string GetWizardKey()
    ``{
	y2debug( " Return wizard key %1", WizardKey);
	return WizardKey;
    };

global define void SetWizardKey( string key )
    ``{
    y2debug(" Set WizardKey %1", WizardKey);
    WizardKey = key;
    };


    /* Functions for testing */

    global define void DebugStorage()``{

	y2milestone("StorageMaps: %1",StorageMaps);
	y2milestone("Storage:%1",StorageMap);
    }


/**
 * Check if a disk is a real disk and not RAID or LVM
 * @return boolean true if real disk
 */
global define boolean IsRealDisk( map entry )
    ``{
    return( entry["type"]:`CT_UNKNOWN==`CT_DISK );
    }

global define boolean DeviceRealDisk( string device )
    ``{
    boolean ret = false;
    
    if( find( device, "LABEL" )!=0 && find( device, "UUID" )!=0 )
	{
	map dev = $[];
	dev = GetDiskPartition( device );
	ret = dev["disk"]:"" != "/dev/md" && dev["disk"]:"" != "/dev/loop" &&
	      find( dev["disk"]:"", "/dev/evms")!=0 &&
	      is( dev["nr"]:(any)0, integer );
	if( !ret )
	    {
	    map st = (map)SCR::Read( .target.stat, dev["disk"]:"" );
	    ret = !st["isdir"]:false;
	    }
	}
    y2milestone( "DeviceRealDisk %1 ret %2", device, ret );
    return ret;
    }

/**
  * Determine if there is any Linux partition on this system.
  *
  * If there is none, we don't need to ask if the user wants to update or
  * boot an installed system - he can only do a new installation anyway.
  * No time-consuming or dangerous operations should be performed here,
  * only simple checks for existence of a Linux (type 83) partition.
  *
  * @return boolean true if there is anything that might be a Linux partition
  **/
global define boolean HaveLinuxPartitions() ``{
    boolean ret = false;
    foreach ( string dev, map disk, GetTargetMap(), ``{
        if( !ret )
	    {
	    if( IsRealDisk( disk ) )
		{
		foreach( map e, disk["partitions"]:[], ``{
		    ret = ret ||
			  Partitions::IsLinuxPartition( e["fsid"]:Partitions::fsid_native );
		    });
		}
	    }
	});
    y2milestone( "HaveLinuxPartitions ret=%1", ret );
    return( ret );
    };

/**
 * Get list of all Partitions on all real disks
 * @return list Partition list
 */
global define list GetPartitionList()``{
    list ret = [];
    foreach ( string dev, map disk, GetTargetMap(), ``{
        if( IsRealDisk( disk ) )
	    {
	    list<map> l = disk["partitions"]:[];
	    ret = union( ret, maplist( map p, l,
				       ``(GetDeviceName(dev,p["nr"]:(any)0))));
	    }
	});
    ret = sort( ret );
    y2debug( "GetPartitionList ret=%1", ret );
    return( ret );
    }

/**
 * Get list of all Linux Partitions on all real disks
 * @return list Partition list
 */
global define list GetOtherLinuxPartitions()``{
    list ret = [];
    foreach ( string dev, map disk, GetTargetMap(), ``{
        if( IsRealDisk( disk ) )
	    {
	    list<map> l = (list<map>) filter( map p, disk["partitions"]:[],
	                     ``(!p["format"]:false &&
			        Partitions::IsLinuxPartition(p["fsid"]:0)) );
	    l = filter(map p, l, ``(contains( [`xfs, `ext2, `ext3, `jfs, `reiser],
	                                    p["used_fs"]:`unknown)));
	    l = filter(map p, l,
			``(!FileSystems::IsSystemMp( p["mount"]:"", false )));
	    if( size(l)>0 )
		{
		ret = union( ret, l );
		}
	    }
	});
    y2milestone( "GetOtherLinuxPartitions ret=%1", ret );
    return( ret );
    }

/**
 * Check if swap paritition is availbe on a disk
 * @param disk Disk to be checked
 * @return boolean true if swap available.
 */
global define boolean CheckSwapOn( string disk )``{
    boolean ret = false;
    list swaps = SwappingPartitions();
    while( size(swaps)>0 && !ret )
	{
	if( find( swaps[0]:"", disk )==0)
	    {
	    ret = true;
	    }
	swaps = remove( swaps, 0 );
	}
    y2milestone( "CheckSwapOn %1 ret %2", disk, ret );
    return( ret );
    }

global define string CheckSwapConflicts()``{
    string ret = "";
    list swaps = SwappingPartitions();
    if( size(swaps)>0 )
	{
	list plist = [];
	foreach ( string dev, map disk, GetTargetMap(), ``{
	    if( IsRealDisk( disk ) )
		{
		list<map> l = disk["partitions"]:[];
		l = filter(map p, l, ``(size(p["mount"]:"")>0 ||
				        p["used_by_type"]:`UB_NONE != `UB_NONE ));
		l = filter(map p, l, ``(p["mount"]:"" != "swap") );
		list l1 = maplist(map p, l, ``(GetDeviceName(dev,p["nr"]:(any)0)));
		plist = union( plist, l1 );
		}
	    });
	y2milestone( "CheckSwapConflicts used %1", plist );
	while( size(swaps)>0 && size(ret)==0 )
	    {
	    if( contains( plist, swaps[0]:"" ) )
		{
		ret = swaps[0]:"";
		}
	    swaps = remove( swaps, 0 );
	    }
	}
    y2milestone( "CheckSwapConflicts ret %1", ret );
    return( ret );
    }

global define list GetWinPrimPartitions( map<string,map> targets )
    ``{
    list<map> ret = [];
    map entry = $[];
    string text = "";
    integer num_dos = 0;
    integer num_win = 0;
    integer num_os2 = 0;
    integer num_linux = 0;
    string linux_text = "Linux other";
    string dos_text = "dos";
    string win_text = "windows";
    string os2_text = "OS/2 Boot Manager";

    foreach(string disk, map data, targets,
	``{
	foreach(map part, data["partitions"]:[],
	    ``{
	    string device = GetDeviceName( disk, part["nr"]:(any)0 );
	    if( part["type"]:`unknown == `primary &&
	        SCR::Execute (.target.bash,
		              "/usr/lib/YaST2/bin/check.boot "+device) == 0)
		{
		text = "";
	        if( Partitions::IsDosWinNtPartition( part["fsid"]:0 ) &&
		    GetFreeSpace( device, 0, part["used_fs"]:`none, false )["win_disk"]:false )
		    {
		    if( contains( Partitions::fsid_dostypes, part["fsid"]:0 ) )
			{
			num_dos = num_dos+1;
			text = dos_text;
			}
		    else
			{
			num_win = num_win+1;
			text = win_text;
			}
		    }
		else if( part["fsid"]:0 == 0x12 )
		    {
		    text = "Vendor diagnostic";
		    }
		else if( part["fsid"]:0 == 0x0a )
		    {
		    text = os2_text;
		    num_os2 = num_os2+1;
		    }
		else if( part["fsid"]:0 == Partitions::fsid_native &&
		         size(part["mount"]:"")==0 )
		    {
		    text = linux_text;
		    num_linux = num_linux+1;
		    }
		if( size(text)>0 )
		    {
		    entry["device"] = device;
		    entry["string"] = text;
		    ret = add( ret, eval(entry) );
		    y2milestone( "new entry %1", entry );
		    }
		}
	    });
	});
    y2milestone( "GetWinPrimPartitions num_linux %1 num_win %2 num_dos %3 num_os2 %4",
                 num_linux, num_win, num_dos, num_os2 );
    integer num = 1;
    if( num_linux>1 )
	{
	ret = maplist( map entry, ret, 
	    ``{
	    if( entry["string"]:""==linux_text )
		{
		entry["string"] = linux_text + sformat( " %1", num );
		num = num+1;
		}
	    return( entry );
	    });
	}
    num = 1;
    if( num_dos>1 )
	{
	ret = maplist( map entry, ret, 
	    ``{
	    if( entry["string"]:""==dos_text )
		{
		entry["string"] = dos_text + sformat( " %1", num );
		num = num+1;
		}
	    return( entry );
	    });
	}
    num = 1;
    if( num_win>1 )
	{
	ret = maplist( map entry, ret, 
	    ``{
	    if( entry["string"]:""==win_text )
		{
		entry["string"] = win_text + sformat( " %1", num );
		num = num+1;
		}
	    return( entry );
	    });
	}
    num = 1;
    if( num_os2>1 )
	{
	ret = maplist( map entry, ret, 
	    ``{
	    if( entry["string"]:""==os2_text )
		{
		entry["string"] = os2_text + sformat( " %1", num );
		num = num+1;
		}
	    return( entry );
	    });
	}
    y2milestone( "GetWinPrimPartitions ret %1", ret );
    return( ret );
    }

global define list<string> AddPackageList()
    ``{
    list<string> pl = [];
    boolean mount_lvm = false;
    boolean need_evms = false;
    map<string,map> tg = GetTargetMap();
    map<string,map> tt = filter( string k, map e, tg, 
                                 ``(e["type"]:`CT_UNKNOWN==`CT_LVM ));
    boolean have_lvm = size(tt)>0;
    if( have_lvm )
	{
	list<map> part = [];
	foreach( string k, map e, tt,
		 ``{
		 part = (list<map>)merge( part, e["partitions"]:[]);
		 });
	mount_lvm = size(filter( map p, part, ``(size(p["mount"]:"")>0)))>0; 
	}
    tt = filter( string k, map e, tg, ``(find(k, "/dev/evms/")==0));
    if( size(filter( string k, map e, tg, ``(e["is_container"]:false &&
					     find(e["name"]:"","lvm/")!=0)))>0)
	{
	y2milestone( "non lvm evms container" );
	need_evms = true;
	}
    if( !need_evms )
	{
	list<map> part = [];
	foreach( string k, map e, tt,
		 ``{
		 part = (list<map>)merge( part, e["partitions"]:[]);
		 });
	need_evms = size(filter( map p, part, ``(size(p["mount"]:"")>0)))>0; 
	}
    y2milestone( "AddPackageList have_lvm %1 mount_lvm %2 need_evms %3", 
                  have_lvm, mount_lvm, need_evms );
    if( have_lvm && (mount_lvm||!need_evms))
	{
	pl = add( pl, "lvm2" );
	}
    if( need_evms )
	{
	pl = add( pl, "evms" );
	}
    y2milestone( "AddPackageList ret %1", pl );
    return( pl );
    }

global define list GetForeignPrimary()
    ``{
    list ret = [];
    if( Arch::i386 () || Arch::ia64 () || Arch::x86_64 () )
	{
	foreach(map e, (list<map>)GetWinPrimPartitions( GetTargetMap() ),
	    ``{
	    ret = add( ret, sformat( "%1 %2", e["device"]:"", e["string"]:"" ));
	    });
	}
    y2milestone( "ret=%1", ret );
    return( ret );
    }

global define map IsResizable( map part )
    ``{
    map ret = FileSystems::IsResizable(`unknown);
    if( !Arch::s390 () &&
        (part["type"]:`none==`lvm || Partitions::IsResizable( part["fsid"]:0 )))
	{
	if( part["fsid"]:0==Partitions::fsid_swap )
		{
	    ret = FileSystems::IsResizable(`swap);
		}
	else
		{
	    ret = FileSystems::IsResizable(part["used_fs"]:`unknown);
		}
	}
    y2milestone( "IsResizable part:%1 ret:%2", part, ret );
    return( ret );
    }

global define integer FreeCylAfter( map disk, map partition )
    ``{
    integer ret = 0;
    integer next_used_cyl = disk["cyl_count"]:0;
    integer cylinder = partition["region",0]:0;
    if( haskey( partition, "ori_length" ))
	{
        cylinder = cylinder + partition["ori_length"]:0;
        }
    else
	{
        cylinder = cylinder + partition["region",1]:0;
        }
    if( partition["type"]:`primary == `logical )
	{
	map ext = filter( map part, disk["partitions"]:[],
			  ``( part["type"]:`primary==`extended ))[0]:$[];
	next_used_cyl = ext["region",0]:0+ext["region",1]:0;
	}
    if( cylinder < next_used_cyl )
	{
	foreach(map part, disk["partitions"]:[], ``{
	    integer start = part["region",0]:0;
	    if( start >= cylinder && start < next_used_cyl )
		{
		next_used_cyl = start;
		}
	    });
	}
    if( next_used_cyl >= cylinder )
	ret = next_used_cyl-cylinder;
    y2milestone( "FreeCylAfter cyl:%1 ret:%2", cylinder, ret );
    return( ret );
    }

global define boolean CheckNextCreated( map disk, list region )
    ``{
    boolean ret = false;
    integer cylinder = region[0]:0 + region[1]:0;
    foreach(map part, disk["partitions"]:[], ``{
	if( part["region",0]:0 == cylinder && part["create"]:false )
	    {
	    ret = true;
	    }
	});
    y2milestone( "CheckNextCreated region:%1 ret:%2", region, ret );
    return( ret );
    }

global define string PathToDestdir( string pt )
    ``{
    if( Installation::scr_destdir != "/" )
	{
	pt = Installation::scr_destdir + pt;
	}
    return( pt );
    }

//-----------------------------------------------------
//
// change an entry in /etc/fstab
//
global define void ChangeLineFstab( map entry )
    ``{
    string tabpath = PathToDestdir( "/etc/fstab" );
    if( Installation::scr_destdir != "/" )
	{
	if( SCR::Read( .target.size, tabpath )>= 0 )
	    SCR::Execute( .target.remove, tabpath );
	}
    map fstab = Partitions::GetFstab( tabpath );
    list lines = Storage::FindFstabLines( fstab, entry["mount"]:"",
                                          entry["spec"]:"", "x", "x" );
    list fstlist = [ entry["spec"]:"", entry["mount"]:"",
		     entry["vfstype"]:"", entry["mntops"]:"",
		     sformat("%1",entry["freq"]:0),
		     sformat("%1",entry["passno"]:0) ];
    y2milestone( "lines %1", lines );
    if( size(lines)==0 )
	{
	AsciiFile::AppendLine( fstab, fstlist );
	}
    else
	{
	integer field = 0;
	while( field<4 )
	    {
	    AsciiFile::ChangeLineField( fstab, lines[0]:-1, field,
					fstlist[field]:"" );
	    field = field+1;
	    }
	}
    string dir = entry["mount"]:"";
    if( substring( dir, 0, 1 )== "/" )
	{
	dir = PathToDestdir( dir );
	if( SCR::Read( .target.size, dir )<=0 )
	    {
	    SCR::Execute( .target.mkdir, dir );
	    }
	}
    AsciiFile::RewriteFile( fstab, tabpath );
    };

global define map MakeCdromFstabEntry( map cd )
    ``{
    map entry = FileSystems::GetFstabDefaultMap( "cdrom" );
    string cdmount = cd["linkname"]:"";
    entry["spec"] = cdmount;
    entry["mount"] = "/media/"+substring(cdmount,5);
    string enc = Storage::LangTypicalEncoding();
    if( !contains( [ "iso8859-1", "iso8859-15", "" ], enc ))
	{
	entry["mntops"] = entry["mntops"]:"" + ",iocharset=" + enc;
	}
    y2milestone( "ret %1", entry );
    return( entry );
    };

define void HandleModulesOnBoot( map<string,map> targetMap )
    ``{
    list<string> ml = filter( string e, 
                              (list<string>) splitstring( Misc::SysconfigRead( .sysconfig.kernel.MODULES_LOADED_ON_BOOT, "" ), " \t"), 
			      ``(size(e)>0));
    y2milestone( "HandleModulesOnBoot ml %1", ml );
    boolean need_cryptoloop = false;
    boolean need_fish2 = false;
    foreach( string disk, map e, targetMap,
	``{
	foreach( map p, e["partitions"]:[],
	    ``{
	    if( p["noauto"]:false && p["enc_type"]:`none!=`none )
		{
		if( p["enc_type"]:`none == `twofish )
		    need_cryptoloop = true;
		else if( p["enc_type"]:`none == `twofish_old || 
		         p["enc_type"]:`none == `twofish_256_old )
		    need_fish2 = true;
		}
	    });
	});
    y2milestone( "HandleModulesOnBoot need_fish2 %1 need_cryptoloop %2", need_fish2,
                 need_cryptoloop );
    if( need_fish2 && find( string e, ml, ``(e=="loop_fish2"))==nil )
	{
	ml = add( ml, "loop_fish2" );
	SCR::Write( .sysconfig.kernel.MODULES_LOADED_ON_BOOT,
		    mergestring( ml, " " ) );

	}
    if( need_cryptoloop && find( string e, ml, ``(e=="cryptoloop"))==nil )
	{
	ml = add( ml, "cryptoloop" );
	SCR::Write( .sysconfig.kernel.MODULES_LOADED_ON_BOOT,
		    mergestring( ml, " " ) );
	}
    if( need_cryptoloop && find( string e, ml, ``(e=="twofish"))==nil )
	{
	ml = add( ml, "twofish" );
	SCR::Write( .sysconfig.kernel.MODULES_LOADED_ON_BOOT,
		    mergestring( ml, " " ) );

	}
    }

global define integer AddFstabEntry( map e )
    {
    y2milestone( "AddFstabEntry entry:%1", e );
    integer ret = 0;
    integer freq = e["freq"]:0;
    integer passno = e["passno"]:0;
    string dev = e["spec"]:"";
    string m = e["mount"]:"";
    string vfs = e["vfstype"]:"auto";
    string opts = e["mntops"]:"defaults";
    ret = LibStorage::StorageInterface::addFstabEntry( sint, dev, m, vfs, opts,
						       freq, passno );
    if( ret<0 )
	y2error( "ret:%1 entry:%2", ret, e );
    return( ret );
    }

global define void WriteFstab()
    ``{
    y2milestone( "WriteFstab called" );
    StorageDevices::MakeCDLinks();
    Storage::AddFstabEntry( FileSystems::GetFstabDefaultMap( "proc" ) );
    Storage::AddFstabEntry( FileSystems::GetFstabDefaultMap( "sys" ) );
    if( Hotplug::haveUSB )
	Storage::AddFstabEntry( FileSystems::GetFstabDefaultMap( "usb" ) );
    Storage::AddFstabEntry( FileSystems::GetFstabDefaultMap( "pts" ) );

    integer num = 1;
    map<string,map> tg = GetTargetMap();
    map m = FileSystems::GetFstabDefaultMap( "data" );
    foreach( string t, map disk, tg,
	``{
	if( disk["type"]:`CT_UNKNONW==`CT_DISK && !Arch::s390() )
	    {
	    foreach( map p, disk["partitions"]:[],
		``{
		if( contains( [ `primary, `logical ], p["type"]:`primary ) &&
		    p["fsid"]:0 == Partitions::fsid_native &&
		    !contains( [ `unknown, `swap ], p["detected_fs"]:`unknown ))
		    {
		    m["mount"] = sformat( "/data%1", num );
		    m["spec"] = p["device"]:"";
		    Storage::AddFstabEntry( m );
		    num = num+1;
		    }
		});
	    }
	});

    foreach( map cd, StorageDevices::cddrives, 
	``{
	m = Storage::MakeCdromFstabEntry( cd );
	Storage::AddFstabEntry( m );
	});

    num = 0;
    foreach( string tdevice, any tdata, StorageDevices::ZipDrives,
	``{
	m = FileSystems::GetFstabDefaultMap( "zip" );
	string zfile = "/zip";
	if( num > 0 )
	    zfile = zfile + sformat( "%1", num );
	m["mount"] = "/media"+zfile;
	m["spec"] = tdevice+"4";
	Storage::AddFstabEntry( m );
	num = num+1;
	});
    num = 0;
    foreach( map drive, StorageDevices::FloppyDrives,
	``{
	m = FileSystems::GetFstabDefaultMap( "floppy" );
	string fdname = "/floppy";
	if( num > 0 )
	    fdname = fdname + sformat( "%1", num );
	m["mount"] = "/media"+fdname;
	m["spec"] = drive["dev_name"]:"";
	Storage::AddFstabEntry( m );
	num = num+1;
	});
    HandleModulesOnBoot( tg );
    }

global define map<string,map> SpecialBootHandling( map<string,map> tg )
    ``{
    boolean have_ppc_boot = false;
    foreach( string dev, map disk, tg,
	``{
	foreach(map part, disk["partitions"]:[],
	    ``{
	    if( !have_ppc_boot &&
	        part["fsid"]:0 == Partitions::fsid_prep_chrp_boot &&
		size(part["mount"]:"")==0 && part["create"]:false )
		{
		have_ppc_boot = true;
		}
	    });
	});
    y2milestone( "SpecialBootHandling: have_ppc_boot:%1", have_ppc_boot );
    foreach( string dev, map disk, tg,
	``{
	list new_part = [];
	foreach(map part, disk["partitions"]:[],
	    ``{
	    // convert a mount point of /boot to a 41 PReP boot partition
	    if( Partitions::PrepBoot() && 
		part["mount"]:"" == Partitions::BootMount() && !have_ppc_boot )
		{
		integer id = Partitions::fsid_prep_chrp_boot;
		part["format"] = false;
		part["mount"] = "";
		part["fstype"] = Partitions::FsIdToString( id );
		part["prep_install"] = true;
		if( !part["create"]:false && part["fsid"]:0 != id )
		    {
		    part["ori_fsid"] = part["fsid"]:0;
		    part["change_fsid"] = true;
		    }
		part["fsid"] = id;
		y2milestone( "modified Prep part=%1", part );
		}
	    if( Arch::board_mac () && 
		part["mount"]:"" == Partitions::BootMount() )
		{
		integer id = Partitions::fsid_mac_hfs;
		part["mount"] = "";
		part["fstype"] = Partitions::FsIdToString( id );
		part["fsid"] = id;
		part["used_fs"] = `hfs;
		part["detected_fs"] = `hfs;
		y2milestone( "modified hfs part=%1", part );
		}
	    if( Arch::ia64 () && 
		part["mount"]:"" == Partitions::BootMount() )
		{
		integer id = Partitions::fsid_gpt_boot;
		part["fsid"] = id;
		part["fstype"] = Partitions::FsIdToString( id );
		if( !part["create"]:false && part["detected_fs"]:`none==`vfat )
		    {
		    part["format"] = false;
		    }
		y2milestone( "modified GPT boot part=%1", part );
		}
	    new_part = add( new_part, part );
	    });
	tg[dev,"partitions"] = new_part;
	});
    return( tg );
    }

global define list<list<string> > AutodetectMultipathRaid( map<string,map> tg )
    ``{
    list<list<string> > ret = [];
    map<string, list> disks = (map<string, list>) $[];
    foreach(string dev, map disk, tg,
	``{
	string id = disk["unique"]:"";
	integer pos = find( id, "." );
	if( pos >= 0 )
	    {
	    id = substring( id, pos+1 );
	    if( haskey( disks, id ) )
		{
		disks[id] = add( disks[id]:[], dev );
		}
	    else
		{
		disks[id] = [ dev ];
		}
	    }
	});
    disks = (map<string, list>) filter(string key, list entry, disks, ``(size(entry)>=2) );
    y2milestone( "disks %1", disks );
    foreach( string key, list entry, disks,
	``{
	foreach(map p, tg[entry[0]:"","partitions"]:[],
	    ``{
	    boolean ok = true;
	    list<string> dl = [];
	    foreach(string disk, (list<string>)entry,
		``{
		string dev = GetDeviceName( disk, p["nr"]:(any)0 );
		map p1 = GetPartition( tg, dev );
		if( p1["type"]:`primary == `extended ||
		    p1["used_by_type"]:`UB_NONE!=`UB_NONE ||
		    size(p1["mount"]:"")>0 )
		    {
		    ok = false;
		    }
		dl = add( dl, dev );
		});
	    if( ok )
		{
		ret = add( ret, dl );
		}
	    });
	});
    y2milestone( "ret %1", ret );
    return( ret );
    }

global define boolean PerformLosetup( map& loop, boolean format )
    ``{
    boolean crypt_ok = false;
    string pwd = loop["passwd"]:"";
    loop = (map)filter( string k, any val, (map<string,any>)loop, ``(k!="passwd"));
    y2milestone( "PerformLosetup format %1 loop %2", format, loop );

    string tmpf = SaveDumpPath( "tmpf" );
    y2milestone( "PerformLosetup tmpf %1", tmpf );
    SCR::Write( .target.string, tmpf, pwd );

    string cmd = FileSystems::GetLosetupCmd( loop, tmpf );
    map r = (map)SCR::Execute( .target.bash_output, cmd );
    y2milestone( "PerformLosetup r %1", r );
    crypt_ok = r["exit"]:1 == 0;
    if( crypt_ok && !format && find( loop["encryption"]:"", "twofish")==0 )
	{
	string enc = FileSystems::DetectLoopEncryption( loop, tmpf );
	y2milestone( "PerformLosetup enc %1", enc );
	if( size(enc)>0 )
	    {
	    loop["encryption"] = enc;
	    crypt_ok = true;
	    }
	}
    SCR::Execute( .target.remove, tmpf );
    y2milestone( "PerformLosetup ret %1", crypt_ok );
    return( crypt_ok );
    }

global define boolean DiskmapNeeded()
    ``{
    boolean ret = false;
    map<string,map> real_disks = filter( string k, map e, GetTargetMap(), ``(IsRealDisk( e )) );
    list<string> disks = (list<string>) maplist( string k, map e, real_disks, ``(k));
    y2milestone( "disks %1", disks );
    boolean scsi_disk = false;
    boolean ide_disk = false;
    foreach( string k, disks,
	``{
	if( find( k, "/dev/sd" )==0 )
	    {
	    scsi_disk = true;
	    }
	else if( find( k, "/dev/hd" )==0 )
	    {
	    ide_disk = true;
	    }
	else
	    {
	    ret = true;
	    }
	});
    ret = ret || (scsi_disk && ide_disk);
    if( !ret && ide_disk )
	{
	string abc = "abcdefghijklmnopqrstuvwxyz";
	integer idx = 0;
	foreach( string k, disks,
	    ``{
	    y2milestone( "dev %1 abc %2", substring(k, 7, 1),
	                 substring(abc, idx, 1));
	    if( substring(k, 7, 1) != substring(abc, idx, 1) )
		{
		ret = true;
		}
	    idx = idx+1;
	    });
	}
    y2milestone( "ret %1 disks %2 ide %3 scsi %4", ret, size(disks), ide_disk,
                 scsi_disk );
    return( ret );
    };

global define boolean UseLilo()
    ``{
    boolean ret = false;
    y2milestone( "ret %1", ret );
    return( ret );
    }

global define list<string> GetDirPatterns( string dir, list patterns )
    ``{
    list<string> ret = [];
    string cmd = sformat( "cd %1 && (ls %2 2>/dev/null)", dir,
                          mergestring( (list<string>)patterns, " "));
    map out = (map) SCR::Execute( .target.bash_output, cmd );
    ret = splitstring( out["stdout"]:"", "\n" );
    ret = filter( string e, ret, ``(size(e)>0) );
    ret = maplist( string e, ret, ``(dir+"/"+e));
    y2milestone( "dir %1 pat %2", dir, patterns );
    y2milestone( "ret %1", ret );
    return( ret );
    }

global define map GetBootPartition( string disk )
    ``{
    map ret = $[];
    map tg = GetTargetMap();
    ret = filter( map p, tg[disk,"partitions"]:[], ``(p["boot"]:false))[0]:$[];
    y2milestone( "disk:%1 ret:%2", disk, ret );
    return( ret );
    }

global define void UpdateFstabSubfs()
    ``{
    y2milestone( "updating subfs for cdrom and floppy" );
    string tabpath = PathToDestdir( "/etc/fstab" );
    map fstab = Partitions::GetFstab( tabpath );
    integer line = 0;
    while( line<=AsciiFile::NumLines( fstab ) )
	{
	map l = AsciiFile::GetLine( fstab, line );
	if( find( l["fields",1]:"", "/media/floppy" )==0 )
	    {
	    AsciiFile::ChangeLineField( fstab, line, 2, "subfs" );
	    AsciiFile::ChangeLineField( fstab, line, 3, FileSystems::GetFstabDefaultMntops("floppy") );
	    }
	else if( find( l["fields",1]:"", "/media/cdrom" )==0 ||
		 find( l["fields",1]:"", "/media/dvd" )==0 ||
		 find( l["fields",1]:"", "/media/cdrecorder" )==0 ||
		 find( l["fields",1]:"", "/media/dvdrecorder" )==0 ||
		 find( l["fields",1]:"", "/cdrom" )==0 ||
		 find( l["fields",1]:"", "/dvd" )==0 ||
		 find( l["fields",1]:"", "/cdrecorder" )==0 ||
		 find( l["fields",1]:"", "/dvdrecorder" )==0 ) 
	    {
	    AsciiFile::ChangeLineField( fstab, line, 2, "subfs" );
	    list<string> opts = splitstring( l["fields",3]:"", "," );
	    opts = filter( string e, opts, ``(size(e)>0 ));
	    y2milestone( "old opts %1", opts );
	    opts = filter( string e, opts, 
			   ``(!contains( ["noauto","ro","user","exec"], e )));
	    y2milestone( "old opts %1", opts );
	    string nopts = FileSystems::GetFstabDefaultMntops("cdrom");
	    if( size(opts)>0 )
		nopts = nopts + "," + mergestring( opts, "," );
	    y2milestone( "new opts %1", opts );
	    AsciiFile::ChangeLineField( fstab, line, 3, nopts );
	    }
	line = line+1;
	}
    AsciiFile::RewriteFile( fstab, tabpath );
    }

global string HdToIseries( string input )
    ``{
    string ret = input;
    string regex = "/dev/hd[a-z][0-9]*";
    if( regexpmatch( input, regex ))
	{
	ret = "/dev/iseries/vd" + substring( ret, 7 );
	}
    y2milestone( "HdToIseries input:%1 ret:%2", input, ret );
    return( ret );
    }

global string HdDiskMap( string input, map diskmap )
    ``{
    string ret = input;
    map d = GetDiskPartition( input );
    if( haskey( diskmap, d["disk"]:"" ))
	{
	ret = GetDeviceName( diskmap[d["disk"]:""]:"", d["nr"]:(any)0 );
	}
    y2milestone( "HdDiskMap input:%1 ret:%2", input, ret );
    return( ret );
    }

global define void UpdateFstabIseriesVd()
    ``{
    y2milestone( "UpdateFstabIseriesVd updating hdx to iseries/vdx" );
    string tabpath = PathToDestdir( "/etc/fstab" );
    map fstab = Partitions::GetFstab( tabpath );
    integer line = 0;
    string n = "";
    while( line<=AsciiFile::NumLines( fstab ) )
	{
	map l = AsciiFile::GetLine( fstab, line );
	n = HdToIseries( l["fields",0]:"" );
	if( n != l["fields",0]:"" )
	    {
	    AsciiFile::ChangeLineField( fstab, line, 0, n );
	    }
	line = line+1;
	}
    AsciiFile::RewriteFile( fstab, tabpath );
    tabpath = PathToDestdir( "/etc/cryptotab" );
    map crtab = Partitions::GetCrypto( tabpath );
    line = 0;
    while( line<=AsciiFile::NumLines( crtab ) )
	{
	map l = AsciiFile::GetLine( crtab, line );
	n = HdToIseries( l["fields",1]:"" );
	if( n != l["fields",1]:"" )
	    {
	    AsciiFile::ChangeLineField( crtab, line, 1, n );
	    }
	line = line+1;
	}
    AsciiFile::RewriteFile( crtab, tabpath );
    }

global define void UpdateCdromLinks( map diskmap )
    ``{
    y2milestone( "UpdateCdromLinks map %1", diskmap );
    foreach( string link, StorageDevices::TypeNames,
	``{
	string dev = "/dev/" + link;
	string cont = (string)SCR::Read( .target.symlink, dev );
	if( cont!=nil && find( cont, "/dev/") != 0 )
	    cont = "/dev/" + cont;
	y2milestone( "UpdateCdromLinks dev %1 cont %2", dev, cont );
	if( cont!=nil && haskey( diskmap, cont ) && size(diskmap[cont]:"")>0 )
	    {
	    y2milestone( "Change symlink %1 from %2 -> %3", dev, cont,
	                 diskmap[cont]:"" );
	    SCR::Execute( .target.remove, dev );
	    SCR::Execute( .target.symlink, substring(diskmap[cont]:"",5), dev );
	    }
	});
    }

global define void UpdateFstabDiskmap( map diskmap )
    ``{
    y2milestone( "UpdateFstabdiskmap map %1", diskmap );
    string tabpath = PathToDestdir( "/etc/fstab" );
    map fstab = Partitions::GetFstab( tabpath );
    integer line = 0;
    string n = "";
    while( line<=AsciiFile::NumLines( fstab ) )
	{
	map l = AsciiFile::GetLine( fstab, line );
	n = HdDiskMap( l["fields",0]:"", diskmap );
	if( n != l["fields",0]:"" )
	    {
	    AsciiFile::ChangeLineField( fstab, line, 0, n );
	    }
	line = line+1;
	}
    AsciiFile::RewriteFile( fstab, tabpath );
    tabpath = PathToDestdir( "/etc/cryptotab" );
    map crtab = Partitions::GetCrypto( tabpath );
    line = 0;
    while( line<=AsciiFile::NumLines( crtab ) )
	{
	map l = AsciiFile::GetLine( crtab, line );
	n = HdDiskMap( l["fields",1]:"", diskmap );
	if( n != l["fields",1]:"" )
	    {
	    AsciiFile::ChangeLineField( crtab, line, 1, n );
	    }
	line = line+1;
	}
    AsciiFile::RewriteFile( crtab, tabpath );
    }

global define void UpdateCryptoType()
    ``{
    y2milestone( "UpdateCryptoType" );
    string tabpath = PathToDestdir( "/etc/fstab" );
    map fstab = Partitions::GetFstab( tabpath );
    integer line = 0;
    integer pos = 0;
    string search = "encryption=twofish256";
    while( line<=AsciiFile::NumLines( fstab ) )
	{
	map l = AsciiFile::GetLine( fstab, line );
	pos = find( l["fields",3]:"", search );
	if( pos >= 0 )
	    {
	    string new = substring( l["fields",3]:"", 0, pos );
	    new = new + "encryption=twofishSL92";
	    new = new + substring( l["fields",3]:"", pos+size(search) );
	    y2milestone( "new options line in %1 is %2", l, new );
	    AsciiFile::ChangeLineField( fstab, line, 3, new );
	    }
	line = line+1;
	}
    AsciiFile::RewriteFile( fstab, tabpath );
    tabpath = PathToDestdir( "/etc/cryptotab" );
    map crtab = Partitions::GetCrypto( tabpath );
    line = 0;
    while( line<=AsciiFile::NumLines( crtab ) )
	{
	map l = AsciiFile::GetLine( crtab, line );
	if( l["fields",4]:"" == "twofish256" )
	    {
	    y2milestone( "set twofishSL92 in line %1", l );
	    AsciiFile::ChangeLineField( crtab, line, 4, "twofishSL92" );
	    }
	line = line+1;
	}
    AsciiFile::RewriteFile( crtab, tabpath );
    }

global define void UpdateFstabUsbdevfs()
    ``{
    y2milestone( "UpdateFstabUsbdevfs updating usbdevfs to usbfs" );
    boolean changed = false;
    string tabpath = PathToDestdir( "/etc/fstab" );
    map fstab = Partitions::GetFstab( tabpath );
    integer line = 0;
    while( line<=AsciiFile::NumLines( fstab ) )
	{
	map l = AsciiFile::GetLine( fstab, line );
	if( l["fields",2]:"" == "usbdevfs" )
	    {
	    AsciiFile::ChangeLineField( fstab, line, 2, "usbfs" );
	    AsciiFile::ChangeLineField( fstab, line, 0, "usbfs" );
	    changed = true;
	    }
	line = line+1;
	}
    if( changed )
	{
	y2milestone( "UpdateFstabUsbdevfs changed" );
	AsciiFile::RewriteFile( fstab, tabpath );
	}
    }


define map BuildDiskmap( map oldv )
    ``{
    map d = (map)SCR::Read( .target.stat, 
                            Installation::destdir + "/var/lib/hardware" );
    if( d["isdir"]:false && oldv != DiskMapVersion )
    if( oldv != DiskMapVersion )
	{
	DiskMap = $[];
	string cmd = "cd /var/lib/hardware/unique-keys && ";
	cmd = cmd + " ln -s " + Installation::destdir + "/var/lib/hardware/* ";
	cmd = cmd + Installation::destdir + "/var/lib/hardware/unique-keys/* .";
	y2milestone( "BuildDiskmap cmd %1", cmd );
	map bo = (map)SCR::Execute (.target.bash_output, cmd );
	y2milestone( "BuildDiskmap bo %1", bo );
	cmd = "hwinfo --map";
	y2milestone( "BuildDiskmap cmd %1", cmd );
	bo = (map)SCR::Execute (.target.bash_output, cmd );
	y2milestone( "BuildDiskmap bo %1", bo );
	if( bo["exit"]:1==0 && size(bo["stdout"]:"")>0 )
	    {
	    list<string> lines = splitstring( bo["stdout"]:"", "\n" );
	    foreach( string line, lines,
		``{
		list<string> disks = filter( string d, 
		                             splitstring( line, " \t" ),
					     ``(size(d)>0));
		if( size(disks)>1 )
		    {
		    integer index = 1;
		    while( index<size(disks) )
			{
			DiskMap[disks[index]:""] = disks[0]:"";
			index = index+1;
			}
		    }
		});
	    }
	if( bo["exit"]:1==0 )
	    DiskMapVersion = oldv;
	else
	    DiskMapVersion = $[];
	cmd = "find /var/lib/hardware -type l | xargs rm";
	y2milestone( "BuildDiskmap cmd %1", cmd );
	bo = (map)SCR::Execute (.target.bash_output, cmd );
	y2milestone( "BuildDiskmap bo %1", bo );
	y2milestone( "BuildDiskmap DiskMap %1", DiskMap );
	y2milestone( "BuildDiskmap DiskMapVersion %1", DiskMapVersion );
	}
    return( DiskMap );
    }

global define void ExecuteHwcfgDisk()
    ``{
    string cmd = "/usr/sbin/gen-hwcfg-disk.sh";
    y2milestone( "ExecuteHwcfgDisk cmd %1", cmd );
    map bo = (map)SCR::Execute (.target.bash_output, cmd );
    y2milestone( "ExecuteHwcfgDisk bo %1", bo );
    };

global define void Update( map oldv, map newv )
    ``{
    y2milestone( "Update old:%1 new:%2", oldv, newv );
    if( oldv["major"]:0<9 )
	{
	UpdateFstabUsbdevfs();
	}
    map dm = BuildDiskmap( oldv );
    if( size(dm)>0 )
	{
	UpdateFstabDiskmap( dm );
	}
    if( oldv["major"]:0<9 || (oldv["major"]:0==9 && oldv["minor"]:0<=2))
	{
	StorageDevices::MakeCDLinks();
	Storage::UpdateCryptoType();
	}
    if( oldv["major"]:0<9 || (oldv["major"]:0==9 && oldv["minor"]:0==0))
	{
	UpdateFstabSubfs();
	if( Arch::board_iseries () )
	    {
	    UpdateFstabIseriesVd();
	    }
	string cmd = "cd / && /sbin/insserv -r /etc/init.d/boot.evms";
	y2milestone( "Update cmd %1", cmd );
	map bo = (map)SCR::Execute (.target.bash_output, cmd );
	y2milestone( "Update bo %1", bo );
	}
    ExecuteHwcfgDisk();
    }

global define list<string> GetTranslatedDevices( map oldv, map newv, 
						 list<string> names )
    {
    y2milestone( "GetTranslatedDevices old:%1 new:%2", oldv, newv );
    y2milestone( "GetTranslatedDevices names %1", names );
    list<string> ret = names;
    map dm = BuildDiskmap( oldv );
    if( size(dm)>0 )
	{
	ret = maplist( string n, names, ``(HdDiskMap( n, dm )));
	}
    if( (oldv["major"]:0<9 || (oldv["major"]:0==9 && oldv["minor"]:0==0)) &&
        Arch::board_iseries () )
	{
	ret = maplist( string n, names, ``(HdToIseries( n )));
	}
    y2milestone( "GetTranslatedDevices ret %1", ret );
    return( ret );
    }

global define list GetUsedLvmGroups( map<string,map> tg )
    ``{
    list groups = [];
    foreach( string disk, map data, tg,
	``{
	if( data["type"]:`CT_UNKNOWN==`CT_LVM && 
	    size( filter( map p, data["partitions"]:[], 
	                  ``(size(p["mount"]:"")>0 ) )) > 0 )
	    {
	    y2milestone( "GetUsedLvmGroups %1", 
	                 filter( map p, data["partitions"]:[],
				 ``(size(p["mount"]:"")>0 ) ) );
	    groups = add( groups, substring( disk, 5 ) );
	    }
	});
    y2milestone( "GetUsedLvmGroups ret %1", groups );
    return( groups );
    };

/**
 * Get used real disks
 * @param tg Target map
 * @return disks List of disks
 */
global define list<string> GetUsedRealDisks( map<string,map> tg )
    ``{
    list<string> disks = [];
    list lvmgr = GetUsedLvmGroups( tg );
    list mdlist = [];
    foreach( map p, tg["/dev/md","partitions"]:[],
	``{
	if( size(p["mount"]:"")>0  ||
	    contains( lvmgr, p["used_by"]:"" ) )
	    {
	    mdlist = add( mdlist, p["device"]:"" );
	    }
	});
    foreach( string disk, map data, tg,
	``{
	if( IsRealDisk( data ) && 
	    size( filter( map p, data["partitions"]:[], 
	                  ``(size(p["mount"]:"")>0 ||
			     contains( mdlist, p["used_by"]:"" )  ||
			     contains( lvmgr, p["used_by"]:"" ) ) )) > 0 )
	    {
	    disks = add( disks, disk );
	    }
	});
    y2milestone( "GetUsedRealDisks ret %1", disks );
    return( disks );
    };

global define list<string> GetEvmsRealDisk( map<string,map> tg, map p )
    ``{
    list<string> rdisk = [];
    string name = "";
    if( size(p["device"]:"")>10 )
	name = substring( p["device"]:"", 10 );
    if( find( name, "lvm/" ) == 0 )
	{
	name = substring( name, 0, findlastof( name, "/" ));
	}
    y2milestone( "GetEvmsRealDisk name is %1", name );
    foreach( string disk, map data, tg,
	``{
	if( size(name)>0 && 
	    (IsRealDisk( data ) || disk=="/dev/md") &&
	    size( filter( map p, data["partitions"]:[], 
	                  ``(p["used_by"]:"" == name)))>0 )
	    {
	    rdisk = (list<string>)union( rdisk, [ disk ] );
	    }
	});
    if( size(rdisk)==0 && !p["evms_native"]:false )
	{
	map d = GetDiskPartition( "/dev/" + name );
	if( haskey( tg, d["disk"]:"" ))
	    {
	    rdisk = [ d["disk"]:"" ];
	    }
	}
    y2milestone( "GetEvmsRealDisk %1 is %2", p["device"]:"", rdisk );
    return( rdisk );
    }

global define list<string> GetUsedEvmsDisks( map<string,map> tg )
    ``{
    list<string> disks = [];
    list mdlist = [];
    foreach( string disk, map data, tg,
	``{
	if( find( disk, "/dev/evms" )==0 )
	    {
	    foreach( map p, data["partitions"]:[],
		``{
		if( size(p["mount"]:"")>0 )
		    {
		    list<string> dl = GetEvmsRealDisk( tg, p );
		    foreach( string d, dl,
			``{
			if( find( d, "/dev/md" ) == 0 )
			    {
			    list<string> ndl = [];
			    foreach( string dd, map pp, tg,
				``{
				if( pp["used_by"]:"" == substring(d,5) )
				    {
				    ndl = add( ndl, dd );
				    }
				});
			    disks = (list<string>)union( disks, ndl );
			    }
			else
			    {
			    disks = (list<string>)add( disks, d );
			    }
			});
		    }
		});
	    }
	});
    disks = sort( disks );
    y2milestone( "GetUsedEvmsDisks ret %1", disks );
    return( disks );
    };

global define boolean CheckEvmsNonEvms()
    ``{
    boolean ret = true;
    if( DoCheckEvmsNonEvms )
	{
	map<string,map> tg = GetTargetMap();
	list<string> evms = GetUsedEvmsDisks( tg );
	list<string> nonevms = GetUsedRealDisks( tg );
	evms = filter( string d, evms, ``(contains( nonevms, d )));
	y2milestone( "CheckEvmsNonEvms intersec %1", evms );
	ret = size(evms)==0;
	}
    y2milestone( "CheckEvmsNonEvms ret %1", ret );
    return( ret );
    };

global define boolean CheckEvmsLvm()
    ``{
    boolean ret = true;
    if( DoCheckEvmsLvm )
	{
	map<string,map> tg = GetTargetMap();
	list evms = GetUsedEvmsDisks( tg );
	list lvms = GetUsedLvmGroups( tg );
	ret = size(evms)==0 || size(lvms)==0;
	}
    y2milestone( "CheckEvmsLvm ret %1", ret );
    return( ret );
    };

global define void FinishInstall()
    ``{
    map<string,map> tg = GetTargetMap();
    HandleModulesOnBoot( tg );
    list evms = GetUsedEvmsDisks( tg );
    y2milestone( "FinishInstall evms %1", evms );
    if( size(evms)>0 )
	{
	string cmd = "cd / && /sbin/insserv /etc/init.d/boot.evms";
	y2milestone( "FinishInstall cmd %1", cmd );
	map bo = (map)SCR::Execute (.target.bash_output, cmd );
	y2milestone( "FinishInstall bo %1", bo );
	list<string> nonevms = GetUsedRealDisks( tg );
	nonevms = filter( string d, nonevms, ``(!contains( evms, d )));
	if( size(nonevms)>0 && SCR::Read( .target.size, "/etc/evms.conf" )>=0 )
	    {
	    map evmsconf = $[];
	    AsciiFile::ReadFile( evmsconf, "/etc/evms.conf" );
	    boolean found = false;
	    integer i = 1;
	    string regex = "^[ \t]*exclude[ \t]*=";
	    while( i<=AsciiFile::NumLines(evmsconf) && !found )
		{
		map l = AsciiFile::GetLine( evmsconf, i );
		if( regexpmatch( l["line"]:"", regex ))
		    {
		    found = true;
		    string li = "\texclude = [ " + mergestring( nonevms, " " ) +
		                " ]";
		    y2milestone( "FinishInstall li = %1", li );
		    evmsconf["l",i,"line"] = li;
		    evmsconf["l",i,"buildline"] = false;
		    AsciiFile::RewriteFile( evmsconf, "/etc/evms.conf" );
		    }
		i = i+1;
		}
	    }
	}
    ExecuteHwcfgDisk();
    y2milestone( "FinishInstall" );
    }

global define map GetEntryForMountpoint( string mp ) 
    ``{
    list<map> all_partitions = [];
    foreach( string dev, map disk, GetTargetMap(),
	``{
	all_partitions = (list<map>)union( all_partitions, 
	                                   disk["partitions"]:[] );
	});
    map partition = find( map part, all_partitions, ``(part["mount"]:""==mp) );
    if( partition==nil || partition["mount"]:"" != mp )
        {
	partition = $[];
	}
    return partition;
    }

global define list GetRootInitrdModules()
    ``{
    map partition = GetEntryForMountpoint( "/" );
    y2milestone("root partition in GetInitrdModules %1", partition );

    list initrdmodules =
	FileSystems::GetNeededModules( partition["used_fs"]:`ext2 );

    if( partition["type"]:`unknown == `sw_raid )
	{
	string t = partition["raid_type"]:"";
	if (!contains (initrdmodules, t))
	    {
	    initrdmodules = add (initrdmodules, t);
	    }
	}
    if( partition["type"]:`unknown == `lvm )
	{
	string vgname = substring( partition["device"]:"", 5 );
	vgname = substring( vgname, 0, findfirstof( vgname, "/" ));
	map tg = GetTargetMap();
	list<string> mod = 
	    (list<string>) maplist(map k, filter(map e, tg["/dev/md","partitions"]:[],
						 ``(e["used_by"]:""==vgname) ),
				   ``(k["raid_type"]:""));
	y2milestone( "mod %1", mod );
	foreach(string e, mod,
	    ``{
	    if( size(e)>0 && !contains( initrdmodules, e ) )
		{
		initrdmodules = add( initrdmodules, e );
		}
	    });
	if( !contains( initrdmodules, "dm_mod" ) )
	    {
	    initrdmodules = add( initrdmodules, "dm_mod" );
	    }
	}
    y2milestone ("initrdmodules %1", initrdmodules);
    return initrdmodules;
    };

/**
 * CheckForLvmRootFs
 *---------------------------------------------------------------------
 * check if the root filesystem is a lvm logical volume
 *
 **/
global define boolean CheckForLvmRootFs()
    ``{
    map part = GetEntryForMountpoint( "/" );
    y2milestone( "CheckForLvmRootFs root=%1", part );
    boolean ret = part["type"]:`primary==`lvm;
    y2milestone( "CheckForLvmRootFs ret=%1", ret );
    return ret;
    };

  /**
   * CheckForEvmsRootFs
   *---------------------------------------------------------------------
   * check if the root filesystem is a evms volume
   *
   **/
global define boolean CheckForEvmsRootFs()
    ``{
    map part = GetEntryForMountpoint( "/" );
    y2milestone( "CheckForEvmsRootFs root=%1", part );
    boolean ret = part["type"]:`primary==`evms;
    y2milestone( "CheckForEvmsRootFs ret=%1", ret );
    return ret;
    };



  /*---------------------------------------------------------------------
   * checkForMdRootFs
   *---------------------------------------------------------------------
   * check if the root filesystem is a md device
   *---------------------------------------------------------------------
   */
global define boolean CheckForMdRootFs()
    ``{
    map part = GetEntryForMountpoint( "/" );
    boolean ret = part["type"]:`primary==`sw_raid;
    y2milestone( "CheckForMdRootFs root=%1", part );
    y2milestone( "CheckForMdRootFs ret=%1", ret );
    return ret;
    };

/**
 * Return a map that contains the maindev for maindevkey.
 * @param maindevkey
 * @return map
 */
global define map<string, any> GetMainDev(string maindevkey )``{
    map<string, any> maindev = (map<string, any>)GetTargetMap()[maindevkey]:$[];

    if( maindev == $[] )
	{
	y2milestone("GetMainDev return empty map $[] (default value)");
	y2milestone("No maindev with key %1 in Storage found.", maindevkey );
	}
    return maindev;
    }

global define any GetMainDevParam( string maindevkey, string paramkey, 
                                   any defaultv )
    ``{
    any param =  GetMainDev( maindevkey )[paramkey]:defaultv;

    return param;
    }

/**
 * Return true if Storage contains a maindev with the key "maindevkey".
 * @return boolean
 * @param maindevkey
 *
 */
global define boolean ExistsMainDevKeyEntry( string maindevkey )
    ``{
    if( GetMainDev( maindevkey) != $[] )
	return true;
    return false;
    }

/**
 * Modify a maindev in Storage.
 * @param maindevkey describe the maindev
 * @param newmaindev map with modified maindev
 * @return boolean
 */
global define boolean SetMainDev( string maindevkey, map<string, any> newmaindev )
    ``{
    if( ! ExistsMainDevKeyEntry( maindevkey ))
	{
	return false;
	}
    else
	{
	map<string,map> new_targetMap =  
	    add( GetTargetMap(), maindevkey, newmaindev );
	SetTargetMap( new_targetMap );
	return true;
	}
    }

global define boolean SetMainDevParam(string maindevkey, string paramkey, any newparam )
    ``{
    map<string, any> maindev = GetMainDev( maindevkey);

    if( maindev == $[] )
	return false;

    maindev     = add( maindev, paramkey, newparam );
    return SetMainDev( maindevkey, maindev );
    }

/* replace SubDev entry with newsubdev */
global define boolean SetSubDev( string subdevkey, map newsubdev )
    ``{
    string maindevkey = GetMainDevKey( subdevkey );
    list<map> partitions = (list<map>) GetMainDevParam( maindevkey, "partitions", [] );

    // and now delete the old partition number in curr_disk to replace it in the next step
    list r_part =
	filter(map c_part, partitions ,
		``(sformat("%1", c_part["nr"]:(any)0) != GetSubDevIndex( subdevkey)));

    // netxt step: insert changed partition
    r_part    = add( r_part,   newsubdev );
    return SetMainDevParam( maindevkey, "partitions", r_part );
    }

global define void AdaptResize( string maindev, list region, integer schange )
    ``{
    map tg = GetTargetMap();
    list<map> partitions = tg[maindev,"partitions"]:[];
    integer cylinder = region[0]:0 + region[1]:0;
    boolean found = false;
    integer index = -1;
    integer e_idx = -1;
    list<integer> idx_list = [];
    map part = (map) find(map p, partitions,
                          ``(p["region",0]:0 == cylinder && p["create"]:false));
    y2milestone( "AdaptResize %1 reg %2 change %3", maindev, region, schange );
    if( part != nil )
	{
	found = false;
	index = 0;
	foreach(map p, partitions,
	    ``{
	    if( p["region",0]:0 == cylinder && p["create"]:false )
		{
		found = true;
		}
	    else if( !found )
		{
		index = index + 1;
		}
	    });
	if( partitions[index,"type"]:`primary == `extended )
	    {
	    e_idx = index;
	    found = false;
	    index = 0;
	    foreach(map p, partitions,
		``{
		if( p["region",0]:0 == cylinder && p["create"]:false && 
		    p["type"]:`primary != `extended )
		    {
		    found = true;
		    part = (map)eval(p);
		    }
		else if( !found )
		    {
		    index = index + 1;
		    }
		});
	    }
	cylinder = part["region",0]:0 + part["region",1]:0;
	y2milestone( "AdaptResize part:%1", part );
	y2milestone( "AdaptResize index:%1 e_idx:%2 cylinder:%3", index, e_idx,
	             cylinder );
	map pnew = (map) find( map p, partitions, 
	                       ``( p["region",0]:0 == cylinder &&
				   p["create"]:false ));
	y2milestone( "AdaptResize pnew:%1", pnew );
	while( pnew != nil &&
	       (part["mount"]:"" == Partitions::BootMount() ||
	        part["fsid"]:0==Partitions::fsid_swap ||
	        part["region",1]:0 < (schange<0?(-1*schange):schange)) )
	    {
	    y2milestone( "AdaptResize pnew:%1", pnew );
	    part = (map)eval(pnew);
	    idx_list = add( idx_list, index );
	    found = false;
	    index = 0;
	    foreach(map p, partitions, ``{
	        y2milestone( "found:%1 index:%2 p=%3", found, index, p );
		if( p["delete"]:false == false &&
		    p["nr"]:(any)0 == pnew["nr"]:(any)0 )
		    {
		    found = true;
		    }
		else if( !found )
		    {
		    index = index + 1;
		    }
		});
	    cylinder = part["region",0]:0 + part["region",1]:0;
	    pnew = (map) find( map p, partitions, 
	                       ``( p["region",0]:0 == cylinder &&
				   p["create"]:false ));
	    }
	y2milestone( "AdaptResize idx:%1 list:%2", index, idx_list );
	partitions[index,"region",0] = partitions[index,"region",0]:0 - schange;
	partitions[index,"region",1] = partitions[index,"region",1]:0 + schange;
	if( partitions[index,"region",1]:0 <= 0 )
	    {
	    partitions[index,"region",1] = 1;
	    }
	if( e_idx>=0 )
	    {
	    partitions[e_idx,"region",0] = partitions[e_idx,"region",0]:0 - schange;
	    partitions[e_idx,"region",1] = partitions[e_idx,"region",1]:0 + schange;
	    if( partitions[e_idx,"region",1]:0 <= 0 )
		{
		partitions[e_idx,"region",1] = 1;
		}
	    }

	foreach(integer num, idx_list, ``{
	    partitions[num,"region",0] = partitions[num,"region",0]:0 - schange;
	    });
	}
    else
	{
	y2error( "AdaptResize this should not happen %1", partitions );
	}
    SetMainDevParam( maindev, "partitions", partitions );
    y2milestone( "AdaptResize maindev:%1 region:%2 change:%3", maindev,
                 region, schange );
    }


global define integer NumLoopDevices()
    {
    map bo = (map)SCR::Execute (.target.bash_output, "losetup -a" );
    list<string> sl = splitstring( bo["stdout"]:"", "\n" );
    sl = filter( string s, sl, ``(find( s, "/dev/loop" )==0 ));
    sl = maplist( string s, sl, ``(substring( s, 0, find( s, ":" ))));
    sl = maplist( string s, sl, ``(substring( s, 9 )));
    list<integer> il = sort( maplist( string s, sl, ``(tointeger(s))));
    integer ret = il[size(sl)-1]:-1 + 1;
    y2milestone( "NumLoopDevices ret:%1", ret );
    return( ret );
    }


//-----------------------------------------------------
// convert partitions to fstab entries
// return map (might be empty)
global define map onepartition2fstab (map part, integer& other_nr)
    ``{
    y2milestone( "onepartition2fstab part=%1", part );
    if (part["delete"]:false || 
	part["type"]:`unknown == `extended ||
	(contains( [ `lvm, `sw_raid, `evms ], part["type"]:`unknown ) &&
	 size(part["mount"]:"")==0) ||
	(part["enc_type"]:`none!=`none && !part["noauto"]:false) ||
	part["used_by_type"]:`UB_NONE != `UB_NONE ||
	(contains( [ Partitions::fsid_prep_chrp_boot, Partitions::fsid_lvm,
	             Partitions::fsid_raid ], part["fsid"]:0 ) && 
	 size(part["mount"]:"")==0))
	{
	return $[];
	}

    string spec = part["device"]:""; 
    if( part["mountby"]:`device == `label && size(part["label"]:"")>0 )
	{
	spec = sformat("LABEL=%1", part["label"]:"" );
	}
    else if( part["mountby"]:`device == `uuid && size(part["uuid"]:"")>0 )
	{
	spec = sformat("UUID=%1", part["uuid"]:"" );
	}
    y2debug( "onepartition2fstab spec=%1", spec );
    string  mount_point = part["mount"]:"";
    integer fsid = part["fsid"]:0;

    symbol  used_fs = part["used_fs"]:`ext2;
    boolean format  = part["format"]:false;

    string  vfstype = "unknown";	// keep "unknown", used again below
    integer freq    = 0;
    integer passno  = 0;
    string  mntops  = part["fstopt"]:"";

    if( mount_point == "swap" )
	{
	vfstype = "swap";
	if( size(mntops) == 0 )
	    {
	    mntops = FileSystems::GetFstabDefaultMntops( "swap" );
	    }
	passno = 0;
	}
    else if( fsid==Partitions::fsid_native || fsid==Partitions::fsid_lvm ||
             (part["type"]:`unknown == `evms && 
	      part["detected_fs"]:`none!=`unknown) )
	{
	vfstype = FileSystems::GetMountString( used_fs, 
	                                       (format ? "ext2" : "auto"));

	freq = 1;
	if( mount_point == "/" )
	    {
	    passno = 1;
	    }
	else if( mount_point != "" )
	    {
	    passno = 2;
	    }
	else if( Stage::initial () && !Arch::s390 () )
	    {
	    mount_point = "/data" + other_nr;
	    // Don't mount and fsck this filesystem during boot, its
	    // state is unknown.
	    mntops = "noauto,user";
	    vfstype = "auto";
	    freq = 0;
	    passno = 0;
	    other_nr = other_nr + 1;
	    y2milestone( "TT add MountPoint %1", mount_point );
	    }
	}
    else if( (Arch::i386 ()||Arch::ia64 ()||Arch::x86_64 ()) && size(mount_point)>0 &&
             (used_fs==`fat32 || used_fs==`ntfs) &&
             (contains(union(union(Partitions::fsid_dostypes, 
				   Partitions::fsid_ntfstypes),
			     Partitions::fsid_wintypes), fsid ) ||
	      fsid==Partitions::fsid_gpt_boot))
	{
	freq = 0;
	passno = 0;
	string lower_point = tolower( mount_point );
	if( lower_point != "" && mount_point != lower_point)
	    {
	    if( Installation::scr_destdir != "/" )
		{
		lower_point = Installation::scr_destdir + lower_point;
		}
	    y2milestone( "symlink %1 -> %2", 
	                 substring(mount_point,(findlastof(mount_point,"/")+1)),
			 lower_point );
	    SCR::Execute(.target.symlink, 
	                 substring(mount_point,(findlastof(mount_point,"/")+1)),
	                 lower_point);
	    }
	vfstype = FileSystems::GetMountString( used_fs, "auto" );
	}
    else if( (Arch::sparc () || Arch::alpha ()) &&
	     contains (Partitions::fsid_skipped, fsid))
	{
	return $[];		// skip "whole disk" partition
	}
    else
	{
	return $[];	        // unknown type
	}
    if( part["detected_fs"]:`reiserfs == `unknown || 
        part["noauto"]:false )
	{
	passno = 0;
	}

    map ret = $[ "spec":spec, 
                 "mount":mount_point, 
		 "vfstype":vfstype,
                 "mntops":mntops, 
		 "freq":freq, 
		 "device":part["device"]:"", 
		 "passno":passno ];

    if( size(ret["mntops"]:"")==0 )
	{
	ret["mntops"] = "defaults";
	}

    y2milestone( "onepartition2fstab ret=%1", ret );
    return( ret );
    };



}


