/**
 * File:	StorageSettings.ycp
 * Package:	yast2-storage
 * Summary:	Expert Partitioner
 * Authors:	Arvin Schnell <aschnell@suse.de>
 */
{
    module "StorageSettings";


    textdomain "storage";


    import "Storage";
    import "Partitions";
    import "Integer";
    import "HTML";


    symbol display_name = nil;

    list<symbol> hidden_fields = nil;
    list <string> visible_fields = [];

    boolean modified = false;

    global boolean GetModified()
    {
	return modified;
    }

    global void SetModified( )
    {
	 modified = true;
    }


    global void SetDisplayName(symbol new_display_name)
    {
	display_name = new_display_name;
    }

    global symbol GetDisplayName()
    {
	if (display_name == nil)
	{
	    string tmp = (string) SCR::Read(.sysconfig.storage.DISPLAY_NAME);
	    if (tmp == nil || !contains([ "device", "id", "path" ], tolower(tmp)))
		tmp = "device";

	    display_name = tosymbol(tolower(tmp));
	}

	return display_name;
    }

    global string DisplayName(map data)
    {
	string ret = "";

	switch (GetDisplayName())
	{
	    case `path:
		ret = data["udev_path"]:"";
		break;

	    case `id:
		ret = data["udev_id", 0]:"";
		break;
	}

	if (isempty(ret))
	    ret = data["name"]:"";

	return ret;
    }


    global void SetHiddenFields(list<symbol> new_hidden_fields)
    {
	hidden_fields = toset(new_hidden_fields);
    }


    global list<symbol> GetHiddenFields()
    {
	if (hidden_fields == nil)
	{
	    string tmp = (string) SCR::Read(.sysconfig.storage.HIDDEN_FIELDS);
	    if (tmp == nil)
		tmp = "";

	    hidden_fields = toset(maplist(string field, splitstring(tmp, " \t"), {
		return tosymbol(tolower(field));
	    }));
	}

	return hidden_fields;
    }


    global list<symbol> FilterTable(list<symbol> fields)
    {
	list<symbol> hidden = GetHiddenFields();

	if (GetDisplayName() != `path)
	    hidden = multiset::union(hidden, [ `udev_path ]);
	else
	    hidden = multiset::difference(hidden, [ `udev_path ]);

	if (GetDisplayName() != `id)
	    hidden = multiset::union(hidden, [ `udev_id ]);
	else
	    hidden = multiset::difference(hidden, [ `udev_id ]);

	return filter(symbol field, fields, { return !setcontains(hidden, field); });
    }


    global list<symbol> FilterOverview(list<symbol> fields)
    {
	list<symbol> hidden = GetHiddenFields();

	return filter(symbol field, fields, { return !setcontains(hidden, field); });
    }

    global void InvertVisibleFields(list < map <symbol, any> >all_fields, list <integer> selected)
    {
	    foreach(integer i, Integer::Range(size(all_fields)), {
		list<symbol> fields = all_fields[i, `fields]:[];
		string label = all_fields[i, `label]:"";
		if (contains(selected, i))
		{
		    hidden_fields = multiset::difference(hidden_fields, fields);
		    visible_fields = multiset::union(visible_fields, [label]); 
		}
		else
		{
		    hidden_fields = multiset::union(hidden_fields, fields);
		    visible_fields = multiset::difference(visible_fields, [label]); 
		}
	    });

    }

    global string Summary()
    {
	list<string> tmp = [
	    _("Default Mount-by:") + " " + substring(tostring(Storage::GetDefaultMountBy()), 1),
	    _("Default Filesystem:") + " " + substring(tostring(Partitions::DefaultFs()), 1),
	    _("Show Storage Devices by:") + " " + substring(tostring(display_name), 1),
	    _("Partition Alignment:") + " " + substring(tostring(Storage::GetPartitionAlignment()), 7),
	    _("Visible Information on Storage Devices:") + " " + HTML::List(visible_fields)
	];

	return HTML::List(tmp);
	}


    global void Save()
    {
	if (display_name != nil)
	{
	    string tmp = substring(tostring(display_name), 1);
	    SCR::Write(.sysconfig.storage.DISPLAY_NAME, tmp);
	}

	if (hidden_fields != nil)
	{
	    string tmp = mergestring(maplist(symbol field, hidden_fields, {
		return substring(tostring(field), 1);
	    }), " ");
	    SCR::Write(.sysconfig.storage.HIDDEN_FIELDS, tmp);
	}

	if (true)
	{
	    string tmp = substring(tostring(Storage::GetDefaultMountBy()), 1);
	    SCR::Write(.sysconfig.storage.DEVICE_NAMES, tmp);
	}

	if (true)
	{
	    string tmp = substring(tostring(Partitions::DefaultFs()), 1);
	    SCR::Write(.sysconfig.storage.DEFAULT_FS, tmp);
	}

	if (true)
	{
	    string tmp = "optimal";
	    switch( Storage::GetPartitionAlignment() )
		{
		case `align_cylinder:
		    tmp = "cylinder";
		    break;
		default:
		    tmp = "optimal";
		    break;
		}
	    SCR::Write(.sysconfig.storage.PARTITION_ALIGN, tmp);
	}
    }
}
