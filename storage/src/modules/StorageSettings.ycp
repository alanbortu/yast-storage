/*
 * Copyright (c) 2012 Novell, Inc.
 *
 * All Rights Reserved.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as published
 * by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
 * more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, contact Novell, Inc.
 *
 * To contact Novell about this file by physical or electronic mail, you may
 * find current contact information at www.novell.com.
 */

/**
 * File:	StorageSettings.ycp
 * Package:	yast2-storage
 * Summary:	Expert Partitioner
 * Authors:	Arvin Schnell <aschnell@suse.de>
 */
{
    module "StorageSettings";


    textdomain "storage";


    import "Storage";
    import "Partitions";
    import "Integer";
    import "HTML";


    symbol display_name = nil;

    list<symbol> hidden_fields = nil;
    list <string> visible_fields = [];

    boolean modified = false;


    global boolean GetModified()
    {
	return modified;
    }

    global void SetModified( )
    {
	 modified = true;
    }


    global void SetDisplayName(symbol new_display_name)
    {
	display_name = new_display_name;
    }

    global symbol GetDisplayName()
    {
	if (display_name == nil)
	{
	    string tmp = (string) SCR::Read(.sysconfig.storage.DISPLAY_NAME);
	    if (tmp == nil || !contains([ "device", "id", "path" ], tolower(tmp)))
		tmp = "device";

	    display_name = tosymbol(tolower(tmp));
	}

	return display_name;
    }

    global string DisplayName(map data)
    {
	string ret = "";

	switch (GetDisplayName())
	{
	    case `path:
		ret = data["udev_path"]:"";
		break;

	    case `id:
		ret = data["udev_id", 0]:"";
		break;
	}

	if (isempty(ret))
	    ret = data["name"]:"";

	return ret;
    }


    global void SetHiddenFields(list<symbol> new_hidden_fields)
    {
	hidden_fields = toset(new_hidden_fields);
    }


    global list<symbol> GetHiddenFields()
    {
	if (hidden_fields == nil)
	{
	    string tmp = (string) SCR::Read(.sysconfig.storage.HIDDEN_FIELDS);
	    if (tmp == nil)
		tmp = "";

	    hidden_fields = toset(maplist(string field, splitstring(tmp, " \t"), {
		return tosymbol(tolower(field));
	    }));
	}

	return hidden_fields;
    }


    global list<symbol> FilterTable(list<symbol> fields)
    {
	list<symbol> hidden = GetHiddenFields();

	if (GetDisplayName() != `path)
	    hidden = multiset::union(hidden, [ `udev_path ]);
	else
	    hidden = multiset::difference(hidden, [ `udev_path ]);

	if (GetDisplayName() != `id)
	    hidden = multiset::union(hidden, [ `udev_id ]);
	else
	    hidden = multiset::difference(hidden, [ `udev_id ]);

	return filter(symbol field, fields, { return !setcontains(hidden, field); });
    }


    global list<symbol> FilterOverview(list<symbol> fields)
    {
	list<symbol> hidden = GetHiddenFields();

	return filter(symbol field, fields, { return !setcontains(hidden, field); });
    }

    global void InvertVisibleFields(list < map <symbol, any> >all_fields, list <integer> selected)
    {
	    foreach(integer i, Integer::Range(size(all_fields)), {
		list<symbol> fields = all_fields[i, `fields]:[];
		string label = all_fields[i, `label]:"";
		if (contains(selected, i))
		{
		    hidden_fields = multiset::difference(hidden_fields, fields);
		    visible_fields = multiset::union(visible_fields, [label]); 
		}
		else
		{
		    hidden_fields = multiset::union(hidden_fields, fields);
		    visible_fields = multiset::difference(visible_fields, [label]); 
		}
	    });

    }

    global string Summary()
    {
	list<string> tmp = [
	    _("Default Mount-by:") + " " + substring(tostring(Storage::GetDefaultMountBy()), 1),
	    _("Default File System:") + " " + substring(tostring(Partitions::DefaultFs()), 1),
	    _("Show Storage Devices by:") + " " + substring(tostring(display_name), 1),
	    _("Partition Alignment:") + " " + substring(tostring(Storage::GetPartitionAlignment()), 7),
	    _("Visible Information on Storage Devices:") + " " + HTML::List(visible_fields)
	];

	return HTML::List(tmp);
    }


    global void Save()
    {
	if (display_name != nil)
	{
	    string tmp = substring(tostring(display_name), 1);
	    SCR::Write(.sysconfig.storage.DISPLAY_NAME, tmp);
	}

	if (hidden_fields != nil)
	{
	    string tmp = mergestring(maplist(symbol field, hidden_fields, {
		return substring(tostring(field), 1);
	    }), " ");
	    SCR::Write(.sysconfig.storage.HIDDEN_FIELDS, tmp);
	}

	if (true)
	{
	    string tmp = substring(tostring(Storage::GetDefaultMountBy()), 1);
	    SCR::Write(.sysconfig.storage.DEVICE_NAMES, tmp);
	}

	if (true)
	{
	    string tmp = substring(tostring(Partitions::DefaultFs()), 1);
	    SCR::Write(.sysconfig.storage.DEFAULT_FS, tmp);
	}

	if (true)
	{
	    string tmp = substring(tostring(Storage::GetPartitionAlignment()), 7);
	    SCR::Write(.sysconfig.storage.PARTITION_ALIGN, tmp);
	}
    }
}
