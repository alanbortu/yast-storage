/**
 * File:
 *	StorageDevices.ycp
 *
 * Module:
 *	StorageDevices
 *
 * Depends:
 *	StorageControllers
 *
 * Summary:
 *	This module does all storage device related stuff:
 *	- hard disk drives
 *	- removable drives (ZIP)
 *	- floppy devices
 *
 * $Id$
 *
 * Author:
 *	Klaus Kaempf <kkaempf@suse.de> (initial)
 */
{
    module "StorageDevices";

    import "Mode";
    import "String";
    import "HwStatus";
    import "Partitions";
    import "Installation";
    import "Kernel";

    import "Arch";
    import "Popup";

    textdomain "storage";


    boolean disks_valid = false;

    /**
     * @return map of $["device": $[..target..], ...] for each ZIP drive
     *
     */
    global map<string,any> ZipDrives = $[];


    /**
     * @return list of maps: all kinds of removable media, esp. ZIP drives
     * @see: FloppyDevice
     * @see: FloppyReady
     */
    global list<map> FloppyDrives = [];


    /**
     * @return true if floppy drive present
     * @see: FloppyDevice
     * @see: FloppyReady
     */
    global boolean FloppyPresent = false;


    /**
     * @return Device name of floppy, empty string if no floppy present
     * @see: FloppyPresent
     * @see: FloppyReady
     */
    global string FloppyDevice = "";	// set in constructor


    //---------------------------------------------------------------

    /**
     * list of cd-rom drives
     */
    global list<map> cddrives = [];

    global list TypeNames = [ "cdrom", "dvd", "cdrecorder", "dvdrecorder", 
                              "dvdram" ];

    // storage for localProbe, see Probe()
    map targetMap = $[];

    //---------------------------------------------------------------


//---------------------------------------------------------------
// CD Recorders and CD-ROM links
list idecdrws = [];		// list of IDE CD-RW drivers for ide-scsi
list scsicds = [];		// list of SCSI CDs


  /**
   *	
      #include "storage/routines.ycp";
   */
global define string GetDeviceName( string disk, any partition ) 
    ``{
      string ret = disk;

      if( is( partition, integer ) )
	  {
  	  if( find( disk, "/dev/cciss/" )==0 ||
  	      find( disk, "/dev/ida/" )==0 ||
  	      find( disk, "/dev/ataraid/" )==0 ||
  	      find( disk, "/dev/rd/" )==0 )
  	      {
  	      ret = ret + "p";
  	      }
  	  ret = ret + sformat( "%1", partition );
	  }
      else
          {
  	  ret = ret + "/" + (string)partition;
	  }
      return( ret );
  };


/**
  * ProbeCDROMs()
  *
  * Initialize cddrives
  *
  */
global define boolean ProbeCDROMs()
    ``{
    map linknum = $[ "cdrom"       : 0, 
                     "cdrecorder"  : 0, 
		     "dvd"         : 0, 
		     "dvdrecorder" : 0,
		     "dvdram"      : 0 ];
    if (size (cddrives) == 0)
	{
	if (Mode::initial || Mode::cont)
	    {
	    cddrives = (list<map>) SCR::Read (.probe.cdrom);
	    // write out data for hardware status check
	    foreach (map drive, cddrives,
		``{
		HwStatus::Set (drive["unique_key"]:"", `yes);
		});
	    }
	else
	    {
	    cddrives = [];
	    foreach(map e, (list<map>) SCR::Read (.probe.cdrom.manual),
		``{
		map conf = (map) SCR::Read(.probe.status, e["unique_key"]:"");
		if( conf["available"]:`no != `no )
		    {
		    cddrives = add( cddrives, e );
		    }
		});

	    if ((cddrives == nil) || (size (cddrives) == 0))
		{
		cddrives = [ $["dev_name":"/dev/cdrom"] ];
		}
	    }

	// sort out idecdrws and scsicds
	foreach (map e, cddrives,
	    ``{
	    if( (e["cdr"]:false || e["cdrw"]:false || e["dvdr"]:false ) &&
		e["bus"]:"" == "IDE" )
		{
		y2milestone ("IDE CD-RW %1", idecdrws );
		}
	    if( e["bus"]:"" == "SCSI" )
		{
		scsicds = add (scsicds, e["dev_name"]:"");
		}
	    });

	cddrives = maplist( map e, cddrives,
	    ``{
	    if( e["dev_name"]:"" != "/dev/cdrom" )
		{
		// first, determine the drive type and make a linkname guess
		string cddevice = e["dev_name"]:"";

		string linkname = "cdrom";
		if( e["dvdram"]:false )
		    {
		    linkname = "dvdram";
		    }
		else if( e["dvdr"]:false )
		    {
		    linkname = "dvdrecorder";
		    }
		else if( e["cdr"]:false || e["cdrw"]:false )
		    {
		    linkname = "cdrecorder";
		    }
		else if( e["dvd"]:false )
		    {
		    linkname = "dvd";
		    }

		// now check the number (for /dev/cdrom, /dev/cdrom2, ...)
		integer number = linknum[linkname]:0;
		linknum[linkname] = number + 1;

		string devname = "/dev/" + linkname;

		if( number > 0)
		    devname = devname + number+1;

		e["linkname"] = devname;
		}
	    return( e );
	    });
	}
    y2milestone ("ProbeCDROMs (%1)", cddrives);
    return (size (cddrives) > 0);
    }

global define map GetCdromEntry( string device )
    ``{
    map ret = $[];
    ret = find(map e, cddrives, ``(e["dev_orig"]:(e["dev_name"]:"") == device));
    if( ret == nil )
	{
	ret = $[];
	}
    y2milestone( "ret %1", ret );
    return( ret );
    }

/*
 * FloppyReady ()
 * @return floppy media status
 * determines if a media is present.
 * @see: FloppyPresent
 * @see: FloppyDevice
 */

global define boolean FloppyReady ()
    ``{
    if( Mode::initial )
	{
	y2milestone( "before .probe.floppy" );
	FloppyDrives = (list<map>) SCR::Read(.probe.floppy);
	y2milestone( "after .probe.floppy" );

	if( !FloppyPresent )	// only once !
	    {
	    // write out data for hardware status check
	    foreach (map drive, FloppyDrives,
		``{
		HwStatus::Set (drive["unique_key"]:"", `yes);
		});
	    }
	}
    else
	{
	FloppyDrives = (list<map>) SCR::Read(.probe.floppy.manual);
	}

    map floppy_data = FloppyDrives[0]:$[];
    FloppyDevice = floppy_data["dev_name"]:"";
    if( (FloppyDevice != "") || Mode::test)
	{
	FloppyPresent = true;
	}
    y2milestone( "FloppyDrives %1", FloppyDrives );
    return( size(floppy_data)>0 && !haskey(floppy_data,"notready") );
    }


// loop over floppy drives to find IDE ZIPs
// return map of $[ "device" : $[target], ...]

define map findZIPs ()
    ``{
    map zips = $[];
    foreach (map disk, FloppyDrives,
	``{
	if (disk["zip"]:false)
	    {
	    map target = $[];
	    string dname = "";

	    string ddevice = disk["dev_name"]:"?";
	    string dinfo = disk["vendor"]:"";

	    target["vendor"] = dinfo;
	    if (dinfo != "") dname = dname + dinfo + "-";

	    dinfo = disk["device"]:"";
	    target["model"] = dinfo;

	    if (dinfo != "") dname = dname + dinfo;
	    target["name"] = dname;
	    target["partitions"] = [];

	    zips[ddevice] = target;
	    }
	});
    y2milestone( "zips %1", zips );
    return zips;
    }


/*
 * Fake probing for storage devices in test or demo mode -
 * read ready-made target maps from file.
 *
 * @return	map	TargetMap
 */

global define map fakeProbe ()
    ``{
    string fake_map_file = ( Mode::demo ? "demo_target_map.ycp" : "test_target_map.ycp" );
    
    y2milestone( "%1 mode - using fake target map from %2",
                 Mode::demo ? "Demo" : "Test", fake_map_file );

    map target_map = (map) SCR::Read( .target.yast2, fake_map_file );

    y2debug( "Fake target map: %1", target_map );

    return target_map;
    } // fakeProbe()


/*
 * check partitions for given disk (as path, i.e. '.sda')
 * returns list as specified in README.target_partition
 */
global define map Check4partitions( string diskdev, map disk, path diskpath )
    ``{
    list partitions_desc = (list) SCR::Read( .disk+diskpath+.partitions,
				   Partitions::UseParted() );
    if( is(partitions_desc[0]:(any)"", string ) )
	{
	if( size(partitions_desc[0]:"")>0 )
	    {
	    disk["label"] = partitions_desc[0]:"";
	    }
	else
	    {
	    disk["label"] = Partitions::DefaultPartLabel();
	    }
	}
    else
	{
	disk["label"] = Partitions::DefaultPartLabel();
	}
    disk["max_primary"] = Partitions::MaxPrimary( disk["label"]:"" );
    disk["max_logical"] = Partitions::MaxLogical( diskdev );
    y2milestone( "disk %1 label %2 max_primary:%3 max_logical:%4", 
                 diskdev, disk["label"]:"", disk["max_primary"]:0,
		 disk["max_logical"]:0 );

    // the list contains only maps now
    list<map> partitions = (list<map>)remove( partitions_desc, 0 );
    partitions = maplist(map part, partitions,
	``{
	    if( part["fsid"]:0 > 0 && (part["fsid"]:0<256||disk["label"]:""=="gpt"))
		{
		part["fstype"] = Partitions::FsIdToString( part["fsid"]:0 );
		}
	    return( part );
	});
    partitions = maplist(map p, partitions,
	``{
	    p["device"] = GetDeviceName( diskdev, p["nr"]:(any)0 );
	    return( p );
	});
    disk["partitions"] = partitions;
    return disk;
    };

global define map CheckPartedValid( string ddevice, map disk, 
				    list<map> partitions, list<map> ppart )
    ``{
    map<integer,integer> plist1 = $[];
    map<integer,integer> plist2 = $[];
    boolean ret = true;
    y2milestone( "target %1", disk );
    string regex = substring( ddevice, 5 )+"[p]*[0-9]+";
    y2milestone( "ddevice %1 regex %2", ddevice, regex );
    list<map> ps = filter( map p, ppart, ``(regexpmatch( p["name"]:"", regex) ));
    y2milestone( "ps %1", ps );
    integer cyl_blocks = disk["cyl_size"]:1000000 / 1024;
    list bsd_part = [ Partitions::fsid_freebsd, Partitions::fsid_openbsd ];
    boolean openbsd = find(map e,partitions, 
                            ``(contains(bsd_part,e["fsid"]:0)))!=nil;
    y2milestone( "openbsd %1", openbsd );
    foreach(map p, ps,
	``{
	integer pnr = tointeger(deletechars(substring(p["name"]:"",size(ddevice)-5),"p"));
	plist1[pnr] = p["size"]:0/cyl_blocks;
	});
    foreach(map p, partitions,
	``{
	plist2[p["nr"]:0] = p["region",1]:0;
	});
    map ext = find(map p, partitions, ``(p["type"]:`unknown==`extended));
    if( ext != nil )
	{
	plist1 = filter(integer k, integer e, plist1, ``(k!=ext["nr"]:0));
	plist2 = filter(integer k, integer e, plist2, ``(k!=ext["nr"]:0));
	}
    y2milestone( "plist1 %1", plist1 );
    y2milestone( "plist2 %1", plist2 );
    ret = size(plist1) >= size(plist2);
    if( ret )
	{
	foreach(integer k, integer e, plist1, 
	    ``{
	    if( !haskey( plist2, k ))
		{
		ret = ret && openbsd;
		}
	    else
		{
		integer diff = e - plist2[k]:0;
		if( diff < 0 ) diff = -diff;
		if( diff <= 2 ) diff = 0;
		ret = ret && diff <= plist2[k]:0/100;
		y2milestone( "k:%1 diff:%2 ret:%3", k, diff, ret );
		}
	    });
	foreach(integer k, integer e, plist2, 
	    ``{
	    if( !haskey( plist1, k ))
		{
		ret = false;
		}
	    else
		{
		integer diff = e - plist1[k]:0;
		if( diff < 0 ) diff = -diff;
		if( diff <= 2 ) diff = 0;
		ret = ret && diff <= plist2[k]:0/100;
		y2milestone( "k:%1 diff:%2 ret:%3", k, diff, ret );
		}
	    });
	}
    if( !ret )
	{
	list new_p = [];
	integer reg_start=0;
	y2milestone( "ps=%1", ps );
	foreach(map p, ps,
	    ``{
	    map part = $[];
	    string ts = substring(p["name"]:"",size(ddevice)-5);
	    integer pos = findfirstof(ts, "0123456789");
	    if( pos > 0 )
		{
		ts = substring( ts, pos );
		}
	    integer pnr = tointeger(ts);
	    part["nr"] = pnr;
	    part["region"] = [ reg_start, p["size"]:0/cyl_blocks ];
	    reg_start = reg_start + part["region",1]:0;
	    part["device"] =  GetDeviceName( ddevice, pnr );
	    if( part["region",1]:0==0 )
		{
		part["type"] = `extended;
		part["fsid"] = Partitions::fsid_extended_win;
		}
	    else
		{
		part["type"] = pnr<5 ? `primary : `logical;
		part["fsid"] = Partitions::fsid_native;
		}
	    map pp = find(map e, partitions, ``(e["nr"]:0==pnr));
	    if( pp != nil )
		{
		y2milestone( "entry in parted list %1", pp );
		part["fsid"] = pp["fsid"]:0;
		part["type"] = pp["type"]:`primary;
		}
	    part["fstype"] = Partitions::FsIdToString( part["fsid"]:0 );
	    new_p = add( new_p, part );
	    });
	partitions = (list<map>)new_p;
	y2milestone( "new p %1", partitions );
	}
    y2milestone( "disk %1 ret:%2", ddevice, ret );
    return( $["ret":ret, "partitions":partitions ] );
    };


global define list GetS390Partitions( string ddev, map target, list<map> ppart )
    ``{
    list<map> partitions = [];
    y2milestone( "target %1", target );
    string regex = substring( ddev, 5 )+"[0-9]+";
    y2milestone( "ddev %1 regex %2", ddev, regex );
    list<map> ps = filter(map p, ppart, ``(regexpmatch( p["name"]:"", regex) ));
    y2milestone( "ps %1", ps );
    integer cyl_blocks = target["cyl_size"]:1000000 / 1024;
    foreach(map p, ps,
	``{
	map part = $[];
	part["nr"] = tointeger(substring(p["name"]:"",size(ddev)-5));
	part["region"] = [ 0, p["size"]:0/cyl_blocks ];
	part["fsid"] = Partitions::fsid_native;
	part["type"] = `s390;
	part["fstype"] = "S390 DASD";
	y2milestone( "part %1", part );
	partitions = add( partitions, part );
	});

    /* TODO: no partition found ==> "fdasd -a" needed instead of
       simply pretending a first partition.  this needs to be done on a
       *disk* level, not on partition level.

       This hack is needed, however, to have a partiton visible, so
       the user can choose 'low level format dasd'.

    */

    if( size(ps)==0 )
	{
	map part = $[];
	part["nr"] = 1;
	part["region"] = [ 0, target["cyl_count"]:0 ];
	part["fsid"] = Partitions::fsid_native;
	part["type"] = `s390;
	part["fstype"] = "S390 DASD";
	partitions = [ part ];
	}
    partitions = maplist(map p, partitions,
	``{
	p["device"] = GetDeviceName( ddev, p["nr"]:0 );
	return( p );
	});
    y2milestone( "part %1", partitions );
    return( partitions );
    }

/*
 * Probe for storage devices attached to storage controllers
 * Should be called after StorageControllers::Initialize
 * @return	map	TargetMap
 */

define map localProbe ()
    ``{
    map targets = $[];
    list<map> ppart = [];

    if( Mode::test )
	{
	return fakeProbe();
	}
    ppart = (list<map>) SCR::Read(.proc.partitions);
    y2milestone( "ppart %1", ppart );

    // do the probing
    list<map> all_disks = (list<map>) SCR::Read(.probe.disk);

    y2milestone("disks probed");
    y2milestone( "all_disks %1", all_disks );

    if( size(all_disks)==0 )
	{
	// somehow, we couldn't find any harddisks for installation.
	// This is a fatal error, we can't do anything about it
	return targets;
	}

    // loop over all_disks, constructing targets map

    integer ide_count = 0;
    integer scsi_count = 0;
    integer raid_count = 0;

    foreach (map disk, filter(map e,all_disks,``(size(e["dev_name"]:"")>0)),
	``{
	map target = $[];

	boolean notready = disk["notready"]:false;
	boolean is_zip = (notready || disk["zip"]:false);

	y2milestone( "is_zip %1 notready:%2", is_zip, notready );

	string bus = disk["bus"]:"?";
	string dname = "";
	integer i = 0;

	// write out data for hardware status check
	HwStatus::Set (disk["unique_key"]:"", `yes);

	target["unique"] = disk["unique_key"]:"";

	// ------------------------------------------------------
	// check bus, count disks per bus

	if (bus == "IDE")
	    {
	    ide_count = ide_count + 1;
	    i = ide_count;
	    }
	else if (bus == "SCSI")
	    {
	    scsi_count = scsi_count + 1;
	    i = scsi_count;
	    }
	else if (bus == "RAID")
	    {
	    raid_count = raid_count + 1;
	    i = raid_count;
	    }
	else
	    {
	    i = 1;		// Oops, which bus ?
	    }

	target["bus"] = bus;

	// ------------------------------------------------------
	// construct disk name for user

	dname = ""+i+". "+bus+", ";

	// needed also later as key
	string ddevice = disk["dev_name"]:"?";

	// remember bios id code if set
	string bios_id = disk["bios_id"]:"";
	if (bios_id != "")
	    {
	    target["bios_id"] = bios_id;
	    }

	// - - - - - - - - - - - - - - - - - - - -
	// split /dev/... -> [ "", "dev", "hda" ]

	list listpath = splitstring (ddevice, "/");

	if (size (listpath) < 3)
	    {
	    y2error("too few / in %1", ddevice);
	    }

	if (listpath[1]:"" != "dev")
	    {
	    y2error("not /dev in %1", ddevice);
	    }

	// get first path after /dev

	string stringpath = "." + listpath[2]:"";

	// might be RAID /dev/ida/xy -> [ "", "dev", "ida", "xy" ]

	if (size (listpath) > 3)
	    {
	    list raidpathes = [ ".rd", ".ida", ".cciss", ".ataraid" ];
	    if (contains (raidpathes, stringpath))
		{
		target["raid"] = true;
		}
	    }

	integer pathidx = 3;
	while (pathidx < size (listpath))
	    {
	    stringpath = stringpath + "." + listpath[pathidx]:"";
	    pathidx = pathidx + 1;
	    }

	path diskpath = topath (stringpath);
	path fullpath = .disk + diskpath;

	y2milestone("disk_size: %1", ddevice);

	// call fdisk agent to get size information

	integer cyl_count = 0;
	integer cyl_size = 0;

	if( !Arch::s390 )
	    {
	    // call fdisk agent to get size information
	    if (!is_zip && !notready )
		{
		cyl_count = (integer) SCR::Read(fullpath+.disk_size);
		cyl_size= (integer) SCR::Read(fullpath+.bytes_per_unit);
		}

	    target["cyl_count"] = cyl_count;
	    target["cyl_size"] = cyl_size;

	    y2milestone( "diskinfo: cyl_count %1 cyl_size %2", cyl_count, 
	                 cyl_size );
	    }
	else
	    {
	    // on s390 look at libhd-info for diskinfo
	    // "resource":$["disk_log_geo":
	    //                  [$["cylinders":2226, "heads":15, "sectors":12]
	    //              "size":[$["unit":"sectors", "x":400680, "y":4096]]

	    map     size_map   = disk["resource", "size", 0]:$[];
	    integer disk_size  = size_map["x"]:0 * size_map["y"]:0;

	    cyl_count  = disk["resource", "disk_log_geo", 0, "cylinders"]:1;
	    cyl_size   = disk_size / cyl_count;

	    target["cyl_count"] = cyl_count;
	    target["cyl_size"] = cyl_size;

	    y2milestone( "diskinfo: sizemap %1 disksize %2 cyl_count %3 cyl_size %4", size_map, disk_size, cyl_count, cyl_size);
	    }

	// ------------------------------------------------------
	// construct full target name

	dname = dname + String::FormatSize(cyl_count * cyl_size) + ", " + ddevice + ", ";

	string dinfo = disk["vendor"]:"";
//	target["vendor"]:dinfo;

	if (dinfo != "")
	    {
	    dname = dname + dinfo + "-";
	    }
	dinfo = disk["device"]:"";
	target["model"] = dinfo;

	if (dinfo != "")
	    {
	    dname = dname + dinfo;
	    }

	target["name"] = dname;

	// ----------------------------------------------------------
	// Partitions

	list partitions = [];
	if( !is_zip && !notready )
	    {
	    if( find( ddevice, "/dev/dasd" )!=0 )
		{
		target = Check4partitions (ddevice, target, diskpath);
		partitions = target["partitions"]:[];
		y2milestone( "old p %1", partitions );
		map r = CheckPartedValid( ddevice, target, (list<map>)partitions, ppart );
		if( !r["ret"]:true )
		    {
		    partitions = r["partitions"]:[];
		    y2milestone( "new p %1", partitions );
		    target["readonly"] = true;
		    if( Mode::initial && !Mode::autoinst)
			{
			Popup::Error( Partitions::RdonlyText(ddevice,false) );
			}
		    }
		}
	    else
		{
		partitions = GetS390Partitions( ddevice, target, ppart );
		}
	    }

	target["scrpath"] = diskpath;
	target["partitions"] = partitions;

	// add constructed target map to list of all targets

	if (!notready && (size (target) > 0))
	    {
	    if (is_zip)
		ZipDrives[ddevice] = target;
	    else
		targets[ddevice] = target;
	    }
	y2milestone( "disk %1 tg: %2", ddevice, targets[ddevice]:$[] );
	}); // foreach (disk)

    SCR::UnmountAgent(.disk);

    ZipDrives = (map<string,any>)union (ZipDrives, findZIPs ());

    foreach(string k, any e, ZipDrives, 
	``{
	FloppyDrives = filter(map f, FloppyDrives, ``(f["dev_name"]:""!=k));
	});
    y2milestone( "FloppyDrives %1", FloppyDrives );
    y2milestone( "ZipDrives %1", ZipDrives );

    if (Mode::test)
	SCR::Write(.target.ycp, "/tmp/targets", targets);

    return targets;
    } // localProbe()

/*
 * Probe ()
 * probe for target devices, return map
 * used like proposal-api
 *
 * @param boolean force_reset
 */
global define map Probe (boolean force_reset)
    ``{
    y2milestone( "force_reset:%1 disks_valid:%2", force_reset, disks_valid );
    if( force_reset )
	targetMap = $[];

    if( targetMap==$[] && disks_valid )
	{
	targetMap = localProbe();
	ProbeCDROMs();
	}
    return targetMap;
    }


/*
 * symlink_cdrom
 *
 * make proper symlink for cd-rom/dvd/cdrecorder drive
 *
 * @param	map	cdinfo	result of .probe.cdrom
 */

// count the links for "pseudo" devices

define void symlink_cdrom( map cdinfo )
    ``{
    y2milestone( "device %1 link %2", cdinfo["dev_name"]:"",
                 cdinfo["linkname"]:"" );
    if( size(cdinfo["linkname"]:"")>0 && size(cdinfo["dev_name"]:"")>0 )
	{
	string link = cdinfo["linkname"]:"";
	string device = cdinfo["dev_name"]:"";
	
	if( Installation::destdir != "/" )
	    {
	    link = Installation::destdir + link;
	    }
	y2milestone( "pathname %1 links to %2", link, device );
	SCR::Execute (.target.symlink, substring(device,5), link);
	}
    return;
    }

/*
 * Symlink (/mnt)/dev/cdromX to all real cdrom devices (/dev/sr0, etc.)
 * create type dependant links (i.e. /dev/dvd for a DVD drive
 * but make sure that at least /dev/cdrom exists.
 */

global define void MakeCDLinks ()
    ``{
    if( ProbeCDROMs() )
	{
	string boot_device = (string) SCR::Read (.etc.install_inf.Cdrom);
	if (boot_device == nil) boot_device = "";

	if (boot_device != "")
	    boot_device = "/dev/" + boot_device;

	// our boot device might be re-mapped due to ide-scsi
	map idecdwr = find(map e, cddrives, ``(e["dev_orig"]:""==boot_device));
	if( idecdwr != nil )
	    {
	    boot_device = idecdwr["dev_name"]:"";
	    }

	if( Installation::destdir != "/" )
            {
            string dir = Installation::destdir + "/dev";
            if( SCR::Read( .target.size, dir )<=0 )
                {
                SCR::Execute( .target.mkdir, dir );
                }
            }

	foreach (map drive, cddrives, ``{ symlink_cdrom (drive); });

	// if we didn't made a /dev/cdrom link, we dont have a
	// plain cdrom drive (only cdrecorders, dvds, etc.)
	// force such a link here.

	if( find(map e, cddrives, ``(e["linkname"]:""=="/dev/cdrom")) == nil )
	    {
	    // if we didnt boot from cd, just link to the first drive
	    if( boot_device=="" )
		{
		boot_device = cddrives[0,"dev_name"]:"";
		}
	    if (boot_device != "")
		{
		symlink_cdrom ($["dev_name":boot_device, 
                                 "linkname":"/dev/cdrom"]);
		}
	    }

	// if we didn't made a /dev/dvd link so far try to 
	// force such a link here.
	map te = find(map e, cddrives, ``(e["linkname"]:""=="/dev/dvd"));
	if( te == nil )
	    {
	    te = find(map e, cddrives, ``(e["dvd"]:false));
	    if( te != nil )
		{
		symlink_cdrom ($["dev_name":te["dev_name"]:"", 
                                 "linkname":"/dev/dvd"]);
		}
	    }

	// if we didn't made a /dev/cdrecorder link so far try to 
	// force such a link here.
	te = find(map e, cddrives, ``(e["linkname"]:""=="/dev/cdrecorder"));
	if( te == nil )
	    {
	    te = find(map e, cddrives, ``(e["cdrw"]:false));
	    if( te != nil )
		{
		symlink_cdrom ($["dev_name":te["dev_name"]:"", 
                                 "linkname":"/dev/cdrecorder"]);
		}
	    }
	}
    return;
    }

/*
 * Initialize
 */

global define void FullProbe ()
    ``{
    FloppyReady();		// probe floppy
    ProbeCDROMs();		// probe CDs
    }

global define void InitDone()
    ``{
    disks_valid = true;
    y2milestone( "called disks_valid %1", disks_valid );
    }

/*
 * Constructor
 */

global define void StorageDevices ()
    ``{
    if( !Mode::initial && !Mode::config )
	{
	FullProbe ();
	disks_valid = true;
	}
    return;
    }
}
