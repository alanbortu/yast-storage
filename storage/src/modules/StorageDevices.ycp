/**
 * File:
 *	StorageDevices.ycp
 *
 * Module:
 *	StorageDevices
 *
 * Depends:
 *	StorageControllers
 *
 * Summary:
 *	This module does all storage device related stuff:
 *	- hard disk drives
 *	- removable drives (ZIP)
 *	- floppy devices
 *
 * $Id$
 *
 * Author:
 *	Klaus Kaempf <kkaempf@suse.de> (initial)
 */
{
    module "StorageDevices";

    import "Mode";
    import "HwStatus";
    import "Storage";
    import "Partitions";
    import "Installation";

    textdomain "storage";

    include "ui/common_functions.ycp";

    boolean disks_valid = false;

    /**
     * @return map of $["device": $[..target..], ...] for each ZIP drive
     *
     */
    global map zipDrives = $[];


    /**
     * @return list of maps: all kinds of removable media, esp. ZIP drives
     * @see: FloppyDevice
     * @see: FloppyReady
     */
    global list FloppyDrives = [];


    /**
     * @return true if floppy drive present
     * @see: FloppyDevice
     * @see: FloppyReady
     */
    global boolean FloppyPresent = false;


    /**
     * @return Device name of floppy, empty string if no floppy present
     * @see: FloppyPresent
     * @see: FloppyReady
     */
    global string FloppyDevice = "";	// set in constructor


    //---------------------------------------------------------------

    /**
     * list of cd-rom drives
     */
    global list cddrives = [];

    global list TypeNames = [ "cdrom", "dvd", "cdrecorder", "dvdrecorder", 
                              "dvdram" ];

    // storage for localProbe, see Probe()
    map targetMap = $[];

    //---------------------------------------------------------------


//---------------------------------------------------------------
// CD Recorders and CD-ROM links
list idecdrws = [];		// list of IDE CD-RW drivers for ide-scsi
list scsicds = [];		// list of SCSI CDs

/**
  * ProbeCDROMs()
  *
  * Initialize cddrives
  *
  */
global define boolean ProbeCDROMs()
    ``{
    map linknum = $[ "cdrom"       : 0, 
                     "cdrecorder"  : 0, 
		     "dvd"         : 0, 
		     "dvdrecorder" : 0,
		     "dvdram"      : 0 ];
    if (size (cddrives) == 0)
	{
	if (Mode::initial || Mode::cont)
	    {
	    cddrives = SCR::Read (.probe.cdrom);
	    // write out data for hardware status check
	    foreach (`drive, cddrives,
		``{
		HwStatus::Set (drive["unique_key"]:"", `yes);
		});
	    }
	else
	    {
	    cddrives = [];
	    foreach( `e, SCR::Read (.probe.cdrom.manual),
		``{
		map conf = SCR::Read(.probe.status, e["unique_key"]:"");
		if( conf["available"]:`no != `no )
		    {
		    cddrives = add( cddrives, e );
		    }
		});

	    if ((cddrives == nil) || (size (cddrives) == 0))
		{
		cddrives = [ $["dev_name":"/dev/cdrom"] ];
		}
	    }

	// sort out idecdrws and scsicds
	foreach (`e, cddrives,
	    ``{
	    if( (e["cdr"]:false || e["cdrw"]:false || e["dvdr"]:false ) &&
		e["bus"]:"" == "IDE" )
		{
		idecdrws = add( idecdrws, substring( e["dev_name"]:"", 5));
		y2milestone ("IDE CD-RW %1", idecdrws );
		}
	    if( e["bus"]:"" == "SCSI" )
		{
		scsicds = add (scsicds, e["dev_name"]:"");
		}
	    });

	// now rewrite the /dev-names for the IDE drives
	// as they appear _after_ loading of ide-scsi
	foreach (`e, cddrives,
	    ``{
	    if( contains( idecdrws, substring( e["dev_name"]:"", 5) ))
		{
		string scsiname = "/dev/sr" + size (scsicds);
		y2milestone ("IDE CD-RW %1 -> %2", e["dev_name"]:"", scsiname);
		scsicds = add (scsicds, scsiname);
		e["dev_orig"] = e["dev_name"]:"";
		e["dev_name"] = scsiname;
		}
	    });

	foreach( `e, filter( `v, cddrives, ``(v["dev_name"]:""!="/dev/cdrom")),
	    ``{
	    // first, determine the drive type and make a linkname guess
	    string cddevice = e["dev_name"]:"";

	    string linkname = "cdrom";
	    if( e["dvdram"]:false )
		{
		linkname = "dvdram";
		}
	    else if( e["dvdr"]:false )
		{
		linkname = "dvdrecorder";
		}
	    else if( e["cdr"]:false || e["cdrw"]:false )
		{
		linkname = "cdrecorder";
		}
	    else if( e["dvd"]:false )
		{
		linkname = "dvd";
		}

	    // now check the number (for /dev/cdrom, /dev/cdrom2, ...)
	    integer number = linknum[linkname]:0;
	    linknum[linkname] = number + 1;

	    string devname = "/dev/" + linkname;

	    if( number > 0)
		devname = devname + number+1;

	    e["linkname"] = devname;
	    });

	}
    y2milestone ("ProbeCDROMs (%1)", cddrives);
    return (size (cddrives) > 0);
    }

global define map GetCdromEntry( string device )
    ``{
    map ret = $[];
    ret = find( `e, cddrives, ``(e["dev_orig"]:(e["dev_name"]:"") == device));
    if( ret == nil )
	{
	ret = $[];
	}
    y2milestone( "ret %1", ret );
    return( ret );
    }

/*
 * FloppyReady ()
 * @return floppy media status
 * determines if a media is present.
 * @see: FloppyPresent
 * @see: FloppyDevice
 */

global define boolean FloppyReady ()
    ``{
    if( Mode::initial )
	{
	y2milestone( "before .probe.floppy" );
	FloppyDrives = SCR::Read(.probe.floppy);
	y2milestone( "after .probe.floppy" );

	if( !FloppyPresent )	// only once !
	    {
	    // write out data for hardware status check
	    foreach (`drive, FloppyDrives,
		``{
		HwStatus::Set (drive["unique_key"]:"", `yes);
		});
	    }
	}
    else
	{
	FloppyDrives = SCR::Read(.probe.floppy.manual);
	}

    map floppy_data = FloppyDrives[0]:$[];
    FloppyDevice = floppy_data["dev_name"]:"";
    if( (FloppyDevice != "") || Mode::test)
	{
	FloppyPresent = true;
	}
    y2milestone( "FloppyDrives %1", FloppyDrives );
    return( size(floppy_data)>0 && !haskey(floppy_data,"notready") );
    }


// check if this device is a ZIP drive

define boolean check4zip (map disk)
    ``{
    list zlist = splitstring (disk["device"]:"", " ");
    boolean zip_found = false;
    foreach (`zelement, zlist,
	``{
	if (zelement == "ZIP")
	    zip_found = true;
	});
    y2milestone( "zip %1 disk %2", zip_found, 
                 filter( `k, `e, disk, ``(k!="partitions")));
    return zip_found;
    }

// loop over floppy drives to find IDE ZIPs
// return map of $[ "device" : $[target], ...]

define map findZIPs ()
    ``{
    map zipdrives = $[];
    foreach (`disk, FloppyDrives,
	``{
	boolean is_zip = check4zip (disk);
	if (is_zip)
	    {
	    map target = $[];
	    string dname = "";

	    string ddevice = disk["dev_name"]:"?";
	    string dinfo = disk["vendor"]:"";

	    target["vendor"] = dinfo;
	    if (dinfo != "") dname = dname + dinfo + "-";

	    dinfo = disk["device"]:"";
	    target["model"] = dinfo;

	    if (dinfo != "") dname = dname + dinfo;
	    target["name"] = dname;
	    target["partitions"] = [];

	    zipdrives[ddevice] = target;
	    }
	});
    y2milestone( "zipdrives %1", zipdrives );
    return zipdrives;
    }


/*
 * Probe for storage devices attached to storage controllers
 * Should be called after StorageControllers::Initialize
 * @return	map	TargetMap
 */

define map localProbe ()
    ``{
    map targets = $[];
    list ppart = [];

    if( Mode::test )
	{
	return fakeProbe();
	}
    ppart = SCR::Read(.proc.partitions);
    y2milestone( "ppart %1", ppart );

    // do the probing
    list all_disks = SCR::Read(.probe.disk);

    y2milestone("disks probed");
    y2milestone( "all_disks %1", all_disks );

    if( size(all_disks)==0 )
	{
	// somehow, we couldn't find any harddisks for installation.
	// This is a fatal error, we can't do anything about it
	return targets;
	}

    // loop over all_disks, constructing targets map

    integer ide_count = 0;
    integer scsi_count = 0;
    integer raid_count = 0;

    foreach (`disk, filter(`e,all_disks,``(size(e["dev_name"]:"")>0)),
	``{
	map target = $[];

	boolean is_zip = false;

	boolean notready = disk["notready"]:false;

	is_zip = (notready || check4zip (disk));

	y2milestone( "is_zip %1 notready:%2", is_zip, disk["notready"]:false );

	string bus = disk["bus"]:"?";
	string dname = "";
	integer i = 0;

	// write out data for hardware status check
	HwStatus::Set (disk["unique_key"]:"", `yes);

	target["unique"] = disk["unique_key"]:"";

	// ------------------------------------------------------
	// check bus, count disks per bus

	if (bus == "IDE")
	    {
	    ide_count = ide_count + 1;
	    i = ide_count;
	    }
	else if (bus == "SCSI")
	    {
	    scsi_count = scsi_count + 1;
	    i = scsi_count;
	    }
	else if (bus == "RAID")
	    {
	    raid_count = raid_count + 1;
	    i = raid_count;
	    }
	else
	    {
	    i = 1;		// Oops, which bus ?
	    }

	target["bus"] = bus;

	// ------------------------------------------------------
	// construct disk name for user

	dname = ""+i+". "+bus+", ";

	// needed also later as key
	string ddevice = disk["dev_name"]:"?";

	// remember bios id code if set
	string bios_id = disk["bios_id"]:"";
	if (bios_id != "")
	    {
	    target["bios_id"] = bios_id;
	    }

	// - - - - - - - - - - - - - - - - - - - -
	// split /dev/... -> [ "", "dev", "hda" ]

	list listpath = splitstring (ddevice, "/");

	if (size (listpath) < 3)
	    {
	    y2error("too few / in %1", ddevice);
	    }

	if (listpath[1]:"" != "dev")
	    {
	    y2error("not /dev in %1", ddevice);
	    }

	// get first path after /dev

	string stringpath = "." + listpath[2]:"";

	// might be RAID /dev/ida/xy -> [ "", "dev", "ida", "xy" ]

	if (size (listpath) > 3)
	    {
	    list raidpathes = [ ".rd", ".ida", ".cciss", ".ataraid" ];
	    if (contains (raidpathes, stringpath))
		{
		target["raid"] = true;
		}
	    }

	integer pathidx = 3;
	while (pathidx < size (listpath))
	    {
	    stringpath = stringpath + "." + listpath[pathidx]:"";
	    pathidx = pathidx + 1;
	    }

	path diskpath = topath (stringpath);
	path fullpath = .disk + diskpath;

	y2milestone("disk_size: %1", ddevice);

	// call fdisk agent to get size information

	integer cyl_count = 0;
	integer cyl_size = 0;
	integer max_primary = 4;

	if( !Arch::s390 )
	    {
	    // call fdisk agent to get size information
	    if (!is_zip)
		{
		cyl_count = SCR::Read(fullpath+.disk_size);
		cyl_size= SCR::Read(fullpath+.bytes_per_unit);
		max_primary= SCR::Read(fullpath+.max_primary);
		if( Arch::board_mac )
		    {
		    max_primary = 16;
		    }
		}

	    target["cyl_count"] = cyl_count;
	    target["cyl_size"] = cyl_size;
	    target["max_primary"] = max_primary;

	    y2milestone( "diskinfo: cyl_count %1 cyl_size %2 max_primary %3",
			 cyl_count, cyl_size, max_primary);
	    }
	else
	    {
	    // on s390 look at libhd-info for diskinfo
	    // "resource":$["disk_log_geo":
	    //                  [$["cylinders":2226, "heads":15, "sectors":12]
	    //              "size":[$["unit":"sectors", "x":400680, "y":4096]]

	    map     size_map   = disk["resource", "size", 0]:$[];
	    integer disk_size  = size_map["x"]:0 * size_map["y"]:0;

	    cyl_count  = disk["resource", "disk_log_geo", 0, "cylinders"]:1;
	    cyl_size   = disk_size / cyl_count;

	    target["cyl_count"] = cyl_count;
	    target["cyl_size"] = cyl_size;

	    y2milestone( "diskinfo: sizemap %1 disksize %2 cyl_count %3 cyl_size %4", size_map, disk_size, cyl_count, cyl_size);
	    }

	// ------------------------------------------------------
	// construct full target name

	dname = dname + size_text(cyl_count * cyl_size) + ", " + ddevice + ", ";

	string dinfo = disk["vendor"]:"";
	target["vendor"]:dinfo;

	if (dinfo != "")
	    {
	    dname = dname + dinfo + "-";
	    }
	dinfo = disk["device"]:"";
	target["model"] = dinfo;

	if (dinfo != "")
	    {
	    dname = dname + dinfo;
	    }

	target["name"] = dname;

	// ----------------------------------------------------------
	// Partitions

	list partitions = [];
	if( !is_zip )
	    {
	    if( find( ddevice, "/dev/dasd" )!=0 )
		{
		partitions = Check4partitions (ddevice, target, diskpath);
		y2milestone( "old p %1", partitions );
		map r = CheckPartedValid( ddevice, target, partitions, ppart );
		if( !r["ret"]:true )
		    {
		    partitions = r["partitions"]:[];
		    y2milestone( "new p %1", partitions );
		    target["readonly"] = true;
		    if( Mode::initial )
			{
			UI::ErrorPopup( Partitions::RdonlyText(ddevice,false) );
			}
		    }
		}
	    else
		{
		partitions = GetS390Partitions( ddevice, target, ppart );
		}
	    }

	if( target["label"]:"" == "mac" || target["label"]:"" == "gpt" )
	    {
	    target["max_primary"] = 16;
	    }

	target["scrpath"] = diskpath;
	target["partitions"] = partitions;

	// add constructed target map to list of all targets

	if (!notready && (size (target) > 0))
	    {
	    if (is_zip)
		zipDrives[ddevice] = target;
	    else
		targets[ddevice] = target;
	    }

	y2milestone( "disk %1 tg: %2", ddevice, targets[ddevice]:$[] );

	}); // foreach (`disk)

    SCR::UnmountAgent(.disk);

    zipDrives = union (zipDrives, findZIPs ());

    if (Mode::test)
	SCR::Write(.target.ycp, "/tmp/targets", targets);

    return targets;
    } // localProbe()

global define list GetS390Partitions( string ddev, map target, list ppart )
    ``{
    list partitions = [];
    y2milestone( "target %1", target );
    string regex = substring( ddev, 5 )+"[0-9]+";
    y2milestone( "ddev %1 regex %2", ddev, regex );
    list ps = filter( `p, ppart, ``(regexpmatch( p["name"]:"", regex) ));
    y2milestone( "ps %1", ps );
    integer cyl_blocks = target["cyl_size"]:1000000 / 1024;
    foreach( `p, ps,
	``{
	map part = $[];
	part["nr"] = tointeger(substring(p["name"]:"",size(ddev)-5));
	part["region"] = [ 0, p["size"]:0/cyl_blocks ];
	part["fsid"] = Partitions::fsid_native;
	part["type"] = `s390;
	part["fstype"] = "S390 DASD";
	y2milestone( "part %1", part );
	partitions = add( partitions, part );
	});

    /* TODO: no partition found ==> "fdasd -a" needed instead of
       simply pretending a first partition.  this needs to be done on a
       *disk* level, not on partition level.

       This hack is needed, however, to have a partiton visible, so
       the user can choose 'low level format dasd'.

    */

    if( size(ps)==0 )
	{
	map part = $[];
	part["nr"] = 1;
	part["region"] = [ 0, target["cyl_count"]:0 ];
	part["fsid"] = Partitions::fsid_native;
	part["type"] = `s390;
	part["fstype"] = "S390 DASD";
	partitions = [ part ];
	}
    partitions = maplist( `p, partitions,
	``{
	p["device"] = Storage::GetDeviceName( ddev, p["nr"]:0 );
	return( p );
	});
    y2milestone( "part %1", partitions );
    return( partitions );
    }

/*
 * Probe ()
 * probe for target devices, return map
 * used like proposal-api
 *
 * @param boolean force_reset
 */
global define map Probe (boolean force_reset)
    ``{
    y2milestone( "force_reset:%1 disks_valid:%2", force_reset, disks_valid );
    if( force_reset )
	targetMap = $[];

    if( targetMap==$[] && disks_valid )
	{
	targetMap = localProbe();
	}
    return targetMap;
    }


/*
 * Fake probing for storage devices in test or demo mode -
 * read ready-made target maps from file.
 *
 * @return	map	TargetMap
 */

global define map fakeProbe ()
    ``{
    string fake_map_file = ( Mode::demo ? "demo_target_map.ycp" : "test_target_map.ycp" );
    
    y2milestone( "%1 mode - using fake target map from %2",
                 Mode::demo ? "Demo" : "Test", fake_map_file );

    map target_map =  SCR::Read( .target.yast2, fake_map_file );

    y2debug( "Fake target map: %1", target_map );

    return target_map;
    } // fakeProbe()



/*
 * ProbeIDERecorders ()
 *
 * probe for IDE cd recorders and return list of hdX names
 * for ide-scsi setup
 */

global define list ProbeIDERecorders ()
    ``{
    ProbeCDROMs();
    y2milestone ("idecdrws %1", idecdrws);
    return idecdrws;
    }

/*
 * symlink_cdrom
 *
 * make proper symlink for cd-rom/dvd/cdrecorder drive
 *
 * @param	map	cdinfo	result of .probe.cdrom
 */

// count the links for "pseudo" devices

define void symlink_cdrom( map cdinfo )
    ``{
    if( size(cdinfo["linkname"]:"")>0 && size(cdinfo["dev_name"]:"")>0 )
	{
	string link = cdinfo["linkname"]:"";
	string device = cdinfo["dev_name"]:"";
	
	if( Installation::destdir != "/" )
	    {
	    link = Installation::destdir + link;
	    }
	y2milestone( "pathname %1 links to %2", link, device );
	SCR::Execute (.target.symlink, substring(device,5), link);
	}
    return;
    }

/*
 * Symlink (/mnt)/dev/cdromX to all real cdrom devices (/dev/sr0, etc.)
 * create type dependant links (i.e. /dev/dvd for a DVD drive
 * but make sure that at least /dev/cdrom exists.
 */

global define void MakeCDLinks ()
    ``{
    if( ProbeCDROMs() )
	{
	string boot_device = SCR::Read (.etc.install_inf.Cdrom);
	if (boot_device == nil) boot_device = "";

	if (boot_device != "")
	    boot_device = "/dev/" + boot_device;

	// our boot device might be re-mapped due to ide-scsi
	map idecdwr = find( `e, cddrives, ``(e["dev_orig"]:""==boot_device));
	if( idecdwr != nil )
	    {
	    boot_device = idecdwr["dev_name"]:"";
	    }

	if( Installation::destdir != "/" )
            {
            string dir = Installation::destdir + "/dev";
            if( SCR::Read( .target.size, dir )<=0 )
                {
                SCR::Execute( .target.mkdir, dir );
                }
            }

	foreach (`drive, cddrives, ``{ symlink_cdrom (drive); });

	// if we didn't made a /dev/cdrom link, we dont have a
	// plain cdrom drive (only cdrecorders, dvds, etc.)
	// force such a link here.

	if( find( `e, cddrives, ``(e["linkname"]:""=="/dev/cdrom")) == nil )
	    {
	    // if we didnt boot from cd, just link to the first drive
	    if( boot_device=="" )
		{
		boot_device = cddrives[0,"dev_name"]:"";
		}
	    if (boot_device != "")
		{
		symlink_cdrom ($["dev_name":boot_device, 
                                 "linkname":"/dev/cdrom"]);
		}
	    }
	}
    return;
    }

/*
 * Initialize
 */

global define void FullProbe ()
    ``{
    FloppyReady();		// probe floppy
    ProbeCDROMs();		// probe CDs
    }

global define map CheckPartedValid( string ddevice, map disk, 
				    list partitions, list ppart )
    ``{
    map plist1 = $[];
    map plist2 = $[];
    boolean ret = true;
    y2milestone( "target %1", disk );
    string regex = substring( ddevice, 5 )+"[p]*[0-9]+";
    y2milestone( "ddevice %1 regex %2", ddevice, regex );
    list ps = filter( `p, ppart, ``(regexpmatch( p["name"]:"", regex) ));
    y2milestone( "ps %1", ps );
    integer cyl_blocks = disk["cyl_size"]:1000000 / 1024;
    foreach( `p, ps,
	``{
	integer pnr = tointeger(deletechars(substring(p["name"]:"",size(ddevice)-5),"p"));
	plist1[pnr] = p["size"]:0/cyl_blocks;
	});
    foreach( `p, partitions,
	``{
	plist2[p["nr"]:0] = p["region",1]:0;
	});
    map ext = find( `p, partitions, ``(p["type"]:`unknown==`extended));
    if( ext != nil )
	{
	plist1 = filter( `k, `e, plist1, ``(k!=ext["nr"]:0));
	plist2 = filter( `k, `e, plist2, ``(k!=ext["nr"]:0));
	}
    y2milestone( "plist1 %1", plist1 );
    y2milestone( "plist2 %1", plist2 );
    ret = size(plist1) == size(plist2);
    if( ret )
	{
	foreach( `k, `e, plist1, 
	    ``{
	    if( !haskey( plist2, k ))
		{
		ret = false;
		}
	    else
		{
		integer diff = e - plist2[k]:0;
		ret = diff >= -1 && diff <= 1;
		y2milestone( "k:%1 diff:%2", k, diff );
		}
	    });
	foreach( `k, `e, plist2, 
	    ``{
	    if( !haskey( plist1, k ))
		{
		ret = false;
		}
	    else
		{
		integer diff = e - plist1[k]:0;
		ret = diff >= -1 && diff <= 1;
		y2milestone( "k:%1 diff:%2", k, diff );
		}
	    });
	}
    if( !ret )
	{
	partitions = [];
	integer reg_start=0;
	foreach( `p, ps,
	    ``{
	    map part = $[];
	    integer pnr = tointeger(substring(p["name"]:"",size(ddevice)-5));
	    part["nr"] = pnr;
	    part["region"] = [ reg_start, p["size"]:0/cyl_blocks ];
	    reg_start = reg_start + part["region",1]:0;
	    part["device"] =  Storage::GetDeviceName( ddevice, pnr );
	    if( part["region",1]:0==0 )
		{
		part["type"] = `extended;
		part["fsid"] = Partitions::fsid_extended_win;
		}
	    else
		{
		part["type"] = pnr<5 ? `primary : `logical;
		part["fsid"] = Partitions::fsid_native;
		}
	    part["fstype"] = Partitions::FsIdToString( part["fsid"]:0 );
	    partitions = add( partitions, part );
	    });
	y2milestone( "new p %1", partitions );
	}
    y2milestone( "disk %1 ret:%2", ddevice, ret );
    return( $["ret":ret, "partitions":partitions ] );
    };

/*
 * check partitions for given disk (as path, i.e. '.sda')
 * returns list as specified in README.target_partition
 */
global define list Check4partitions (string diskdev, map disk, path diskpath)
    ``{
    list partitions = [];

    partitions = SCR::Read(.disk+diskpath+.partitions,
			   Partitions::UseParted() );
    if( is(partitions[0]:"", string ) )
	{
	if( size(partitions[0]:"")>0 )
	    {
	    disk["label"] = partitions[0]:"";
	    }
	else
	    {
	    disk["label"] = Partitions::DefaultPartLabel();
	    }
	}
    else
	{
	disk["label"] = Partitions::DefaultPartLabel();
	}
    disk["max_primary"] = Partitions::MaxPrimary( disk["label"]:"" );
    y2milestone( "disk %1 label %2", diskdev, disk["label"]:"" );
    partitions = remove( partitions, 0 );
    partitions = maplist( `part, partitions,
	``{
	if( part["fsid"]:0 > 0 && (part["fsid"]:0<256||disk["label"]:""=="gpt"))
	    {
	    part["fstype"] = Partitions::FsIdToString( part["fsid"]:0 );
	    }
	return( part );
	});
    partitions = maplist( `p, partitions,
	``{
	p["device"] = Storage::GetDeviceName( diskdev, p["nr"]:0 );
	return( p );
	});
    return partitions;
    };

global define void InitDone()
    ``{
    disks_valid = true;
    y2milestone( "called disks_valid %1", disks_valid );
    }

/*
 * Constructor
 */

global define void StorageDevices ()
    ``{
    if( !Mode::initial && !Mode::config )
	{
	FullProbe ();
	disks_valid = true;
	}
    return;
    }
}
