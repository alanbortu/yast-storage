/**
 * File:	StorageFields.ycp
 * Package:	yast2-storage
 * Summary:	Expert Partitioner
 * Authors:	Arvin Schnell <aschnell@suse.de>
 */
{
    module "StorageFields";


    textdomain "storage";


    import "Storage";
    import "FileSystems";
    import "Partitions";
    import "Arch";
    import "Mode";
    import "HTML";
    import "Integer";


    /**
     * Call callback for every disk of target_map in a well defined sorted order.
     */
    global void IterateTargetMap(map<string, map> target_map, void(map<string, map>, map) callback)
    {
	const map disk_order = $[ `CT_DMRAID : 0, `CT_DISK : 1, `CT_MD : 2, `CT_LOOP : 3,
				  `CT_LVM : 4, `CT_DM : 6, `CT_NFS : 7 ];

	list<string> keys = maplist(string dev, map disk, target_map, { return dev; });
	keys = sort(string a, string b, keys, {
	    integer oa = disk_order[target_map[a,"type"]:`CT_UNKNOWN]:8;
	    integer ob = disk_order[target_map[b,"type"]:`CT_UNKNOWN]:8;
	    return (oa==ob) ? (a<b) : (oa<ob);
	});

	foreach(string dev, keys, {
	    map disk = target_map[dev]:$[];
	    callback(target_map, disk);
	});
    };


    string UsedByString(symbol ub_type, string used_by)
    {
	switch(ub_type)
	{
	    case `UB_LVM:
		return "LVM " + used_by;
	    case `UB_DM:
		return "DM " + used_by;
	    case `UB_DMRAID:
		return "RAID " + used_by;
	    case `UB_MD:
		return "RAID " + used_by;
	    default:
		return used_by;
	}
    }


    global term TableHeader(list<symbol> fields)
    {
	term header = `header();

	foreach(symbol field, fields, {

	    switch (field)
	    {
		case `device:
		    // Column header
		    header = add(header, _("Device"));
		    break;

		case `size:
		    // Column header
		    header = add(header, `Right(_("Size")));
		    break;

		case `type:
		    // Column header
		    header = add(header, _("Type"));
		    break;

		case `format:
		    // Column header, abbreviation for "format" (to format a partition)
		    header = add(header, `Right(_("F")));
		    break;

		case `fs_type:
		    // Column header, abbreviation for "Filesystem Type"
		    header = add(header, _("FS Type"));
		    break;

		case `mount_point:
		    // Column header
		    header = add(header, _("Mount Point"));
		    break;

		case `mount_by:
		    // Column header
		    header = add(header, _("Mount By"));
		    break;

		case `used_by:
		    // Column header
		    header = add(header, _("Used By"));
		    break;

		case `start_cyl:
		    // Column header
		    header = add(header, `Right(_("Start")));
		    break;

		case `end_cyl:
		    // Column header
		    header = add(header, `Right(_("End")));
		    break;

		case `fs_id:
		    // Column header
		    header = add(header, `Right(_("FS Id")));
		    break;

		case `uuid:
		    // Column header
		    header = add(header, _("UUID"));
		    break;

		case `label:
		    // Column header
		    header = add(header, _("Label"));
		    break;

		case `udev_path:
		    // Column header
		    header = add(header, _("Device Path"));
		    break;

		case `udev_id:
		    // Column header
		    header = add(header, _("Device ID"));
		    break;

		case `bios_id:
		    // Column header
		    header = add(header, _("BIOS ID"));
		    break;

		case `disk_label:
		    // Column header
		    header = add(header, _("Disk Label"));
		    break;

		case `lvm_metadata:
		    // Column header
		    header = add(header, _("Metadata"));
		    break;

		case `pe_size:
		    // Column header, abbreviation for "Physical Extent"
		    header = add(header, _("PE Size"));
		    break;

		case `stripes:
		    // Column header
		    header = add(header, _("Stripes"));
		    break;

		case `raid_type:
		    // Column header
		    header = add(header, _("RAID Type"));
		    break;

		case `chunk_size:
		    // Column header
		    header = add(header, _("Chunk Size"));
		    break;

		case `parity_algorithm:
		    // Column header
		    header = add(header, _("Parity Algorithm"));
		    break;

		default:
		    y2error("unknown field %1", field);
		    header = add(header, "error");
		    break;
	    }

	});

	return header;
    }


    string Helptext(symbol field, symbol style)
    {
	string ret = "<p>";

	switch (field)
	{
	    case `device:
		ret = ret + "<b>Device</b> tells the kernel name of the device.";
		break;

	    case `chunk_size:
		ret = ret + "<b>Chunk Size</b> tells the chunk size for RAID devices.";
		break;

	    case `mount_by:
		// description of a table column or overview entry
		ret = ret + "<b>Mount By</b> indicates how the file system is
mounted: (Kernel) by Kernel Name, (Label) by File System Label, (UUID) by File
System UUID, (ID) by Device ID, and (Path) by Device Path.";
		break;

	    case `mount_point:
		// description of a table column or overview entry
		ret = ret + "<b>Mount Point</b> shows where the file system is
or will be mounted.";

		if (Mode::normal() || true)
		    // description of a table column or overview entry
		    ret = ret + " " + "An asterisk (*) after the mount point
indicates a file system that is currently not mounted (for example, because it
has the <tt>noauto</tt> option set in <tt>/etc/fstab</tt>).";
		break;

	    case `parity_algorithm:
		ret = ret + "<b>Parity Algorithm</b> tells the parity
algorithm for RAID devices with RAID type 5.";
		break;

	    case `raid_type:
		ret = ret + "<b>RAID Type</b> tells the RAID type, also called
RAID level, for RAID devices.";
		break;

	    case `size:
		ret = ret + "<b>Size</b> tells the size of the device.";
		break;

	    case `used_by:
		// description of a table column or overview entry
		ret = ret + "<b>Used By</b> tells if a device is used by
e.g. RAID or LVM. If you do not use such things, it is perfectly normal for
this column to be empty.";
		break;

	    default:
		y2error("unknown field %1", field);
		ret = ret + "error";
		break;
	}

	ret = ret + "</p>";

	return ret;
    }


    string MakeSubInfo(map disk, map part, symbol field, symbol style)
    {
	map data = (part == nil ? disk : part);

	switch (field)
	{
	    case `device:
	    {
		string value = data["device"]:"";
		if (style == `table)
		    return value;
		else
		    return sformat(_("Device: %1"), value);
	    }

	    case `size:
	    {
		string value = Storage::KByteToHumanString(data["size_k"]:0);
		if (style == `table)
		    return value;
		else
		    return sformat(_("Size: %1"), value);
	    }

	    case `type:
	    {
		string value = "";

		if (part == nil)
		{
		    string disk_device = disk["device"]:"";
		    string vendor = disk["vendor"]:"";
		    string model = disk["model"]:"";

		    if ((model != "") && (vendor != ""))
			value = vendor + "-" + model;
		    else
			value = vendor + model;

		    if (value == "")
		    {
			if (disk["bus"]:"" == "RAID")
			{
			    value = "RAID " + disk_device;
			}
			else if(disk["type"]:`CT_UNKNOWN==`CT_LVM)
			{
			    value = "LVM" + (disk["lvm2"]:false ? "2 " : " ") + disk["name"]:"";
			}
			else if(disk["type"]:`CT_UNKNOWN==`CT_DMRAID)
			{
			    value = "BIOS RAID " + disk["name"]:"";
			}
			else
			{
			    // label text
			    vendor = sformat(_("DISK %1"), substring(disk_device, 5));
			}
		    }
		}
		else
		{
		    value = part["fstype"]:"";
		}
		if (style == `table)
		    return value;
		else
		    return sformat(_("Type: %1"), value);
	    }

	    case `format:
	    {
		string value = "";
		if (part == nil) {
		    if (disk["dasdfmt"]:false)
			value = value + "X";
		} else {
		    if (part["enc_type"]:`none != `none)
			value = value + "C";
		    if (part["format"]:false)
			value = value + "F";
		}
		if (style == `table)
		    return value;
		else
		    return sformat(_("Format: %1"), value);
	    }

	    case `encrypted:
	    {
		string value = data["enc_type"]:`none != `none ? _("Yes") : _("No");
		if (style == `table)
		    return value;
		else
		    return sformat(_("Encrypted: %1"), value);
	    }

	    case `fs_type:
	    {
		string value = FileSystems::GetName(data["used_fs"]:`unknown, "");
		if (style == `table)
		    return value;
		else
		    return sformat(_("File System: %1"), value);
	    }

	    case `mount_point:
	    {
		string value = data["mount"]:"";
		if (Mode::normal() && data["inactive"]:false )
		    value = value + " *";
		if (style == `table)
		    return value;
		else
		    return sformat(_("Mount Point: %1"), value);
	    }

	    case `mount_by:
	    {
		string value = "";
		if (data["mount"]:"" != "") {
		    map tmp = $[ `device : "Kernel", `uuid : "UUID", `label : "Label", `id : "ID", `path : "Path" ];
		    symbol mount_by = data["mountby"]:`device;
		    value = tmp[mount_by]:"";
		}
		if (style == `table)
		    return value;
		else
		    return sformat(_("Mount By: %1"), value);
	    }

	    case `used_by:
	    {
		string value = UsedByString(data["used_by_type"]:`UB_NONE, data["used_by"]:"");
		if (style == `table)
		    return value;
		else
		    return sformat(_("Used By: %1"), value);
	    }

	    case `uuid:
	    {
		string value = data["uuid"]:"";
		if (style == `table)
		    return value;
		else
		    return sformat(_("UUID: %1"), value);
	    }

	    case `label:
	    {
		string value = (part == nil) ? "" : data["label"]:"";
		if (style == `table)
		    return value;
		else
		    return sformat(_("Label: %1"), value);
	    }

	    case `udev_path:
	    {
		string value = data["udev_path"]:"";
		if (style == `table)
		    return value;
		else
		    return sformat(_("Path: %1"), value);
	    }

	    case `udev_id:
	    {
		if (style == `table) {
		    return data["udev_id", 0]:"";
		} else {
		    integer n = size(data["udev_id"]:[]);
		    return mergestring(maplist(integer i, Integer::Range(n == 0 ? 1 : n), {
			return sformat(_("ID %1: %2"), i+1, data["udev_id", i]:"");
		    }), HTML::Newline());
		}
	    }

	    case `bios_id:
	    {
		string value = data["bios_id"]:"";
		if (style == `table)
		    return value;
		else
		    return sformat(_("BIOS ID: %1"), value);
	    }

	    case `disk_label:
	    {
		string value = (part == nil) ? toupper(data["label"]:"") : "";
		if (style == `table)
		    return value;
		else
		    return sformat(_("Disk Label: %1"), value);
	    }

	    case `vendor:
	    {
		string value = data["vendor"]:"";
		if (style == `table)
		    return value;
		else
		    return sformat(_("Vendor: %1"), value);
	    }

	    case `model:
	    {
		string value = data["model"]:"";
		if (style == `table)
		    return value;
		else
		    return sformat(_("Model: %1"), value);
	    }

	    case `bus:
	    {
		string value = data["bus"]:"";
		if (style == `table)
		    return value;
		else
		    return sformat(_("Bus: %1"), value);
	    }

	    case `lvm_metadata:
	    {
		string value = "";
		if (disk["type"]:`CT_UNKNOWN == `CT_LVM && part == nil)
		    value = disk["lvm2"]:true ? "LVM2" : "LVM1";
		if (style == `table)
		    return value;
		else
		    return sformat(_("Metadata Type: %1"), value);
	    }

	    case `pe_size:
	    {
		string value = "";
		if (disk["type"]:`CT_UNKNOWN == `CT_LVM && part == nil)
		    value = Storage::ByteToHumanStringWithPrecision(disk["pesize"]:0, 2, true);
		if (style == `table)
		    return value;
		else
		    return sformat(_("Physical Extent Size: %1"), value);
	    }

	    case `stripes:
	    {
		string value = "";
		if (disk["type"]:`CT_UNKNOWN == `CT_LVM && part != nil)
		{
		    integer stripes = data["stripes"]:1;
		    integer stripesize = data["stripesize"]:0;
		    if (stripes == 1)
			value = sformat("%1", stripes);
		    else
			value = sformat("%1 (%2)", stripes, Storage::KByteToHumanStringWithPrecision(stripesize, 2, true));
		}
		if (style == `table)
		    return value;
		else
		    return sformat(_("Stripes: %1"), value);
	    }

	    case `raid_type:
	    {
		string value = toupper(data["raid_type"]:"");
		if (style == `table)
		    return value;
		else
		    return sformat(_("RAID Type: %1"), value);
	    }

	    case `chunk_size:
	    {
		string value = "";
		if (contains(["raid0", "raid5"], data["raid_type"]:"")) {
		    integer chunksize = data["chunk_size"]:0;
		    value = Storage::KByteToHumanStringWithPrecision(chunksize, 2, true);
		}
		if (style == `table)
		    return value;
		else
		    return sformat(_("Chunk Size: %1"), value);
	    }

	    case `parity_algorithm:
	    {
		string value = "";
		if (contains(["raid5"], data["raid_type"]:"")) {
		    value = data["parity_algorithm"]:"";
		    value = mergestring(splitstring(value, "_"), "-");
		}
		if (style == `table)
		    return value;
		else
		    return sformat(_("Parity Algorithm: %1"), value);
	    }

	    case `num_cyl:
	    {
		string value = "";
		if (part == nil && Storage::IsPartitionable(disk))
		    value = tostring(disk["cyl_count"]:0);
		if (style == `table)
		    return value;
		else
		    return sformat(_("Number of Cylinders: %1"), value);
	    }

	    case `cyl_size:
	    {
		string value = "";
		if (part == nil && Storage::IsPartitionable(disk))
		    value = Storage::ByteToHumanString(disk["cyl_size"]:0);
		if (style == `table)
		    return value;
		else
		    return sformat(_("Cylinder Size: %1"), value);
	    }

	    case `start_cyl:
	    {
		string value = "";
		if (Storage::IsPartitionable(disk)) {
		    if (part == nil)
			value = tostring(0);
		    else
			value = tostring(part["region", 0]:0);
		}
		if (style == `table)
		    return value;
		else
		    return sformat(_("Start Cylinder: %1"), value);
	    }

	    case `end_cyl:
	    {
		string value = "";
		if (Storage::IsPartitionable(disk)) {
		    if (part == nil)
			value = tostring(disk["cyl_count"]:0 - 1);
		    else
			value = tostring(part["region", 0]:0 + part["region", 1]:0 - 1);
		}
		if (style == `table)
		    return value;
		else
		    return sformat(_("End Cylinder: %1"), value);
	    }

	    case `fs_id:
	    {
		integer fs_id = data["fsid"]:0;
		string value = Partitions::ToHexString(fs_id) + " " + Partitions::FsIdToString(fs_id);
		if (style == `table)
		    return value;
		else
		    return sformat(_("FS Id: %1"), value);
	    }
	    break;

	    case `file_path:
	    {
		string value = data["fpath"]:"";
		if (style == `table)
		    return value;
		else
		    return sformat(_("File Path: %1"), value);
	    }

	    default:
	    {
		y2error("unknown field %1", field);
		return "error";
	    }
	}
    }


    term TableRow(list<symbol> fields, map disk, map part)
    {
	string device = (part == nil) ? disk["device"]:"" : part["device"]:"";

	term row = list::reduce(term tmp, symbol field, `item(`id(device)), fields, {
	    return add(tmp, MakeSubInfo(disk, part, field, `table));
	});

	return row;
    }


    global boolean AlwaysHideDisk(map<string, map> target_map, map disk)
    {
	boolean real_disk = Storage::IsPartitionable(disk);
	symbol type = disk["type"]:`CT_UNKNOWN;

	if (type == `CT_DISK && !real_disk)
	    return true;

	if (!contains([ `CT_DISK, `CT_DMRAID, `CT_LVM ], type))
	    return true;

	return false;
    }


    global boolean AlwaysHidePartition(map<string, map> target_map, map disk, map partition)
    {
	if (partition["fsid"]:0 == Partitions::fsid_mac_hidden)
	    return true;

	if (disk["used_by_type"]:`UB_NONE == `UB_DMRAID)
	    return true;

	return false;
    }


    /**
     * Predicate function for Table and TableContents.
     */
    global symbol PredicateAll(map disk, map partition)
    {
	return `showandfollow;
    }


    /**
     * Predicate function for Table and TableContents.
     */
    global symbol PredicateDiskType(map disk, map partition, list<symbol> disk_types)
    {
	if (partition == nil)
	{
	    if (contains(disk_types, disk["type"]:`CT_UNKNOWN))
		return `showandfollow;
	    else
		return `ignore;
	}
	else
	{
	    return `show;
	}
    }


    /**
     * Predicate function for Table and TableContents.
     */
    global symbol PredicateDiskDevice(map disk, map partition, list<string> disk_devices)
    {
	if (partition == nil)
	{
	    if (contains(disk_devices, disk["device"]:""))
		return `follow;
	    else
		return `ignore;
	}
	else
	{
	    return `show;
	}
    }


    /**
     * Predicate function for Table and TableContents.
     */
    global symbol PredicateDevice(map disk, map partition, list<string> devices)
    {
	if (partition == nil)
	{
	    if (contains(devices, disk["device"]:""))
		return `showandfollow;
	    else
		return `follow;
	}
	else
	{
	    if (contains(devices, partition["device"]:""))
		return `show;
	    else
		return `ignore;
	}
    }


    /**
     * Predicate function for Table and TableContents.
     */
    global symbol PredicateUsedByDevice(map disk, map partition, list<string> devices)
    {
	// TODO: this should come from libstorage
	string UsedByDevice(map tmp)
	{
	    if (tmp["used_by_type"]:`UB_NONE == `UB_DM)
		return "/dev/mapper/" + tmp["used_by"]:"";
	    else
		return "/dev/" + tmp["used_by"]:"";
	}
    
	if (partition == nil)
	{
	    if (contains(devices, UsedByDevice(disk)))
		return `showandfollow;
	    else
		return `follow;
	}
	else
	{
	    if (contains(devices, UsedByDevice(partition)))
		return `show;
	    else
		return `ignore;
	}
    }


    /**
     * The predicate function determines whether the disk/partition is
     * included. The predicate function takes two arguments, disk and
     * partition. For disks predicate is called with the partitions set to
     * nil.
     *
     * Possible return values for predicate:
     * `show, `follow, `showandfollow, `ignore
     */
    global list<term> TableContents(list<symbol> fields, map<string, map> target_map,
				    symbol(map, map) predicate)
    {
	list<term> contents = [];

	void callback(map<string, map> target_map, map disk)
	{
	    symbol disk_predicate = predicate(disk, nil);

	    if (!AlwaysHideDisk(target_map, disk) &&
		contains([`show, `showandfollow], disk_predicate))
	    {
		term row = StorageFields::TableRow(fields, disk, nil);
		contents = add(contents, row);
	    }

	    if (contains([`follow, `showandfollow], disk_predicate))
	    {
		list<map> partitions = disk["partitions"]:[];

		foreach(map partition, partitions, {

		    symbol part_predicate = predicate(disk, partition);

		    if (!AlwaysHidePartition(target_map, disk, partition) &&
			contains([`show, `showandfollow], part_predicate))
		    {
			term row = StorageFields::TableRow(fields, disk, partition);
			contents = add(contents, row);
		    }
		});
	    }
	}

	IterateTargetMap(target_map, callback);

	return contents;
    }


    global term Table(list<symbol> fields, map<string, map> target_map,
		      symbol(map, map) predicate)
    {
	term header = TableHeader(fields);
	list<term> content = TableContents(fields, target_map, predicate);

	return `Table(`opt(`keepSorting), header, content);
    }


    global string TableHelptext(list<symbol> fields)
    {
	string initial = "<p>The table contains:</p>";

	string helptext = list::reduce(string tmp, symbol field, initial, fields, {
	    return tmp + Helptext(field, `table);
	});

	return helptext;
    }


    /**
     * The device must be the device entry in the target-map, e.g. "/dev/sda1",
     * not something like "LABEL=test".
     */
    global string OverviewContents(list<symbol> fields, map<string, map> target_map, string device)
    {
	map disk = target_map[device]:nil;
	map part = nil;

	if (disk == nil)
	{
	    foreach(string s, map d, target_map, {
		part = find(map p, d["partitions"]:[], { return p["device"]:"" == device; });
		if (part != nil) {
		    disk = d;
		    break;
		}
	    });
	}

	list< list<symbol> > splitfields(list<symbol> fields)
	{
	    list< list<symbol> > ret = [];

	    list<symbol> tmp = [];
	    foreach(symbol field, fields, {
		if (substring(tostring(field), 0, 8) == "`heading") {
		    if (size(tmp) > 1)
			ret = add(ret, tmp);
		    tmp = [ field ];
		} else {
		    tmp = add(tmp, field);
		}
	    });
	    if (size(tmp) > 1)
		ret = add(ret, tmp);

	    return ret;
	}

	string Heading(symbol field)
	{
	    switch (field) {
		case `heading_device:
		    return _("Device:");
		case `heading_filesystem:
		    return _("File System:");
		case `heading_hd:
		    return _("Hard Disk:");
		case `heading_lvm:
		    return _("LVM:");
		case `heading_md:
		    return _("RAID:");
		default:
		    y2error("unknown field %1", field);
		    return "error";
	    }
	}

	list<string> List(list<symbol> fields)
	{
	    return maplist(symbol field, fields, {
		return MakeSubInfo(disk, part, field, `overview);
	    });
	};

	string content = mergestring(maplist(list<symbol> subfields, splitfields(fields), {
	    return HTML::Heading(Heading(subfields[0]:`none)) + HTML::List(List(sublist(subfields, 1)));
	}), "");

	return content;
    }


    global term Overview(list<symbol> fields, map<string, map> target_map, string device)
    {
	string contents = OverviewContents(fields, target_map, device);

	return `RichText(`opt(`hstretch, `vstretch), contents);
    }


    global string OverviewHelptext(list<symbol> fields)
    {
	fields = filter(symbol field, fields, { return substring(tostring(field), 0, 8) != "`heading"; });

	string initial = "<p>The overview contains:</p>";

	string helptext = list::reduce(string tmp, symbol field, initial, fields, {
	    return tmp + Helptext(field, `overview);
	});

	return helptext;
    }
}
