/**
 * Module: 		StorageControllers.ycp
 *
 * Authors:		Klaus Kaempf <kkaempf@suse.de> (initial)
 *
 * Purpose:
 * This module does all floppy disk related stuff:
 * - Detect the floppy devices
 *
 * SCR: Read(.probe.storage)
 *
 * $Id$
 */
{
    module "StorageControllers";

    import "Arch";
    import "ModuleLoading";
    import "HwStatus";
    import "Initrd";
    import "Kernel";
    import "Storage";
    import "StorageDevices";
    import "StorageClients";
    import "Label";
    import "Popup";
    import "Linuxrc";

    textdomain "storage";

    // list of loaded modules and arguments 
    // needed for modules.conf writing
    // must be kept in order (-> no map !)
    // must be searchable (-> separate lists for names and args)

    list<string> moduleNames = [];
    list<string> moduleArgs = [];

    list<list> ModToInitrdLx = [];
    list<list> ModToInitrd = [];

    list<map> controllers = [];	// set by "Probe"


    /**
     * Probe storage controllers
     * probing, loading modules
     *
     * @returns integer	number of controllers, 0 = none found 
     */
global integer Probe()
{
    y2milestone( "StorageControllers::Probe()" );

    // probe 'storage' list

    controllers = (list<map>)SCR::Read (.probe.storage);

    if (!Arch::s390 () && size (controllers) == 0)
	{
	y2milestone("no controllers");
	}
    return size (controllers);
}


// start a controller (by loading its module)
// return true if all necessary modules were actually loaded
// return false if loading failed or was not necessary at all

boolean StartController(map controller)
{
    // check module information
    // skip controller if no module info available

    list<map> module_drivers = controller["drivers"]:[];

    if (size (module_drivers) == 0)
	return false;

    // get list of modules from /proc/modules
    SCR::UnmountAgent (.proc.modules);
    map loaded_modules = (map)SCR::Read(.proc.modules);		

    // loop through all drivers checking if one is already active
    // or if one is already listed in /proc/modules

    boolean already_active = false;
    foreach (map modulemap, module_drivers,
	``{
	if( modulemap["active"]:true ||
	    size( loaded_modules[modulemap["modules",0,0]:""]:$[] ) > 0 )
	    {
	    already_active = true;
	    if( modulemap["active"]:true )
		{
		ModToInitrdLx = add( ModToInitrdLx, 
		                     [ modulemap["modules",0,0]:"",
				       modulemap["modules",0,1]:"" ] );
		y2milestone( "startController ModToInitrdLx %1", ModToInitrdLx );
		y2milestone( "startController ModToInitrd %1", ModToInitrd );
		}
	    }
	});

    // save unique key for HwStatus::Set()
    string unique_key = controller["unique_key"]:"";

    if (already_active)
	{
	HwStatus::Set (unique_key, `yes);
	return false;
	}

    boolean stop_loading = false;
    boolean one_module_failed = false;

    // loop through all drivers defined for this controller
    // break after first successful load
    //   no need to check "active", already done before !
    foreach (map modulemap, module_drivers,
	``{
	y2milestone ("startController modulemap: %1", modulemap);
	boolean module_modprobe = modulemap["modprobe"]:false;

	boolean all_modules_loaded = true;

	if (!stop_loading)
	    {
	    foreach (list module_entry, modulemap["modules"]:[],
		``{
		string module_name = module_entry[0]:"";
		string module_args = module_entry[1]:"";

		    // load module if not yet loaded
		    if( !contains (moduleNames, module_name) )
			{
			symbol load_result = `ok;
			if( Linuxrc::manual () )
			    {
			    list vendor_device = 
				ModuleLoading::prepareVendorDeviceInfo(controller);
			    load_result = 
				ModuleLoading::Load( module_name, module_args,
						     vendor_device[0]:"",
						     vendor_device[1]:"", true,
						     module_modprobe );
			    }
			else
			    {
			    load_result = 
				ModuleLoading::Load( module_name, module_args,
						     "", "", false, 
						     module_modprobe );
			    }
			y2milestone( "startController load_result %1", load_result );

			if (load_result == `fail)
			    {
			    all_modules_loaded = false;
			    }
			else if (load_result == `dont)
			    {
			    all_modules_loaded = true;
			    }
			else		// load ok
			    {
			    // save data for modules.conf writing
			    moduleNames = add (moduleNames, module_name);
			    moduleArgs  = add (moduleArgs, module_args);

			    y2milestone( "startController moduleNames %1", moduleNames );
			    y2milestone( "startController moduleArgs %1", moduleArgs );
			    ModToInitrd = add( ModToInitrd, [ module_name,
			                                      module_args ] );
			    y2milestone( "startController ModToInitrd %1", ModToInitrd );
			    y2milestone( "startController ModToInitrdLx %1", ModToInitrdLx );
			    }
			} // not yet loaded

		// break out of module load loop if one module failed

		if (!all_modules_loaded)
		    {
		    one_module_failed = true;
		    }
		}); // foreach module of current driver info

	    } // stop_loading

	// break out of driver load loop if all modules of
	//   the current driver loaded successfully

	if (all_modules_loaded)
	    {
	    stop_loading = true;
	    }

	});  // foreach driver

    HwStatus::Set (unique_key, one_module_failed?`no:`yes);

    return !one_module_failed;
}


// local function to go through list of resources (list of maps)
// checking if '"active":true' is set.

boolean AnyActive(list<map> resources)
{
    boolean active = size(resources)==0;

    foreach (map res, resources,
    ``{
	if (res["active"]:false)
	    active = true;
    });

    return active;
}

/**
 * Start storage related USB and FireWire stuff
 *
 */
global void StartHotplugStorage()
{
    import "Hotplug";

    // If USB capable, there might be an usb storage device (i.e. ZIP)
    // activate the module _last_ since it might interfere with other
    // controllers (i.e. having usb-storage first might result in
    // /dev/sda == zip which is bad if the zip drive is removed :-}).

    if (Hotplug::haveUSB)
    {
	// if loading of usb-storage is successful, re-probe for floppies
	// again since USB ZIP drives are regarded as floppies.

	if (ModuleLoading::Load ("usb-storage", "", "", "USB Storage", Linuxrc::manual (), true) == `ok)
	{
	    StorageDevices::FloppyReady();
	}
    }

    if (Hotplug::haveFireWire)
    {
	// load sbp2
	ModuleLoading::Load ("sbp2", "", "", "SBP2 Protocol", Linuxrc::manual (), true);
    }
}

/**
 * @param	none
 * @returns void
 * Init storage controllers (module loading)
 * Must have called StorageControllers::probe() before !
// O: list of [ loaded modules, module argument ]
 */

global void Initialize()
{
    moduleNames = [];
    moduleArgs = [];
    integer cindex = 0;
    boolean module_loaded = false;

    ModToInitrd = [];
    ModToInitrdLx = [];

    y2milestone("Initialize controllers: %1", controllers);

    // loop through all controller descriptions from hwprobe

    // use while(), continue not allowed in foreach()
    while( !Arch::s390() && cindex < size(controllers) )
	{
	map controller = controllers[cindex]:$[];
	y2milestone( "Initialize controller %1", controller );

	if( size(controller["requires"]:[])>0 )
	    {
	    foreach( string s, controller["requires"]:[],
		``{
		Storage::AddHwPackage( s );
		});
	    }

	cindex = cindex + 1;

	// check BIOS resources on 'wintel' compatible systems
	if (Arch::board_wintel ())
	{
	    // for every controller it is checked whether
	    // the controller is disabled in BIOS
	    // this is done by checking for an active IO or memory resource

	    if( !(AnyActive (controller["resource", "io"]:[])
		  || AnyActive (controller["resource", "mem"]:[])))
	    {
		y2milestone( "Initialize controller %1 disabled in BIOS", 
			     controller["device"]:"" );

		// continue if disabled in BIOS
		continue;
	    }
	}

	module_loaded = StartController(controller) || module_loaded;
	} // while (controller)

    y2milestone( "Initialize module_loaded %1", module_loaded );
    y2milestone( "Initialize ModToInitrdLx %1 ModToInitrd %2 ", ModToInitrdLx,
                 ModToInitrd );
    ModToInitrd = (list<list>)union( ModToInitrdLx, ModToInitrd );
    y2milestone( "Initialize ModToInitrd %1", ModToInitrd );

    if( size(ModToInitrd)>1 )
	{
	list<string> ls = filter( string s, 
	                          splitstring( (string)SCR::Read( .etc.install_inf.InitrdModules ), 
				               " " ),
				  ``(size(s)>0) );
	y2milestone( "Initialize ls=%1", ls );
	integer i = 0;
	map lrmods = listmap( string s, ls, ``{i=i+1; return( $[ s : i ] );});
	y2milestone( "Initialize lrmods=%1", lrmods );
	i = 0;
	while( i<size(ModToInitrd) )
	    {
	    integer j=i+1;
	    while( j<size(ModToInitrd) )
		{
		if( haskey( lrmods, ModToInitrd[i,0]:"" ) &&
		    haskey( lrmods, ModToInitrd[j,0]:"" ) &&
		    lrmods[ModToInitrd[i,0]:""]:0 > 
			lrmods[ModToInitrd[j,0]:""]:0 )
		    {
		    list tmp = ModToInitrd[i]:[];
		    ModToInitrd[i] = ModToInitrd[j]:[];
		    ModToInitrd[j] = tmp;
		    }
		j = j+1;
		}
	    i=i+1;
	    }
	y2milestone( "Initialize ModToInitrd %1", ModToInitrd );
	}
    foreach( list s, ModToInitrd,
	``{
	Initrd::AddModule( s[0]:"", s[1]:"" );
	});

    // load all raid personalities
    SCR::Execute(.target.modprobe, "raid0", "" );
    SCR::Execute(.target.modprobe, "raid1", "" );
    SCR::Execute(.target.modprobe, "raid5", "" );
    SCR::Execute(.target.modprobe, "raid6", "" );
    SCR::Execute(.target.modprobe, "multipath", "" );

    StartHotplugStorage();

    y2milestone("Initialize all controllers initialized module_loaded:%1", module_loaded);

    StorageDevices::InitDone();
    if( module_loaded )
	Storage::ReReadTargetMap();
    y2milestone( "Initialize calling EnablePopup()" );
    StorageClients::EnablePopup();
};

}
