/**
 * Module: 		FileSystems.ycp
 *
 * Authors:		Johannes Buchhold (jbuch@suse.de)
 *
 * Purpose: 		
 * These module contains the supported filesystems and their settings. 	
 * 
 *				
 * $Id$
 */
{
  module "FileSystems";
  textdomain "storage";
  import "Arch";
  import "Partitions";
 


  
  global list system_m_points = [ "/", "/boot", "/usr" , "/var", "/opt"];
  global list suggest_m_points = union( system_m_points, 
                                        [ "/home", "/local", ""] );
  global list swap_m_points   = [ "swap", ""  ];

  global string nchars = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";

  /* All supported filesystems */
  map support 	= $[
		   `reiser	: true,
		   `xfs		: true,
		   `ext2        : true,
		   `ext3        : true,
		   `jfs    	: true,
		   `fat16  	: true,
		   `fat32  	: true
  ];

  map capabilities = $[
		   `reiser	: $[ 
		                     "extend":true,  
				     "shrink":true,
		                     "mount_extend":true, 
				     "uuid" : true,
				     "label_length" : 16,
				     "label" : true
				   ],
		   `xfs		: $[ 
		                     "extend":true, 
		                     "mount_extend":true, 
				     "label_length" : 12,
				     "set_label_mount" : true,
				     "uuid" : true,
				     "label" : true
				   ],
		   `ext2        : $[ 
		                     "extend":true,  
		                     "shrink":true,
				     "parted" : true,
				     "uuid" : true,
				     "label_length" : 16,
				     "set_label_mount" : true,
				     "label" : true
				   ],
		   `ext3        : $[ "extend":true,
		                     "shrink":true,
				     "parted" : true,
				     "uuid" : true,
				     "label_length" : 16,
				     "set_label_mount" : true,
				     "label" : true
				   ],
		   `jfs    	: $[ 
				   ],
		   `fat16  	: $[ "shrink":true,
				     "parted" : true,
				   ],
		   `fat32  	: $[ "shrink":true,
				     "parted" : true,
				   ],
		   `swap  	: $[ "extend":true,  
		                     "shrink":true,
				   ],
		   `unknown  	: $[ 
				   ],
  ];


 
    /**
     * Return a map that contains the mount option for each used_fs (-t)
     * @return map
     */
  /*
    to mount_string 
    global define used2typeMap()
    ``{
	return $[
		 `ext2   : "ext2",
		 `ext3   : "ext3",
		 `reiser : "reiserfs",
		 `xfs    : "xfs",
		 `jfs    : "jfs",
		 `fat16  : "vfat",
		 `fat32  : "vfat" ];
    };
  */

global define list GetGeneralFstabOptions()
    ``{
    list options = 
	[ $[
	     `widget : `Left(`CheckBox(`id("opt_readonly"), _("Mount &read-only"), false)),
	     `query_key : "opt_readonly",
	     `help_text : _("<p><b>Mount read-only:</b>
No writable access to the file system is possible. Default is false.</p>
"),
             `type : `boolean,
	     `str_opt : $[ 1 : "ro", "default" : "" ],
	     `str_scan : [[ "ro", 1 ], ["rw", 0 ]],
	   ],
	  $[
	     `widget : `Left(`CheckBox(`id("opt_noatime"), _("No &access time"), false)),
	     `query_key : "opt_noatime",
	     `help_text : _("<p><b>No access time:</b>
Access times are not updated when a file is read. Default is false.</p>"),
             `type : `boolean,
	     `str_opt  : $[ 1 : "noatime", "default" : "" ],
	     `str_scan : [[ "noatime", 1 ], ["atime", 0 ]],
	   ],
	  $[
	     `widget : `Left(`CheckBox(`id("opt_user"), _("Mountable by &user"), false)),
	     `query_key : "opt_user",
	     `help_text : _("<p><b>Mountable by user:</b>
The file system may be mounted by an ordinary user. Default is false.</p>
"),
             `type : `boolean,
	     `str_opt  : $[ 1 : "user", "default" : "" ],
	     `str_scan : [[ "nouser", 0 ], ["user", 1 ]],
	   ]
	];
    return( options );
    };

global define map GetArbitraryOptionField()
    ``{
    map opt = $[
	     `widget : `TextEntry(`id("opt_arbitrary"), _("Arbitrary option &value"), ""),
	     `query_key : "opt_arbitrary",
	     `help_text : _("<p><b>Arbitrary option value:</b>
In this field, type any legal mount option allowed in the fourth field of /etc/fstab.
Mutiple options are separated by commas.</p>
"),
             `type : `text
	   ];
    return( opt );
    };

define map GetNormalFilesystems()``{

  list fat_fst_options =
      [
	$[
	   `widget : `ComboBox(`id("opt_iocharset"), `opt(`editable,`hstretch), _("Char&set for file names"), 
	                       ["", "iso8859-1", "iso8859-15", "iso8859-2", "iso8859-5", "iso8859-7", "iso8859-9", 
			        "sjis", "koi8-r" ]),
	   `query_key : "opt_iocharset",
	   `type : `text,
	   `help_text : _("<p><b>Charset for file names:</b>
Set the charset used for display of file names in Windows partitions.</p>
"),
	   `str_opt : "iocharset=%1",
	   `str_scan : "iocharset=\(.*\)"
	 ],
	$[
	   `widget : `ComboBox(`id("opt_codepage"), `opt(`editable,`hstretch), _("Code&page for short FAT names"), 
	                       ["", "437", "852"]),
	   `query_key : "opt_codepage",
	   `type : `text,
	   `help_text : _("<p><b>Codepage for short FAT names:</b>
This codepage is used for converting to shortname characters on FAT file systems.</p>
"),
	   `str_opt : "codepage=%1",
	   `str_scan : "codepage=\(.*\)"
	 ]
      ];

  list fat32_options =
      [
       $[
	 `widget		: `ComboBox(`id("opt_number_of_fats"), `opt(`hstretch), _("Number of &FATs"), ["auto" , "1", "2"  ]),
	 `query_key	: "opt_number_of_fats",
	 `option_str	: "-f",
	 `help_text	: _("<p><b>Number of FATs:</b>
Specify the number of file allocation tables in the file system. The default is 2.</p>")
       ],
	 $[
	   `widget	: `ComboBox(`id("opt_fat_size"), `opt(`hstretch), _("FAT &size"), ["auto",
											  `item(`id("12"), "12 bit"),
											  `item(`id("16"), "16 bit"),
											  `item(`id("32"), "32 bit") ]),
	   `query_key 	: "opt_fat_size",
	   `option_str	: "-F",
	   `help_text	: _("<p><b>FAT size:</b>
Specifies the type of file allocation tables used (12,  16,  or  32-bit). If auto is specified, YaST2 will automatically select the value most suitable for the file system size.</p>
")
	 ],
	 $[
	   `widget 	: `TextEntry(`id("opt_root_dir_entries"), `opt(`hstretch), _("Root &dir entries"), "auto"),
	   `query_key 	: "opt_root_dir_entries",
	   `option_str	: "-r",
	   `between	: [ 112, -1],
	   `valid_chars 	: "0123456789",
	   `error_text 	: _("The minimum size for \"Root dir entries\" is 112. Please try again."),
	   `help_text	: _("<p><b>Root dir entries:</b>
Select the number of entries available in the root directory.</p>")
	 ]
  ];

  
  list reiserfs_options =   [
			     $[
			       `widget     	: `ComboBox(`id("opt_hash"), `opt(`hstretch), _("Hash &function"), ["auto", "r5", "tea" ,"rupasov" ]),
			       `query_key		: "opt_hash",
			       `option_str	: "--hash",
			       `option_blank    : true,
			       `help_text		: _("<p><b>Hash function:</b>
This specifies the name of the hash function to use to sort the file names in directories.</p>")
			     ],
			       $[
				 `widget     	: `ComboBox(`id("opt_format"), `opt(`hstretch), _("FS &revision"), ["auto", "3.5", "3.6" ]),
				 `query_key		: "opt_format",
				 `option_str	: "--format",
			         `option_blank  : true,
				 `help_text		: _("<p><b>FS revision:</b>
This option defines the reiserfs format revision to use. '3.5' is for backwards compatibility with kernels of the 2.2.x series. '3.6' is more recent, but can only be used with kernel versions greater than or equal to 2.4.</p>
")	
			       ]
  ];
  
  list reiser_fst_options =
      [
	$[
	   `widget : `ComboBox(`id("opt_journal"), `opt(`hstretch), _("Data &journalling mode"), 
	                       ["journal", "ordered", "writeback"]),
	   `default   : "ordered",
	   `query_key : "opt_journal",
	   `type : `text,
	   `help_text : _("<p><b>Data journalling mode:</b>
Specifies  the  journalling  mode  for  file  data.
<p>journal -- All data is committed into the  journal  prior  to  being
written into the main file system.
<p>ordered -- All data is forced directly out to the main file system 
prior to its  metadata  being committed to the journal.
<p>writeback -- Data ordering is not preserved.</p>
"),
	   `str_opt : "data=%1",
	   `str_scan : "data=\(.*\)"
	 ]
      ];

  list xfs_options	=  [
			    $[
			      `widget	: `ComboBox(`id("opt_block_size"), `opt(`hstretch), _("Block &size"), [ "auto", "512", "1024", "2048","4092","8192", "16384","32768","65536"]),
			      
			      `query_key : "opt_block_size",
			      `option_str: "-b size=",
			      `help_text	: _("<p><b>Block size</b> This option specifies the fundamental block size of the file system.</p>")
			    ],
			      $[
				`widget   	: `ComboBox(`id("opt_bytes_per_indoe"), `opt(`hstretch), _("Bytes per &inode"),["auto","256", "512", "1024", "2048"]),
				`query_key	: "opt_bytes_per_indoe",
				`option_str  	: "-i size=",
				`help_text  	: _("<p><b>Bytes per inode:</b>
This option specifies the inode size of the file system.</p>
")
			      ],
			      $[
				`widget   	: `ComboBox(`id("opt_max_inode_space"), `opt(`hstretch), _("&Percentage of inode space"),["auto", "5", "10", "15", "20","25","30",
																	 "35", "40", "45", "50", "55", "60", "65",
																	 "70", "75", "80", "85", "90", "95",
																	 `item(`id("0"), "100") ]),
				`query_key	: "opt_max_inode_space",
				`option_str  	: "-i maxpct=",
				`help_text  	: _("<p><b>Percentage of inode space:</b>
The option \"Percentage of inode space\" specifies the maximum percentage of space in the file system that can be allocated to inodes.</p>
")
			      ],
			      $[
				`widget   	: `ComboBox(`id("opt_inode_align"), `opt(`hstretch), _("Inode &aligned"),[ "auto", `item(`id("1"), "true"),
															 `item( `id("0"), "false")  ]),
				`query_key	: "opt_inode_align",
				`option_str  	: "-i align=",
				`help_text  	: _("<p><b>Inode aligned:</b>
The option \"Inode aligned\" is used to specify whether inode allocation is or 
is not aligned. The default is that inodes are aligned. Aligned inode access 
is normally more efficient than unaligned access.</p>
")
			      ]
  ];

  
  list jfs_options = [
		      $[
			`widget 		: `TextEntry(`id("opt_log_size"), `opt(`hstretch),_("&Log size in megabytes"), "auto"),
			`query_key	: "opt_log_size",
			`option_str	: "-ls:",
			// no way to find out the max log size ????
			`between		: [ 0 , -1 ], //  -> -1 = infinite
			`valid_chars 	: "0123456789",
			`error_text 	: _("The \"Log size\" value is incorrect.\nPlease enter a value greater than zero."),
			// xgettext: no-c-format						       
			`help_text  	: _("<p><b>Log size</b>
Set the log size (in megabytes). If auto, the default is 40% of the aggregate size.</p>")
		      ],
		      $[	
			`widget		: `CheckBox(`id("opt_blocks_utility"), _("Invoke Bad Blocks List &Utility"), false),
			`query_key	: "opt_blocks_utility",
			`option_str	: "-l"
		      ]
  ];
  
  list ext2and3_options  =  [
			       $[
				 `widget     	: `TextEntry(`id("opt_raid"), `opt(`hstretch), _("Stride &length in blocks"), "none" ),
				 `query_key	: "opt_raid",
				 `option_str	: "-Rstride=",
				 `valid_chars	: "0123456789",
				 `between		: [ 1, -1],
				 `error_text	: _("The \"Stride length in blocks\" value is not possible.\nPlease select a value greater than 1."),
				 `help_text	: _("<p><b>Stride length in blocks:</b>  
Set RAID-related options for the file system. Currently the only supported 
argument is 'stride' which takes the number of blocks in a 
RAID stripe as its argument.</p>
")
			       ],
				 $[
				   `widget     	: `ComboBox(`id("opt_blocksize"), `opt(`hstretch), _("Block &size in bytes"), ["auto","1024", "2048","4096" /*,"8192", "16384","32768"*/ ]),
				   `query_key	: "opt_blocksize",
				   `option_str	: "-b",
				   `help_text  	: _("<p><b>Block size:</b>
Specify the size of blocks in bytes. Valid block size values are 1024, 2048, and 4096 bytes per block. If auto is selected, the block size is determined by the file system size and the expected use of the file system.</p>\n")
				 ],
				 $[
				   `widget   	: `ComboBox(`id("opt_bytes_per_indoe"), `opt(`hstretch), _("Bytes per &inode"),["auto","1024", "2048","4096","8192", "16384","32768" ]),
				   `query_key	: "opt_bytes_per_indoe",
				   `option_str 	: "-i",
				   `help_text  	: _("<p><b>Bytes per inode:</b>
Specify the bytes to inode ratio. YaST2 creates an inode for every &lt;bytes-per-inode&gt; bytes of space on the disk. The larger the bytes-per-inode ratio, the fewer inodes will be created.
Generally, this value should not be smaller than the block size of the file system, since too many inodes will be created in this case.  It is not possible to expand the
number of inodes on a file system after its creation, so be sure to enter a reasonable value for this parameter.</p>
")
				 ],
				 $[
				   `widget   	: `TextEntry(`id("opt_reserved_blocks"), `opt(`hstretch), _("Percentage of blocks &reserved for root"), "auto" ),
				   `query_key	: "opt_reserved_blocks",
				   `option_str  : "-m",
				   //`default 	: 5,
				   `between	: [ 0 , 99 ], //  -> -1 = infinite
				   `str_length	: 2,
				   `valid_chars : "0123456789",
				   `error_text  : _("The \"Percentage of blocks reserved for root\" value is incorrect.\nPlease use a value between 0 and 99."),
				   // xgettext: no-c-format						       
				   `help_text  	: _("<p><b>Percentage of blocks reserved for root:</b> Specify the percentage of blocks reserved for the super user. This value defaults to 5%.</p>")
				 ]
      ];


  list ext3_fst_options =
      [
	$[
	   `widget : `ComboBox(`id("opt_journal"), `opt(`hstretch), _("Data journalling mode"), 
	                       ["journal", "ordered", "writeback"]),
	   `default   : "ordered",
	   `query_key : "opt_journal",
	   `type : `text,
	   `help_text : _("<p><b>Data journalling mode:</b>
Specifies  the  journalling  mode  for  file  data.
journal -- All data is committed into the  journal  prior  to  being
written into the main file system.
ordered -- All data is forced directly out to the main file system 
prior to its  metadata  being committed to the journal.
writeback -- Data ordering is not preserved.</p>
"),
	   `str_opt : "data=%1",
	   `str_scan : "data=\(.*\)"
	 ]
      ];


  map RealFileSystems  = $[
		      `ext2	: $[
				    `name 		: "Ext2",
				    `fsid 		: Partitions::fsid_native,
				    `supports_format 	: true,
				    `fsid_item 		: "0x83 Linux ",
				    `fstype 		: "Linux native" ,
				    `crypt 		: true ,
				    `mountpoints 	: suggest_m_points,
				    `mount_option	: "-t ext2",
				    `mount_string	: "ext2",
				    `makefstype		: "ext2",
				    `options  		: ext2and3_options,
		      ],
		      `fat32	: $[
				    `name 		: "FAT",
				    `fsid 		: 12,
				    `supports_format 	: true ,
				    `fsid_item 		: "0x0C Win95 FAT32 ",
				    `fstype 		: "Fat32",
				    `crypt 		: true ,
				    `mountpoints 	: suggest_m_points ,
				    `mount_option	: "-t vfat",
				    `mount_string	: "vfat",
				    `makefstype		: "fat32",
				    `fst_options  	: fat_fst_options,
				    `options 		: fat32_options
					
		      ],
		      `reiser 	: $[
				    `name 		: "ReiserFS",
				    `fsid 		: Partitions::fsid_native,
				    `supports_format 	: true ,
				    `fsid_item 		: "0x83 Linux " ,
				    `fstype 		: "Linux native",
				    `crypt 		: true,
				    `mountpoints 	: suggest_m_points,
				    `mount_option 	: "-t reiserfs",
				    `mount_string	: "reiserfs",
				    `needed_modules	: [ "reiserfs" ],
				    `makefstype		: "reiserfs",
				    `fst_options  	: reiser_fst_options,
				    `options 		: reiserfs_options
		      ],
		      `xfs 	: $[
				    `name 		: "XFS",
				    `fsid 		: Partitions::fsid_native,
				    `supports_format 	: true ,
				    `fsid_item 		: "0x83 Linux " ,
				    `fstype 		: "Linux native" ,
				    `crypt 		: true,
				    `mountpoints 	: suggest_m_points,
				    `mount_option 	: "-t xfs",
				    `mount_string	: "xfs",
				    `needed_modules	: [ "xfs_support", "xfs_dmapi", "xfs" ],
				    `makefstype		: "xfs",
				    `options 		: xfs_options
		      ], 
		      `jfs 	: $[
				    `name 		: "JFS",
				    `fsid 		: Partitions::fsid_native,
				    `supports_format 	: true ,
				    `fsid_item 		: "0x83 Linux " ,
				    `fstype 		: "Linux native" ,
				    `crypt		: true,
				    `mountpoints 	: suggest_m_points,
				    `mount_string	: "jfs",
				    `mount_option	: "-t jfs",
				    `needed_modules	: [ "jfs" ],
				    `makefstype		: "jfs",
				    `options      	: jfs_options
		      ],
		      `ext3 	: $[
				    `name 		: "Ext3",
				    `fsid 		: Partitions::fsid_native,
				    `supports_format 	: true ,
				    `fsid_item 		: "0x83 Linux " ,
				    `fstype 		: "Linux native" ,
				    `crypt		: true,
				    `mountpoints 	: suggest_m_points,
				    `mount_string	: "ext3",
				    `mount_option	: "-t ext3",
				    `needed_modules	: [ "jbd",  "ext3" ],
				    `makefstype		: "ext2", // format ext3 as ext2 !!!!!!!!!!!!!!!
				    `fst_options  	: ext3_fst_options,
				    `options      	: ext2and3_options
		      ],
		      `hfs 	: $[
				    `name 		: "MacHFS",
				    `fsid 		: Partitions::fsid_mac_hfs,
				    `supports_format 	: true,
				    `fsid_item 		: "0x102 Apple_HFS " ,
				    `fstype 		: "Apple_HFS " ,
				    `crypt		: false,
				    `mountpoints 	: [],
				    `mount_string	: "hfs",
				    `mount_option	: "-t hfs",
				    `needed_modules	: [ "hfs" ],
				    `makefstype		: "hfs", 
				    `fst_options  	: [],
				    `options      	: []
		      ]
  ];

  return( RealFileSystems );
  };

			      
  map PseudoFileSystems = $[
			    `lvm	: $[
					    `name 		: "LVM",
					    `fsid 		: Partitions::fsid_lvm,
					    `supports_format 	: false,
					    `fsid_item 		: "0x8E Linux LVM "
			    ],
			    `raid	: $[
					    `name 		: "RAID",
					    `fsid 		: Partitions::fsid_raid,
					    `supports_format 	: false,
					    `fsid_item 		: "0xFD Linux RAID "
			    ],
			    `xbootpdisk : $[
					   `name 		: "PPCBOOT",
					   `fsid 		: Partitions::fsid_prep_chrp_boot,
					   `supports_format 	: false,
					   `fsid_item 		: "0x41 PPC PReP Boot"
			    ],
			    `xhibernate : $[
					   `name 		: "Hibernate",
					   `fsid 		: Partitions::fsid_hibernation,
					   `supports_format 	: false,
					   `fsid_item 		: "0xA0 Hibernation"
			    ]
  ];

  
  map SwapFileSystems = $[
			  `swap 	: $[
					    `name 		: "Swap" ,
					    `fsid 		: Partitions::fsid_swap,
					    `supports_format 	: true ,
					    `fsid_item 		: "0x82 Linux swap ",
					    `fstype 		: "Linux swap",
					    `crypt 		: false,
					    `mountpoints 	: swap_m_points
			    ]
  ];
  

  
  /* FileS build fss map with all supported filesystems ( list support ) */
global define void FileSystems()
    ``{
    if( Arch::sparc64 || Arch::sparc32 )
	{
        support[`fat16] = false;
        support[`fat32] = false;
	}
    if( Arch::ppc )
	{
	support[`xfs] = false;
	}
    if( Arch::s390 )
	{
	support[`xfs] = false;
	}
    if( Arch::alpha )
	{
	support[`reiser] = false;
	}	
    if( Arch::board_mac )
	{
	support[`hfs] = true;
	}
    y2milestone( "support %1", support );
    }
  

 /**
   * Filesystem Definitions
   * @return map map with all supported filesystems
   */
global define map GetAllFileSystems(boolean add_swap, boolean add_pseudo )
    ``{
    map ret = filter( `fs_key, `fs_map, GetNormalFilesystems(), 
                      ``( support[fs_key]:false ));

    if( add_swap )
	{
	ret = union( ret, SwapFileSystems );
	}
    if( add_pseudo )
	{
	ret = union( ret, PseudoFileSystems );
	}
    return ret;
    } 


  global define boolean IsSupported( symbol used_fs)``{
      return support[ used_fs ]:false;
  }
  
  global define map GetFsMap( symbol used_fs )``{
      map allfs =  GetAllFileSystems( true, true  );
      return allfs[ used_fs]:$[];
  }
  
  global define string GetName( symbol used_fs , string default )``{
      map fsmap 	= GetFsMap( used_fs);
      string ret        = fsmap[`name]:"";
      if ( ret == "" ) ret = default;
      return ret;
  }

  global define integer GetFsid( symbol used_fs )``{
      map fsmap 	= GetFsMap( used_fs);
      return fsmap[`fsid]:Partitions::fsid_native;
  }

  global define boolean GetSupportFormat( symbol used_fs )``{
      map fsmap 	= GetFsMap( used_fs);
      return fsmap[`supports_format]:nil;  
  }

  global define string GetFsidItem( symbol used_fs )``{
      map fsmap 	= GetFsMap( used_fs);
      return fsmap[`fsid_item ]:"";  
  }

  global define string GetFstype( symbol used_fs )``{
      map fsmap 	= GetFsMap( used_fs);
      return fsmap[`fstype ]:"";  
  }

  global define boolean GetCrypt( symbol used_fs )``{
      map fsmap 	= GetFsMap( used_fs);
      return fsmap[`crypt ]:nil;  
  }

  global define list GetPossibleMountPoints( symbol used_fs )``{
      map fsmap 	= GetFsMap( used_fs);
      return fsmap[`mountpoints ]:[];  
  }

  global define string GetMountOption( symbol used_fs )``{
      map fsmap 	= GetFsMap( used_fs);
      return fsmap[`mount_option ]:"";  
  }

  global define list GetOptions( symbol used_fs )``{
      map fsmap 	= GetFsMap( used_fs);
      return fsmap[`options ]:[];  
  }

  
    /**
     * Return the mount option for each used_fs (-t)
     * @return string
     */
  global define string GetMountString(symbol used_fs ,string default )``{
      map fsmap 	= GetFsMap( used_fs);
      string ret        = fsmap[`mount_string ]:"";
      if( ret == "" ) ret = default;
      return ret;
  }

  global define list GetNeededModules( symbol used_fs )``{
      map fsmap 	= GetFsMap( used_fs);
      return fsmap[`needed_modules ]:[]; 
  }

  global define string GetMakeFsType( symbol used_fs , string default )``{
      map fsmap 	= GetFsMap( used_fs);
      string ret        = fsmap[`makefstype ]:"";
      if( ret == "" ) ret = default;
      return ret;
  }

  
  
  /**
     * Load the kernel module which is necessary to mount a partition with used_fs!
     * @param used_fs filesystem
     * @return boolean
     * old load_fs_module
     */
global define boolean LoadModule( symbol used_fs )
    ``{

    list all_needed_modules = GetNeededModules( used_fs );
    y2milestone("all needed modules : %1", all_needed_modules );
    boolean load_success = true;

    map loaded_modules = SCR::Read(.proc.modules);
    y2milestone( "loaded_modules %1", loaded_modules );
    
    foreach(`modulename, all_needed_modules , 
	``{
	if( modulename != "" &&  size (loaded_modules[modulename]:$[])==0 )
	    {
	    if( load_success )
		load_success = SCR::Execute(.target.insmod, modulename , "" );
	
	    y2milestone ("Loaded fs module %1  %2", modulename, load_success?"Ok":"Failed");
	    }
	});
    return load_success;
    };

global define boolean MountUuid( symbol fsys )
    ``{
    map cap = capabilities[`unknown]:$[];
    cap = capabilities[fsys]:cap;
    boolean ret = cap["uuid"]:false;
    y2milestone( "MountUuid fsys:%1 ret:%2", fsys, ret );
    return( ret );
    }

global define boolean MountLabel( symbol fsys )
    ``{
    map cap = capabilities[`unknown]:$[];
    cap = capabilities[fsys]:cap;
    boolean ret = cap["label"]:false;
    y2milestone( "fsys:%1 ret:%2", fsys, ret );
    return( ret );
    }

global define boolean ChangeLabelMounted( symbol fsys )
    ``{
    map cap = capabilities[`unknown]:$[];
    cap = capabilities[fsys]:cap;
    boolean ret = cap["set_label_mount"]:false;
    y2milestone( "fsys:%1 ret:%2", fsys, ret );
    return( ret );
    }

global define integer LabelLength( symbol fsys )
    ``{
    map cap = capabilities[`unknown]:$[];
    cap = capabilities[fsys]:cap;
    integer ret = cap["label_legth"]:16;
    y2milestone( "fsys:%1 ret:%2", fsys, ret );
    return( ret );
    }

global define map IsResizable( symbol fsys )
    ``{
    map cap = capabilities[`unknown]:$[];
    cap = capabilities[fsys]:cap;
    map ret = $[];
    ret["extend"] = cap["extend"]:false;
    ret["shrink"] = cap["shrink"]:false;
    ret["mount_extend"] = cap["mount_extend"]:false;
    ret["mount_shrink"] = cap["mount_shrink"]:false;
    ret["parted"] = cap["parted"]:false;
    y2milestone( "IsResizable fsys:%1 ret:%2", fsys, ret );
    return( ret );
    };

global define map GetFsysInfos( string disk, map part )
    ``{
    y2milestone( "disk:%1 part[nr]:%2", disk, part["nr"]:0 );
    string dev = Storage::GetDeviceName( disk, part["nr"]:0 );
    if( size(part["loop_dev"]:"")>0 )
	{
	dev = part["loop_dev"]:"";
	}
    y2milestone( "dev:%1", dev );
    part["used_fs"] = DetectFs( dev );
    if( part["used_fs"]:`unknown != `unknown )
	{
	map info = GetUuidVolume( dev, part["used_fs"]:`unknown );
	if( size(info["uuid"]:"")>0 )
	    {
	    part["uuid"] = info["uuid"]:"";
	    }
	if( size(info["label"]:"")>0 )
	    {
	    part["label"] = info["label"]:"";
	    }
	}
    y2milestone( "ret part:%1", part );
    return( part );
    }

global define map GetUuidVolume( string dev, symbol fs )
    ``{
    map ret = $[];
    string val = "";
    string cmd = "";
    string search = "";
    map cmd_ret = $[];
    integer pos = 0;
    if( fs == `ext2 || fs == `ext3 )
	{
	cmd = sformat( "/sbin/tune2fs -l %1", dev );
	y2debug( "executing cmd %1", cmd );
	cmd_ret = SCR::Execute(.target.bash_output, cmd);
	val = cmd_ret["stdout"]:"";
	search = "UUID:";
	pos = find( val, search );
	if( pos != -1 )
	    {
	    val = substring( val, pos+size(search) );
	    pos = findfirstof( val, "\n" );
	    if( pos != nil )
		{
		val = substring( val, 0, pos );
		}
	    val = deletechars( val, " \n\t" );
	    if( size(val)>0 )
		{
		ret["uuid"] = val;
		}
	    }
	val = cmd_ret["stdout"]:"";
	search = "volume name:";
	pos = find( val, search );
	if( pos != -1 )
	    {
	    val = substring( val, pos+12 );
	    pos = findfirstof( val, "\n" );
	    if( pos != nil )
		{
		val = substring( val, 0, pos );
		}
	    val = deletechars( val, " \n\t" );
	    if( size(val)>0 && val != "<none>" )
		{
		ret["label"] = val;
		}
	    }
	}
    else if( fs == `reiser )
	{
	cmd = sformat( "/sbin/debugreiserfs %1", dev );
	y2debug( "executing cmd %1", cmd );
	cmd_ret = SCR::Execute(.target.bash_output, cmd);
	val = cmd_ret["stdout"]:"";
	search = "UUID:";
	pos = find( val, search );
	if( pos != -1 )
	    {
	    val = substring( val, pos+size(search) );
	    pos = findfirstof( val, "\n" );
	    if( pos != nil )
		{
		val = substring( val, 0, pos );
		}
	    val = deletechars( val, " \n\t" );
	    if( size(val)>0 )
		{
		ret["uuid"] = val;
		}
	    }
	val = cmd_ret["stdout"]:"";
	search = "LABEL:";
	pos = find( val, search );
	if( pos != -1 )
	    {
	    val = substring( val, pos+size(search) );
	    pos = findfirstof( val, "\n" );
	    if( pos != nil )
		{
		val = substring( val, 0, pos );
		}
	    val = deletechars( val, " \n\t" );
	    if( size(val)>0 )
		{
		ret["label"] = val;
		}
	    }
	}
    else if( fs == `xfs )
	{
	cmd = sformat( "/usr/sbin/xfs_admin -l -u %1", dev );
	y2debug( "executing cmd %1", cmd );
	cmd_ret = SCR::Execute(.target.bash_output, cmd);
	val = cmd_ret["stdout"]:"";
	search = "uuid =";
	pos = find( val, search );
	if( pos != -1 )
	    {
	    val = substring( val, pos+size(search) );
	    pos = findfirstof( val, "\n" );
	    if( pos != nil )
		{
		val = substring( val, 0, pos );
		}
	    val = deletechars( val, " \n\t" );
	    if( size(val)>0 )
		{
		ret["uuid"] = val;
		}
	    }
	val = cmd_ret["stdout"]:"";
	search = "label =";
	pos = find( val, search );
	if( pos != -1 )
	    {
	    val = substring( val, pos+size(search) );
	    pos = findfirstof( val, "\n" );
	    if( pos != nil )
		{
		val = substring( val, 0, pos );
		}
	    val = deletechars( val, " \"\n\t" );
	    if( size(val)>0 )
		{
		ret["label"] = val;
		}
	    }
	}
    y2milestone( "GetUuidVolume dev:%1 fs:%2 ret:%3", dev, fs, ret );
    return( ret );
    }

  /*
   * DetectFs
   *---------------------------------------------------------------------
   * Detect the existing fs on the partition. Right now only ext2 and
   * reiserfs are detected.
   * arguments: <partition> for ex. "/dev/sda1"
   * returns:   Symbol for filesystem or `unknown
   *---------------------------------------------------------------------
   */
global define symbol DetectFs( string current_dev )
    ``{
    symbol  return_value = `unknown;
    string  testcall     = "";
    map bash_call        = $[];

    testcall  = sformat( "/bin/guessfstype %1", current_dev );
    bash_call = SCR::Execute (.target.bash_output, testcall, $[] );

    if (bash_call["exit"]:1 == 0)
	{
	string type = bash_call["stdout"]:"";
	integer pos = findlastof(type, "\n");
	if (pos != nil)
	   {
	   type = substring (type, 0, pos);
	   }
	pos = findlastof(type, " ");
	if (pos != nil)
	   {
	   type = substring (type, pos+1);
	   }
	pos = findfirstof(type, " ,");
	if (pos != nil)
	   {
	   type = substring (type, 0, pos);
	   }
	y2milestone( "type %1", type );
	if( type == "ext2" )
	  {
	  return_value = `ext2;
	  }
	else if( type == "ext3" )
	  {
	  return_value = `ext3;
	  }
	else if( type == "reiserfs" )
	  {
	  return_value = `reiser;
	  }
	else if( type == "jfs" )
	  {
	  return_value = `jfs;
	  }
	else if( type == "xfs" )
	  {
	  return_value = `xfs;
	  }
	else if( type == "vfat" || type == "fat" )
	  {
	  return_value = `fat32;
	  }
	else if( type == "ntfs" )
	  {
	  return_value = `ntfs;
	  }
	else if( type == "hfs" )
	  {
	  return_value = `hfs;
	  }
	}
    y2debug( "detect fs ret %1 bash %2", return_value, bash_call );

    y2milestone( "DetectFs %1: %2", current_dev, return_value );
    return( return_value );
    };


global define boolean SetVolumeLabel( string dev, map part )
    ``{
    boolean ret = false;
    string cmd = "";
    symbol fs = part["used_fs"]:`unknown;
    string label = part["label"]:"";
    y2milestone( "dev:%1 fs:%2 label:%3", dev, fs, label );
    if( size(label)>0 )
	{
	if( fs == `ext2 || fs == `ext3 )
	    {
	    cmd = sformat("/sbin/tune2fs -L %1 %2", label, dev );
	    }
	else if( fs == `xfs )
	    {
	    cmd = sformat("/usr/sbin/xfs_admin -L %1 %2", label, dev );
	    }
	else if( fs == `reiser )
	    {
	    cmd = sformat("/sbin/reiserfstune -l %1 %2", label, dev );
	    }
	if( size(cmd)>0 )
	    {
	    y2milestone( "Excuting cmd:%1", cmd );
	    ret = SCR::Execute(.target.bash, cmd ) == 0;
	    // /sbin/reiserfstune always seems to return 1 even on success
	    if( fs == `reiser )
		ret = true;
	    }
	}
    y2milestone( "ret:%1", ret );
    return( ret );
    };

}
