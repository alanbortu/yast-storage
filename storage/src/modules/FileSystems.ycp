/**
 * Module: 		FileSystems.ycp
 *
 * Authors:		Johannes Buchhold (jbuch@suse.de)
 *
 * Purpose:
 * These module contains the supported filesystems and their settings.
 *
 *
 * $Id$
 */
{
  module "FileSystems";
  textdomain "storage";
  import "Arch";
  import "String";
  import "Partitions";
  import "Popup";
  import "Encoding";

  import "Mode";
  import "Stage";

  import "LibStorage";
  import "LibStorage::StorageInterface";
  import "LibStorage::FsCapabilities";

global map<string,any> conv_fs =
    $[ "def_sym" : `unknown,
       "def_int" : LibStorage::FSUNKNOWN(),
       "m" : $[ LibStorage::REISERFS() : `reiser,
                LibStorage::EXT2() : `ext2,
                LibStorage::EXT3() : `ext3,
                LibStorage::VFAT() : `vfat,
                LibStorage::XFS() : `xfs,
                LibStorage::JFS() : `jfs,
                LibStorage::HFS() : `hfs,
                LibStorage::NTFS() : `ntfs,
                LibStorage::SWAP() : `swap,
                LibStorage::FSNONE() : `none
              ]
     ];

integer fromSymbol( map<string,any> conv, symbol val )
    {
    integer ret = conv["def_int"]:-1;
    foreach( integer i, symbol s, conv["m"]:$[],
        ``{
        if( s==val )
            ret = i;
        });
    return( ret );
    }

  global list<string> system_m_points = [ "/", Partitions::BootMount(), "/usr",
                                          "/var", "/opt" ];
  global list<string> crypt_m_points = [ "/", Partitions::BootMount(), "/usr" ];
  global list<string> suggest_m_points = (list<string>)union( system_m_points,
                                        [ "/home", "/srv", "/tmp", "/local", ""] );
  global list<string> swap_m_points   = [ "swap", ""  ];

  global string nchars = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";

define list FstabOptionStrings = 
    [ "defaults", 
      "auto", "noauto",
      "atime", "noatime",
      "ro", "rw",
      "user", "nouser",
      "acl", "noacl",
      "user_xattr", "no_user_xattr",
      "data=journal", "data=ordered", "data=writeback",
      "dev", "nodev", 
      "exec", "noexec", 
      "suid", "nosuid", 
      "async", "sync", "dirsync",
      "procuid", 
      "barrier=none",
      "fs=floppyfss", "fs=cdfss",
      "users", "gid=users"
      ];

define list FstabOptionRegex = [ "pri=[0-9]\+", "iocharset=.\+", "utf8=\.*",
                                 "nls=.\+", "codepage=.\+", 
				 "gid=[0-9]\+", "umask=[0-7]\+",
				 "loop=.\+", "encryption=.\+",
				 "pri=[0-9]\+" ];

define map FstabDefaultMap =
    $[ "pts":    $[ "spec":"devpts", "mount":"/dev/pts", "vfstype":"devpts",
		    "mntops":"mode=0620,gid=5", "freq":0, "passno":0 ],
       "proc":   $[ "spec":"proc", "mount":"/proc", "vfstype":"proc", 
                    "mntops":"defaults", "freq":0, "passno":0 ],
       "sys":    $[ "spec":"sysfs", "mount":"/sys", "vfstype":"sysfs", 
                    "mntops":"noauto", "freq":0, "passno":0 ],
       "swap":   $[ "spec":"", "mount":"swap", "vfstype":"swap", 
                    "mntops":"default", "freq":0, "passno":0 ],
       "root":   $[ "spec":"", "mount":"", "vfstype":"auto", 
                    "mntops":"defaults", "freq":1, "passno":1 ],
       "dev":    $[ "spec":"", "mount":"", "vfstype":"auto", 
                    "mntops":"noauto,user", "freq":0, "passno":0 ],
       "nfs":    $[ "spec":"", "mount":"", "vfstype":"nfs", 
                    "mntops":"defaults", "freq":0, "passno":0 ],
       "usb":    $[ "spec":"usbfs", "mount":"/proc/bus/usb", "vfstype":"usbfs", 
                    "mntops":"noauto", "freq":0, "passno":0 ],
       "cdrom":  $[ "spec":"", "mount":"", "vfstype":"subfs", 
                    "mntops":"noauto,fs=cdfss,ro,procuid,nosuid,nodev,exec", 
		    "freq":0, "passno":0 ],
       "floppy": $[ "spec":"", "mount":"", "vfstype":"subfs", 
                    "mntops":"noauto,fs=floppyfss,procuid,nodev,nosuid,sync", 
		    "freq":0, "passno":0 ],
       "zip":    $[ "spec":"", "mount":"", "vfstype":"auto", 
                    "mntops":"noauto,user", "freq":0, "passno":0 ],
       "data":   $[ "spec":"", "mount":"", "vfstype":"auto", 
                    "mntops":"noauto,user", "freq":0, "passno":0 ]
     ];

  /* All supported filesystems */
  map<symbol, boolean> support 	= $[
		   `reiser	: true,
		   `xfs		: true,
		   `ext2        : true,
		   `ext3        : true,
		   `jfs    	: false,
		   `vfat  	: true,
		   `xxefi  	: false,
		   `xbootdisk  	: false,
		   `xbootfat  	: false,
		   `xhibernate 	: true,
		   `raid       	: true,
		   `lvm        	: true
  ];

  map<symbol, map<string, any> > capabilities = $[
		   `reiser	: $[
		                     "extend":true,
				     "shrink":true,
		                     "mount_extend":true,
				     "uuid" : true,
				     "label_length" : 16,
				     "label" : true
				   ],
		   `xfs		: $[
		                     "extend":true,
		                     "mount_extend":true,
				     "label_length" : 12,
				     "set_label_mount" : true,
				     "uuid" : true,
				     "label" : true
				   ],
		   `ext2        : $[
		                     "extend":true,
		                     "shrink":true,
				     "uuid" : true,
				     "label_length" : 16,
				     "set_label_mount" : true,
				     "label" : true
				   ],
		   `ext3        : $[ "extend":true,
		                     "shrink":true,
				     "uuid" : true,
				     "label_length" : 16,
				     "set_label_mount" : true,
				     "label" : true
				   ],
		   `jfs    	: $[
				   ],
		   `hfs    	: $[
				   ],
		   `vfat  	: $[ "shrink":true
				   ],
		   `ntfs  	: $[ "extend":true,
		                     "shrink":true
				   ],
		   `swap  	: $[ "extend":true,
		                     "shrink":true,
				   ],
		   `unknown  	: $[
				   ],
  ];



    /**
     * Return a map that contains the mount option for each used_fs (-t)
     * @return map
     */
  /*
    to mount_string
    global define used2typeMap()
    ``{
	return $[
		 `ext2   : "ext2",
		 `ext3   : "ext3",
		 `reiser : "reiserfs",
		 `xfs    : "xfs",
		 `jfs    : "jfs",
		 `vfat   : "vfat" ];
    };
  */

global define list<map<symbol, any> > GetGeneralFstabOptions()
    ``{
    list<map<symbol, any> > options =
	[ $[
	     // button text
	     `widget : `Left(`CheckBox(`id("opt_readonly"), _("Mount &read-only"), false)),
	     `query_key : "opt_readonly",
	     // help text, richtext format
	     `help_text : _("<p><b>Mount Read-Only:</b>
No writable access to the file system is possible. Default is false.</p>
"),
             `type : `boolean,
	     `str_opt : $[ 1 : "ro", "default" : "" ],
	     `str_scan : [[ "ro", 1 ], ["rw", 0 ]],
	   ],
	  $[
	     // button text
	     `widget : `Left(`CheckBox(`id("opt_noatime"), _("No &access time"), false)),
	     `query_key : "opt_noatime",
	     // help text, richtext format
	     `help_text : _("<p><b>No access time:</b>
Access times are not updated when a file is read. Default is false.</p>"),
             `type : `boolean,
	     `str_opt  : $[ 1 : "noatime", "default" : "" ],
	     `str_scan : [[ "noatime", 1 ], ["atime", 0 ]],
	   ],
	  $[
	     // button text
	     `widget : `Left(`CheckBox(`id("opt_user"), _("Mountable by &user"), false)),
	     `query_key : "opt_user",
	     // help text, richtext format
	     `help_text : _("<p><b>Mountable by User:</b>
The file system may be mounted by an ordinary user. Default is false.</p>
"),
             `type : `boolean,
	     `str_opt  : $[ 1 : "user", "default" : "" ],
	     `str_scan : [[ "nouser", 0 ], ["user", 1 ]],
	   ],
	  $[
	     // button text
	     `widget : `Left(`CheckBox(`id("opt_noauto"), `opt(`notify), _("Do Not Mount at System &Start-up"), false)),
	     `query_key : "opt_noauto",
	     // help text, richtext format
	     `help_text : _("<p><b>Not Mounted at System Start-up:</b>
The file system is not automatically mounted when the system starts.
An entry in /etc/fstab is created and the file system is mounted
with the appropriate options when the command <tt>mount &lt;mount point&gt;</tt>
(&lt;mount point&gt; is the directory to which the file system is mounted)
is given. Default is false.</p>
"),
             `type : `boolean,
	     `str_opt  : $[ 1 : "noauto", "default" : "" ],
	     `str_scan : [[ "noauto", 1 ], ["auto", 0 ]],
	   ]
	];
    return( options );
    };

global define list< map<symbol, any> > GetJournalFstabOptions()
    ``{
    list< map<symbol, any> > options =
	[ $[
	     `widget : `VBox( `ComboBox(`id("opt_journal"), `opt(`hstretch),
					// label text
					_("Data &Journaling Mode"),
					["journal", "ordered", "writeback"]),
			      `VSpacing(0.5)),
	     `default   : "ordered",
	     `query_key : "opt_journal",
	     `type : `text,
	     // help text, richtext format
	     `help_text : _("<p><b>Data Journaling Mode:</b>
Specifies the journaling mode for file data.
<tt>journal</tt> -- All data is committed into the journal prior to being
written into the main file system.
<tt>ordered</tt> -- All data is forced directly out to the main file system
prior to its metadata being committed to the journal.
<tt>writeback</tt> -- Data ordering is not preserved.</p>
"),
	     `str_opt : "data=%1",
	     `str_scan : "data=\(.*\)"
	   ]
	];
    return( options );
    };

global define list< map<symbol, any> > GetAclFstabOptions()
    ``{
    list< map<symbol, any> > options =
	[ $[
	     // button text
	     `widget : `Left(`CheckBox(`id("opt_acl"), _("&Access Control Lists (ACL)"), false)),
	     `query_key : "opt_acl",
	     // help text, richtext format
	     `help_text : _("<p><b>Access Control Lists (ACL):</b>
Enable access control lists on the file system.</p>
"),
             `type : `boolean,
	     `default : true,
	     `str_opt : $[ 0 : "noacl", "default" : "acl" ],
	     `str_scan : [[ "acl", 1 ], ["noacl", 0 ]],
	   ],
	  $[
	     // button text
	     `widget : `Left(`CheckBox(`id("opt_eua"), _("&Extended User Attributes"), false)),
	     `query_key : "opt_eua",
	     // help text, richtext format
	     `help_text : _("<p><b>Extended User Attributes:</b>
Allow extended user attributes on the file system.</p>
"),
             `type : `boolean,
	     `str_opt  : $[ 1 : "user_xattr", "default" : "" ],
	     `str_scan : [[ "user_xattr", 1 ], ["no_user_xattr", 0 ]],
	   ],
	];
    return( options );
    };

global define map<symbol, any> GetArbitraryOptionField()
    ``{
    map<symbol,any> opt = $[
	     // label text
	     `widget : `TextEntry(`id("opt_arbitrary"), _("Arbitrary option &value"), ""),
	     `query_key : "opt_arbitrary",
	     // help text, richtext format
	     `help_text : _("<p><b>Arbitrary Option Value:</b>
In this field, type any legal mount option allowed in the fourth field of /etc/fstab.
Mutiple options are separated by commas.</p>
"),
             `type : `text
	   ];
    return( opt );
    };

define map<symbol, map<symbol, any> > GetNormalFilesystems()``{

  list< map<symbol, any> > fat_fst_options =
      [
	$[
	   // label text
	   `widget : `ComboBox(`id("opt_iocharset"), `opt(`editable,`hstretch), _("Char&set for file names"),
	                       ["", "iso8859-1", "iso8859-15", "iso8859-2",
			        "iso8859-5", "iso8859-7", "iso8859-9", "utf8",
			        "koi8-r", "euc-jp", "sjis", "gb2312", "big5", "euc-kr" ]),
	   `query_key : "opt_iocharset",
	   `type : `text,
	     // help text, richtext format
	   `help_text : _("<p><b>Charset for File Names:</b>
Set the charset used for display of file names in Windows partitions.</p>
"),
	   `str_opt : "iocharset=%1",
	   `str_scan : "iocharset=\(.*\)"
	 ],
	$[
	   // label text
	   `widget : `ComboBox(`id("opt_codepage"), `opt(`editable,`hstretch), _("Code&page for short FAT names"),
	                       ["", "437", "852", "932", "936", "949", "950" ]),
	   `query_key : "opt_codepage",
	   `type : `text,
	     // help text, richtext format
	   `help_text : _("<p><b>Codepage for Short FAT Names:</b>
This codepage is used for converting to shortname characters on FAT file systems.</p>
"),
	   `str_opt : "codepage=%1",
	   `str_scan : "codepage=\(.*\)"
	 ]
      ];

  list< map<symbol, any> > vfat_options =
      [
       $[
	 // label text
	 `widget		: `ComboBox(`id("opt_number_of_fats"), `opt(`hstretch), _("Number of &FATs"), ["auto" , "1", "2"  ]),
	 `query_key	: "opt_number_of_fats",
	 `option_str	: "-f",
	     // help text, richtext format
	 `help_text	: _("<p><b>Number of FATs:</b>
Specify the number of file allocation tables in the file system. The default is 2.</p>")
       ],
	 $[
	 // label text
	   `widget	: `ComboBox(`id("opt_fat_size"), `opt(`hstretch), _("FAT &size"), ["auto",
											  `item(`id("12"), "12 bit"),
											  `item(`id("16"), "16 bit"),
											  `item(`id("32"), "32 bit") ]),
	   `query_key 	: "opt_fat_size",
	   `option_str	: "-F",
	     // help text, richtext format
	   `help_text	: _("<p><b>FAT size:</b>
Specifies the type of file allocation tables used (12,  16,  or  32-bit). If auto is specified, YaST2 will automatically select the value most suitable for the file system size.</p>
")
	 ],
	 $[
	 // label text
	   `widget 	: `TextEntry(`id("opt_root_dir_entries"), `opt(`hstretch), _("Root &dir entries"), "auto"),
	   `query_key 	: "opt_root_dir_entries",
	   `option_str	: "-r",
	   `between	: [ 112, -1],
	   `valid_chars : "0123456789",
	   // popup text
	   `error_text 	: _("The minimum size for \"Root dir entries\" is 112. Please try again."),
	     // help text, richtext format
	   `help_text	: _("<p><b>Root dir entries:</b>
Select the number of entries available in the root directory.</p>")
	 ]
  ];


  list< map<symbol, any> > reiserfs_options =   [
			     $[
			       // label text
			       `widget     	: `ComboBox(`id("opt_hash"), `opt(`hstretch), _("Hash &function"), ["auto", "r5", "tea" ,"rupasov" ]),
			       `query_key		: "opt_hash",
			       `option_str	: "--hash",
			       `option_blank    : true,
	     // help text, richtext format
			       `help_text		: _("<p><b>Hash function:</b>
This specifies the name of the hash function to use to sort the file names in directories.</p>")
			     ],
			       $[
			       // label text
				 `widget     	: `ComboBox(`id("opt_format"), `opt(`hstretch), _("FS &revision"), ["auto", "3.5", "3.6" ]),
				 `query_key		: "opt_format",
				 `option_str	: "--format",
			         `option_blank  : true,
	     // help text, richtext format
				 `help_text		: _("<p><b>FS revision:</b>
This option defines the reiserfs format revision to use. '3.5' is for backwards compatibility with kernels of the 2.2.x series. '3.6' is more recent, but can only be used with kernel versions greater than or equal to 2.4.</p>
")
			       ]
  ];


  list< map<symbol, any> > xfs_options	=  [
			      $[
			     // label text
				   `widget     	: `ComboBox(`id("opt_blocksize"), `opt(`hstretch), _("Block &size in bytes"), ["auto","512","1024", "2048","4096" /*,"8192", "16384","32768"*/ ]),
				   `query_key	: "opt_blocksize",
				   `option_str	: "-bsize=",
	     // help text, richtext format
				   `help_text  	: _("<p><b>Block size:</b>
Specify the size of blocks in bytes. Valid block size values are 512, 1024, 2048, and 4096 bytes per block. If auto is selected, the standard block size of 4096 is used.</p>
")
				 ],
			      $[
			       // label text
				`widget   	: `ComboBox(`id("opt_bytes_per_inode"), `opt(`hstretch), _("&Inode Size"),["auto","256", "512", "1024", "2048"]),
				`query_key	: "opt_bytes_per_inode",
				`option_str  	: "-isize=",
	     // help text, richtext format
				`help_text  	: _("<p><b>Inode Size:</b>
This option specifies the inode size of the file system.</p>\n")
			      ],
			      $[
			       // label text
				`widget   	: `ComboBox(`id("opt_max_inode_space"), `opt(`hstretch), _("&Percentage of inode space"),["auto", "5", "10", "15", "20","25","30",
																	 "35", "40", "45", "50", "55", "60", "65",
																	 "70", "75", "80", "85", "90", "95",
																	 `item(`id("0"), "100") ]),
				`query_key	: "opt_max_inode_space",
				`option_str  	: "-imaxpct=",
	     // help text, richtext format
				`help_text  	: _("<p><b>Percentage of inode space:</b>
The option \"Percentage of inode space\" specifies the maximum percentage of space in the file system that can be allocated to inodes.</p>
")
			      ],
			      $[
			       // label text
				`widget   	: `ComboBox(`id("opt_inode_align"), `opt(`hstretch), _("Inode &aligned"),[ "auto", `item(`id("1"), "true"),
															 `item( `id("0"), "false")  ]),
				`query_key	: "opt_inode_align",
				`option_str  	: "-ialign=",
	     // help text, richtext format
				`help_text  	: _("<p><b>Inode Aligned:</b>
The option \"Inode Aligned\" is used to specify whether inode allocation is or
is not aligned. The default is that inodes are aligned. Aligned inode access
is normally more efficient than unaligned access.</p>
")
			      ]
  ];


  list< map<symbol, any> > jfs_options = [
	    $[
	   // label text
	   `widget : `ComboBox(`id("opt_iocharset"), `opt(`editable,`hstretch), _("Char&set for file names"),
	                       ["", "iso8859-1", "iso8859-15", "iso8859-2",
			        "iso8859-5", "iso8859-7", "iso8859-9", "utf8",
			        "koi8-r", "euc-jp", "sjis", "gb2312", "big5", "euc-kr" ]),
	   `query_key : "opt_iocharset",
	   `type : `text,
	     // help text, richtext format
	   `help_text : _("<p><b>Charset for File Names:</b>
Set the charset used to display file names on the partition.</p>\n"),
	   `str_opt : "iocharset=%1",
	   `str_scan : "iocharset=\(.*\)"
	 ],
		      $[
		       // label text
			`widget 		: `TextEntry(`id("opt_log_size"), `opt(`hstretch),_("&Log size in megabytes"), "auto"),
			`query_key	: "opt_log_size",
			`option_str	: "-ls:",
			// no way to find out the max log size ????
			`between		: [ 0 , -1 ], //  -> -1 = infinite
			`valid_chars 	: "0123456789",
		       // popup text
			`error_text 	: _("The \"Log size\" value is incorrect.\nPlease enter a value greater than zero."),
			// xgettext: no-c-format
	     // help text, richtext format
			`help_text  	: _("<p><b>Log size</b>
Set the log size (in megabytes). If auto, the default is 40% of the aggregate size.</p>")
		      ],
		      $[
		       // label text
			`widget		: `CheckBox(`id("opt_blocks_utility"), _("Invoke Bad Blocks List &Utility"), false),
			`query_key	: "opt_blocks_utility",
			`option_str	: "-l"
		      ]
  ];

  list< map<symbol, any> > ext2_options  =  [
			       $[
				 // label text
				 `widget     	: `TextEntry(`id("opt_raid"), `opt(`hstretch), _("Stride &length in blocks"), "none" ),
				 `query_key	: "opt_raid",
				 `option_str	: "-Rstride=",
				 `valid_chars	: "0123456789",
				 `between		: [ 1, -1],
				 // popup text
				 `error_text	: _("The \"Stride length in blocks\" value is not possible.\nPlease select a value greater than 1."),
	     // help text, richtext format
				 `help_text	: _("<p><b>Stride Length in Blocks:</b>
Set RAID-related options for the file system. Currently, the only supported
argument is 'stride', which takes the number of blocks in a
RAID stripe as its argument.</p>
")
			       ],
				 $[
				 // label text
				   `widget     	: `ComboBox(`id("opt_blocksize"), `opt(`hstretch), _("Block &size in bytes"), ["auto","1024", "2048","4096" /*,"8192", "16384","32768"*/ ]),
				   `query_key	: "opt_blocksize",
				   `option_str	: "-b",
	     // help text, richtext format
				   `help_text  	: _("<p><b>Block size:</b>
Specify the size of blocks in bytes. Valid block size values are 1024, 2048, and 4096 bytes per block. If auto is selected, the block size is determined by the file system size and the expected use of the file system.</p>\n")
				 ],
				 $[
				   // label text
				   `widget   	: `ComboBox(`id("opt_inode_density"), `opt(`hstretch), _("Bytes per &inode"),["auto","1024", "2048","4096","8192", "16384","32768" ]),
				   `query_key	: "opt_inode_density",
				   `option_str 	: "-i",
	     // help text, richtext format
				   `help_text  	: _("<p><b>Bytes per inode:</b>
Specify the bytes to inode ratio. YaST2 creates an inode for every &lt;bytes-per-inode&gt; bytes of space on the disk. The larger the bytes-per-inode ratio, the fewer inodes will be created.
Generally, this value should not be smaller than the block size of the file system, since too many inodes will be created in this case.  It is not possible to expand the
number of inodes on a file system after its creation, so be sure to enter a reasonable value for this parameter.</p>
")
				 ],
				 $[
				   // label text
				   `widget   	: `TextEntry(`id("opt_reserved_blocks"), `opt(`hstretch), _("Percentage of blocks &reserved for root"), "auto" ),
				   `query_key	: "opt_reserved_blocks",
				   `option_str  : "-m",
				   //`default 	: 5,
				   `between	: [ 0 , 99 ], //  -> -1 = infinite
				   `str_length	: 2,
				   `valid_chars : "0123456789",
				   // popup text
				   `error_text  : _("The \"Percentage of blocks reserved for root\" value is incorrect.\nPlease use a value between 0 and 99."),
				   // xgettext: no-c-format
	     // help text, richtext format
				   `help_text  	: _("<p><b>Percentage of blocks reserved for root:</b> Specify the percentage of blocks reserved for the super user. This value defaults to 5%.</p>")
				 ]
      ];

  list< map<symbol, any> > ext3_only_options = [
      $[
      // label text
      `widget   	: `ComboBox(`id("opt_bytes_per_inode"), `opt(`hstretch), _("&Inode Size"),["default", "128", "256", "512", "1024"]),
      `query_key	: "opt_bytes_per_inode",
      `option_str  	: "-I",
       // help text, richtext format
      `help_text  	: _("<p><b>Inode Size:</b>
This option specifies the inode size of the file system.</p>\n")
      ]
  ];

  list< map<symbol, any> > ext3_options = (list< map<symbol, any> >)merge( ext2_options, ext3_only_options );

  list< map<symbol, any> > ext3_fst_options = [ ];
  list< map<symbol, any> > ext2_fst_options = [ ];
  list< map<symbol, any> > reiser_fst_options = [ ];


  map <symbol, map<symbol, any> > RealFileSystems  = $[
		      `ext2	: $[
				    `name 		: "Ext2",
				    `fsid 		: Partitions::fsid_native,
				    `supports_format 	: true,
				    `fsid_item 		: "0x83 Linux ",
				    `fstype 		: "Linux native" ,
				    `crypt 		: true ,
				    `mountpoints 	: suggest_m_points,
				    `mount_option	: "-t ext2",
				    `mount_string	: "ext2",
				    `makefstype		: "ext2",
				    `fst_options  	: ext2_fst_options,
				    `options  		: ext2_options,
		      ],
		      `vfat	: $[
				    `name 		: "FAT",
				    `fsid 		: 12,
				    `alt_fsid           : [ 12, 0x103 ],
				    `supports_format 	: true ,
				    `fsid_item 		: "0x0C Win95 FAT32 ",
				    `fstype 		: "Fat32",
				    `crypt 		: true ,
				    `mountpoints 	: suggest_m_points ,
				    `mount_option	: "-t vfat",
				    `mount_string	: "vfat",
				    `makefstype		: "fat32",
				    `needed_modules	: [ "fat", "vfat" ],
				    `fst_options  	: fat_fst_options,
				    `options 		: vfat_options

		      ],
		      `reiser 	: $[
				    `name 		: "Reiser",
				    `fsid 		: Partitions::fsid_native,
				    `supports_format 	: true ,
				    `fsid_item 		: "0x83 Linux " ,
				    `fstype 		: "Linux native",
				    `crypt 		: true,
				    `mountpoints 	: suggest_m_points,
				    `mount_option 	: "-t reiserfs",
				    `mount_string	: "reiserfs",
				    `needed_modules	: [ "reiserfs" ],
				    `makefstype		: "reiserfs",
				    `fst_options  	: reiser_fst_options,
				    `options 		: reiserfs_options
		      ],
		      `xfs 	: $[
				    `name 		: "XFS",
				    `fsid 		: Partitions::fsid_native,
				    `supports_format 	: true ,
				    `fsid_item 		: "0x83 Linux " ,
				    `fstype 		: "Linux native" ,
				    `crypt 		: true,
				    `mountpoints 	: suggest_m_points,
				    `mount_option 	: "-t xfs",
				    `mount_string	: "xfs",
				    `needed_modules	: [ "xfs" ],
				    `makefstype		: "xfs",
				    `options 		: xfs_options
		      ],
		      `jfs 	: $[
				    `name 		: "JFS",
				    `fsid 		: Partitions::fsid_native,
				    `supports_format 	: true ,
				    `fsid_item 		: "0x83 Linux " ,
				    `fstype 		: "Linux native" ,
				    `crypt		: true,
				    `mountpoints 	: suggest_m_points,
				    `mount_string	: "jfs",
				    `mount_option	: "-t jfs",
				    `needed_modules	: [ "jfs" ],
				    `makefstype		: "jfs",
				    `options      	: jfs_options
		      ],
		      `ext3 	: $[
				    `name 		: "Ext3",
				    `fsid 		: Partitions::fsid_native,
				    `supports_format 	: true ,
				    `fsid_item 		: "0x83 Linux " ,
				    `fstype 		: "Linux native" ,
				    `crypt		: true,
				    `mountpoints 	: suggest_m_points,
				    `mount_string	: "ext3",
				    `mount_option	: "-t ext3",
				    `needed_modules	: [ "jbd",  "ext3" ],
				    `makefstype		: "ext2", // format ext3 as ext2 !!!!!!!!!!!!!!!
				    `fst_options  	: ext3_fst_options,
				    `options      	: ext3_options
		      ],
		      `hfs 	: $[
				    `name 		: "MacHFS",
				    `fsid 		: Partitions::fsid_mac_hfs,
				    `supports_format 	: true,
				    `fsid_item 		: "0x102 Apple_HFS " ,
				    `fstype 		: "Apple_HFS " ,
				    `crypt		: false,
				    `mountpoints 	: [],
				    `mount_string	: "hfs",
				    `mount_option	: "-t hfs",
				    `needed_modules	: [ "hfs" ],
				    `makefstype		: "hfs",
				    `fst_options  	: [],
				    `options      	: []
		      ]
  ];

  return( RealFileSystems );
  };

  list< map<symbol, any> > swap_fst_options = [
    $[ `widget 	    : `TextEntry( `id("priority"), `opt(`hstretch),
				  // label text
                                  _("Swap &Priority"), "42" ),
       `query_key   : "priority",
       `between	    : [ 0, 32767],
       `valid_chars : "0123456789",
       // popup text
       `error_text  : _("Value must be between 0 and 32767. Try again."),
       `type : `text,
       `str_opt : "pri=%1",
       `str_scan : "pri=\(.*\)",
	 // help text, richtext format
       `help_text   : _("<p><b>Swap Priority:</b>
Enter the swap priority. Higher numbers mean higher priority.</p>
")
     ]];

  map<symbol, any> SwapFileSystems =
    $[ `swap :
	$[ `name 	    : "Swap" ,
	   `fsid 	    : Partitions::fsid_swap,
	   `supports_format : true ,
	   `fsid_item 	    : "0x82 Linux swap ",
	   `fstype 	    : "Linux swap",
	   `crypt 	    : false,
	   `fst_options     : swap_fst_options,
	   `mountpoints     : swap_m_points
	 ]
     ];


  map<symbol, map<symbol, any> > PseudoFileSystems = $[
			    `lvm	: $[
					    `name 		: "LVM",
					    `fsid 		: Partitions::fsid_lvm,
					    `supports_format 	: false,
					    `fsid_item 		: "0x8E Linux LVM "
			    ],
			    `raid	: $[
					    `name 		: "RAID",
					    `fsid 		: Partitions::fsid_raid,
					    `supports_format 	: false,
					    `fsid_item 		: "0xFD Linux RAID "
			    ],
			    `xbootdisk : $[
					   `name 		: "PPCBOOT",
					   `fsid 		: Partitions::fsid_prep_chrp_boot,
					   `supports_format 	: false,
					   `fsid_item 		: "0x41 PPC PReP Boot"
			    ],
			    `xbootfat  : $[
					   `name 		: "FATBOOT",
					   `fsid 		: Partitions::fsid_fat16,
					   `supports_format 	: false,
					   `fsid_item 		: "0x06 FAT16 Boot"
			    ],
			    `xhibernate : $[
					   `name 		: "Hibernate",
					   `fsid 		: Partitions::fsid_hibernation,
					   `supports_format 	: false,
					   `fsid_item 		: "0xA0 Hibernation"
					   ],
			    `xxefi      : $[
			                   `name                : "Efi Boot",
					   `fsid                : Partitions::fsid_gpt_boot,
					   `supports_format     : false,
					   `fsid_item           : "0x103 EFI Boot"
					   ]
  ];


  /**
   * Filesystem Definitions
   * @return map map with all supported filesystems
   */
global define map<symbol, map<symbol, any> > GetAllFileSystems(boolean add_swap, boolean add_pseudo )
    ``{ 
    map<symbol, map<symbol, any> > ret = filter( symbol fs_key, map<symbol,any> fs_map, GetNormalFilesystems(),
                      ``( support[fs_key]:false ));

    if( add_swap )
	{
	ret = (map<symbol, map<symbol, any> >)union( ret, SwapFileSystems );
	}
    if( add_pseudo )
	{
	ret = (map<symbol, map<symbol, any> >)union( ret, filter( symbol fs_key, any fs_map, PseudoFileSystems,
				  ``( support[fs_key]:false )));
	}
    return ret;
    }


global define list< map<symbol, any> > GetFstabOptWidgets( symbol fsys )
    ``{
    list< map<symbol, any> > ret = [];
    if( fsys != `swap )
	{
	map<symbol, map<symbol, any> > fs = GetAllFileSystems( true, false );
	ret = fs[fsys,`fst_options]:[];
	if( contains( [`ext3, `reiser], fsys ) )
	    {
	    ret = (list< map<symbol, any> >)union( ret, GetJournalFstabOptions() );
	    }
	if( contains( [`ext2, `ext3, `reiser], fsys ) )
	    {
	    ret = (list< map<symbol, any> >)union( ret, GetAclFstabOptions() );
	    }
	}
    else
	{
	ret = swap_fst_options;
	}
    y2milestone( "fsys %1", fsys );
    y2milestone( "ret %1", ret );
    return( ret );
    };




  /* FileS build fss map with all supported filesystems ( list support ) */
global define void FileSystems()
    ``{
    if( Arch::sparc64 () || Arch::sparc32 () )
	{
        support[`vfat] = false;
	}
    if( Arch::ppc () )
	{
	support[`vfat] = Arch::board_chrp ();
	support[`xbootdisk] = true;
	support[`xbootfat] = Arch::board_chrp ();
	}
    if( Arch::s390 () )
	{
	support[`xfs] = false;
	support[`vfat] = false;
	}
    if( Arch::ia64 () )
	{
	support[`jfs] = false;
	support[`xxefi] = true;
	}
    if( Arch::alpha () )
	{
	support[`reiser] = false;
	}
    if( Arch::board_mac () )
	{
	support[`hfs] = true;
	}
    y2milestone( "support %1", support );
    suggest_m_points = [ "/home", "/srv", "/tmp", "/local", ""];
    if( Stage::initial() )
	suggest_m_points = (list<string>)union( system_m_points, 
	                                        suggest_m_points );
    y2milestone( "suggest_m_points:%1", suggest_m_points );
    }

global define void InitSlib( any sint )
    {
    boolean bval = false;
    integer val = 0;
    foreach( symbol fs, map<string,any> cap, capabilities,
	``{
	if( fs != `unknown )
	    {
	    integer id = fromSymbol( conv_fs, fs );
	    any fsinfo = LibStorage::FsCapabilities::new("LibStorage::FsCapabilities");
	    boolean ret = LibStorage::StorageInterface::getFsCapabilities( sint, id, fsinfo );
	    if( !ret )
		y2error( "InitSlib fs:%1 id:%2 ret:%3", fs, id, ret );
	    else
		{
		cap = $[];
		bval = LibStorage::FsCapabilities::swig_isExtendable_get(fsinfo);
		if( bval )
		    cap["extend"] = true;
		bval = LibStorage::FsCapabilities::swig_isReduceable_get(fsinfo);
		if( bval )
		    cap["shrink"] = true;
		bval = LibStorage::FsCapabilities::swig_isExtendableWhileMounted_get(fsinfo);
		if( bval )
		    cap["mount_extend"] = true;
		bval = LibStorage::FsCapabilities::swig_isReduceableWhileMounted_get(fsinfo);
		if( bval )
		    cap["mount_shrink"] = true;
		bval = LibStorage::FsCapabilities::swig_supportsUuid_get(fsinfo);
		if( bval )
		    cap["uuid"] = true;
		bval = LibStorage::FsCapabilities::swig_supportsLabel_get(fsinfo);
		if( bval )
		    cap["label"] = true;
		bval = LibStorage::FsCapabilities::swig_labelWhileMounted_get(fsinfo);
		if( bval )
		    cap["set_label_mount"] = true;
		if( cap["label"]:false )
		    cap["label_length"] = LibStorage::FsCapabilities::swig_labelLength_get(fsinfo);
		cap["min_fs_k"] = LibStorage::FsCapabilities::swig_minimalFsSizeK_get(fsinfo);
		capabilities[fs] = cap;
		}
	    }
	});
    }


  global define boolean IsSupported( symbol used_fs)``{
      return support[ used_fs ]:false;
  }

global define map<symbol, any> GetFsMap( symbol used_fs )
    ``{
    map<symbol, map<symbol, any> > allfs =  GetAllFileSystems( true, true  );
    if( haskey( allfs, used_fs ))
	return allfs[ used_fs]:$[];
    else
	{
	map<symbol, map<symbol, any> > fs = GetNormalFilesystems();
	return( fs[used_fs]:$[] );
	}
    }

  global define string GetName( symbol used_fs, string defaultv )``{
      map<symbol,any> fsmap 	= GetFsMap( used_fs);
      string ret        = fsmap[`name]:"";
      if ( ret == "" && used_fs == `ntfs ) ret = "NTFS";
      if ( ret == "" ) ret = defaultv;
      return ret;
  }

  global define integer GetFsid( symbol used_fs )``{
      map<symbol,any> fsmap 	= GetFsMap( used_fs);
      return fsmap[`fsid]:Partitions::fsid_native;
  }

  global define boolean GetSupportFormat( symbol used_fs )``{
      map<symbol,any> fsmap 	= GetFsMap( used_fs);
      return (boolean)(fsmap[`supports_format]:nil);
  }

  global define string GetFsidItem( symbol used_fs )``{
      map<symbol,any> fsmap 	= GetFsMap( used_fs);
      return fsmap[`fsid_item ]:"";
  }

  global define string GetFstype( symbol used_fs )``{
      map<symbol,any> fsmap 	= GetFsMap( used_fs);
      return fsmap[`fstype ]:"";
  }

  global define boolean GetCrypt( symbol used_fs )``{
      map<symbol,any> fsmap 	= GetFsMap( used_fs);
      return (boolean)(fsmap[`crypt ]:nil);
  }

  global define list GetPossibleMountPoints( symbol used_fs )``{
      map<symbol,any> fsmap 	= GetFsMap( used_fs);
      return fsmap[`mountpoints ]:[];
  }

  global define string GetMountOption( symbol used_fs )``{
      map<symbol,any> fsmap 	= GetFsMap( used_fs);
      return fsmap[`mount_option ]:"";
  }

  global define list GetOptions( symbol used_fs )``{
      map<symbol,any> fsmap 	= GetFsMap( used_fs);
      return fsmap[`options ]:[];
  }


    /**
     * Return the mount option for each used_fs (-t)
     * @return string
     */
  global define string GetMountString(symbol used_fs, string defaultv )``{
      map<symbol,any> fsmap 	= GetFsMap( used_fs);
      string ret        = fsmap[`mount_string ]:"";
      if( size(ret)==0 )
	  {
	  if( used_fs == `vfat )
	      {
	      ret = "vfat";
	      }
	  else if( used_fs == `ntfs )
	      {
	      ret = "ntfs";
	      }
	  }
      if( ret == "" ) ret = defaultv;
      y2milestone( "used_fs:%1 ret:%2", used_fs, ret );
      return ret;
  }

  global define list<string> GetNeededModules( symbol used_fs )``{
      list<string> ret = [];
      map<symbol,any> fsmap 	= GetFsMap( used_fs);
      if( used_fs==`ntfs && size(fsmap)==0 )
	{
	ret = ["ntfs"];
	}
      else
	{
	ret = fsmap[`needed_modules ]:[];
	}
      return ret;
  }

  global define string GetMakeFsType( symbol used_fs , string defaultv )``{
      map<symbol,any> fsmap 	= GetFsMap( used_fs);
      string ret        = fsmap[`makefstype ]:"";
      if( ret == "" ) ret = defaultv;
      return ret;
  }



  /**
     * Load the kernel module which is necessary to mount a partition with used_fs!
     * @param used_fs filesystem
     * @return boolean
     * old load_fs_module
     */
global define boolean LoadModule( symbol used_fs )
    ``{

    list<string> all_needed_modules = GetNeededModules( used_fs );
    y2milestone("all needed modules for %1: %2", used_fs, all_needed_modules );
    boolean load_success = true;

    SCR::UnmountAgent (.proc.modules);
    map loaded_modules = (map) SCR::Read(.proc.modules);
    y2milestone( "loaded_modules %1", loaded_modules );

    foreach( string modulename, all_needed_modules,
	``{
	if( modulename != "" &&  size (loaded_modules[modulename]:$[])==0 )
	    {
	    if( load_success )
		load_success = (boolean) SCR::Execute(.target.modprobe, modulename , "" );

	    y2milestone ("Loaded fs module %1 %2", modulename, load_success?"Ok":"Failed");
	    }
	});
    return load_success;
    };

global define integer MinFsSizeK( symbol fsys )
    ``{
    map<string,any> cap = capabilities[`unknown]:$[];
    cap = capabilities[fsys]:cap;
    integer ret = cap["min_fs_k"]:0;
    y2milestone( "MinFsSizeK fsys:%1 ret:%2", fsys, ret );
    return( ret );
    }

global define boolean MountUuid( symbol fsys )
    ``{
    map<string,any> cap = capabilities[`unknown]:$[];
    cap = capabilities[fsys]:cap;
    boolean ret = cap["uuid"]:false;
    y2milestone( "MountUuid fsys:%1 ret:%2", fsys, ret );
    return( ret );
    }

global define boolean MountLabel( symbol fsys )
    ``{
    map<string,any> cap = capabilities[`unknown]:$[];
    cap = capabilities[fsys]:cap;
    boolean ret = cap["label"]:false;
    y2milestone( "MountLabel fsys:%1 ret:%2", fsys, ret );
    return( ret );
    }

global define boolean ChangeLabelMounted( symbol fsys )
    ``{
    map<string,any> cap = capabilities[`unknown]:$[];
    cap = capabilities[fsys]:cap;
    boolean ret = cap["set_label_mount"]:false;
    y2milestone( "ChangeLabelMounted fsys:%1 ret:%2", fsys, ret );
    return( ret );
    }

global define integer LabelLength( symbol fsys )
    ``{
    map<string,any> cap = capabilities[`unknown]:$[];
    cap = capabilities[fsys]:cap;
    integer ret = cap["label_length"]:16;
    y2milestone( "LabelLength fsys:%1 ret:%2", fsys, ret );
    return( ret );
    }

global define map IsResizable( symbol fsys )
    ``{
    map<string,any> cap = capabilities[`unknown]:$[];
    cap = capabilities[fsys]:cap;
    map ret = $[];
    ret["extend"] = cap["extend"]:false;
    ret["shrink"] = cap["shrink"]:false;
    ret["mount_extend"] = cap["mount_extend"]:false;
    ret["mount_shrink"] = cap["mount_shrink"]:false;
    y2milestone( "IsResizable fsys:%1 ret:%2", fsys, ret );
    return( ret );
    };

global define symbol FsToSymbol( string type )
    ``{
    symbol return_value = `none;
	if( type == "ext2" )
	  {
	  return_value = `ext2;
	  }
	else if( type == "ext3" )
	  {
	  return_value = `ext3;
	  }
    else if( regexpmatch( type, "reiser.*" ) )
	  {
	  return_value = `reiser;
	  }
	else if( type == "jfs" )
	  {
	  return_value = `jfs;
	  }
	else if( type == "xfs" )
	  {
	  return_value = `xfs;
	  }
    else if( type == "vfat" || regexpmatch( type, "fat.*" ))
	  {
	  return_value = `vfat;
	  }
	else if( type == "ntfs" )
	  {
	  return_value = `ntfs;
	  }
	else if( type == "hfs" )
	  {
	  return_value = `hfs;
	  }
	else if( type == "swap" )
	  {
	  return_value = `swap;
	  }
    return( return_value );
    }

global define boolean SetVolumeLabel( string dev, map part )
    ``{
    boolean ret = false;
    string cmd = "";
    symbol fs = part["used_fs"]:`unknown;
    string label = part["label"]:"";
    y2milestone( "SetVolumeLabel dev:%1 fs:%2 label:%3", dev, fs, label );
    if( fs == `ext2 || fs == `ext3 )
	{
	cmd = sformat("/sbin/tune2fs -L \"%1\" %2", label, dev );
	}
    else if( fs == `xfs )
	{
	if( size(label)==0 )
	    label = "--";
	cmd = sformat("/usr/sbin/xfs_admin -L %1 %2", label, dev );
	}
    else if( fs == `reiser )
	{
	cmd = sformat("/sbin/reiserfstune -l \"%1\" %2", label, dev );
	}
    if( size(cmd)>0 )
	{
	y2milestone( "Excuting cmd:%1", cmd );
	ret = SCR::Execute(.target.bash, cmd ) == 0;
	// /sbin/reiserfstune always seems to return 1 even on success
	if( fs == `reiser )
	    ret = true;
	}
    y2milestone( "SetVolumeLabel ret:%1", ret );
    return( ret );
    };

global define void DoChangedFsDefaults( map part )
    ``{
    string cmd = "";
    symbol fs = part["used_fs"]:`unknown;
    string dev = part["device"]:"";
    if( haskey( part, "loop_dev" ))
	{
	dev = part["loop_dev"]:"";
	}
    if( fs == `ext3 )
	{
	y2milestone( "dev:%1 fs:%2", dev, fs );
	cmd = sformat("/sbin/tune2fs -c %1 -i %2 %3", 500, "2m", dev );
	y2milestone( "Excuting cmd:%1", cmd );
	SCR::Execute(.target.bash, cmd );
	}
    };

global define boolean IsCryptMp( string mount, boolean prefix )
    ``{
    boolean ret = contains( crypt_m_points, mount );
    if( !ret && prefix )
	{
	list<string> mp = filter(string s, system_m_points, ``(s!="/") );
	foreach(string s, mp,
	    ``{
	    ret = ret || find( mount, s + "/" )==0;
	    });
	}
    y2milestone( "IsCryptMp mount:%1 prefix:%2 ret:%3", mount, prefix, ret );
    return( ret );
    };

global define boolean IsSystemMp( string mount, boolean prefix )
    ``{
    boolean ret = contains( system_m_points, mount );
    if( !ret && prefix )
	{
	list<string> mp = filter(string s, system_m_points, ``(s!="/") );
	foreach(string s, mp,
	    ``{
	    ret = ret || find( mount, s + "/" )==0;
	    });
	}
    if( size(mount)>0 )
	y2milestone( "IsSystemMp mount:%1 prefix:%2 ret:%3", mount, prefix, ret );
    return( ret );
    };

global define string RemoveCryptOpts( string opt )
    ``{
    string ret = opt;
    ret = String::CutRegexMatch( ret, ",*loop[^,]*", true );
    ret = String::CutRegexMatch( ret, ",*encryption=[^,]*", true );
    ret = String::CutRegexMatch( ret, ",*phash=[^,]*", true );
    ret = String::CutRegexMatch( ret, ",*itercountk=[^,]*", true );
    if( size(ret)!=size(opt) )
	{
	ret = String::CutRegexMatch( ret, "^,", false );
	y2milestone( "in %1 ret %2", opt, ret );
	}
    return( ret );
    };

global define string DefaultFstabOptions( map part )
    ``{
    symbol fsys = part["used_fs"]:`none;
    string fst_default = "";
    if( part["format"]:false && contains( [`ext2, `ext3, `reiser], fsys ) )
	{
	fst_default = "acl,user_xattr";
	}
    y2milestone( "DefaultFstabOptions fsys %1 is %2", fsys, fst_default );
    return( fst_default );
    }

global define boolean HasFstabOption( map part, string opt, boolean prefix )
    {
    list<string> l = splitstring( part["fstopt"]:"", "," );
    if( prefix )
	l = filter( string s, l, ``(find(s,opt)==0));
    else
	l = filter( string s, l, ``(s==opt));
    y2milestone( "HasFstabOption fst:%1 opt:%2 prefix:%3 l:%4 ret:%5", 
                 part["fstopt"]:"", opt, prefix, l, size(l)>0 );
    return( size(l)>0 );
    }

global define map CheckFstabOptions( string option_list )
    ``{
    boolean found = false;
    integer index = 0;
    y2milestone( "CheckFstabOptions option_list=%1", option_list );
    list<string> olist = splitstring( option_list, "," );
    list<string> known = [];
    list<string> unknown = [];
    foreach( string o, olist,
	``{
	if( contains( FstabOptionStrings, o ) )
	    {
	    known = add( known, o );
	    }
	else 
	    {
	    found = false;
	    index = 0;
	    while( !found && index<size(FstabOptionRegex) )
		{
		found = regexpmatch( o, FstabOptionRegex[index]:"" );
		index = index + 1;
		}
	    if( found )
		{
		known = add( known, o );
		}
	    else
		{
		unknown = add( unknown, o );
		}
	    }
	});
    map ret = $[  "all_known" : size(unknown)==0, 
                  "known_options" : mergestring( known, "," ),
                  "unknown_options" : mergestring( unknown, "," ) ];
    y2milestone( "CheckFstabOptions ret=%1", ret );
    return( ret );
    }

global define map GetFstabDefaultMap( string key )
    ``{
    return( FstabDefaultMap[key]:$[] );
    }

global define string GetFstabDefaultMntops( string key )
    ``{
    map m = GetFstabDefaultMap( key );
    return( m["mntops"]:"" );
    }

global define list GetFstabDefaultList( string key )
    ``{
    map m = GetFstabDefaultMap( key );
    return( [ m["spec"]:"", m["mount"]:"", m["vfstype"]:"", m["mntops"]:"",
              tostring(m["freq"]:0), tostring(m["passno"]:0) ] );
    }


}
