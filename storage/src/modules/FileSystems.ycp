/**
 * Module: 		FileSystems.ycp
 *
 * Authors:		Johannes Buchhold (jbuch@suse.de)
 *		Arvin Schnell <aschnell@suse.de>
 *
 * Purpose:
 * These module contains the supported filesystems and their settings.
 *
 *
 * $Id$
 */
{
  module "FileSystems";

  textdomain "storage";

  import "Arch";
  import "String";
  import "Partitions";
  import "Encoding";
  import "Stage";

  import "LibStorage";
  import "LibStorage::StorageInterface";
  import "LibStorage::FsCapabilities";
  import "LibStorage::DiskInfo";
  import "LibStorage::ContVolInfo";

global map<string,any> conv_fs =
    $[ "def_sym" : `unknown,
       "def_int" : LibStorage::FSUNKNOWN(),
       "m" : $[ LibStorage::REISERFS() : `reiser,
                LibStorage::EXT2() : `ext2,
                LibStorage::EXT3() : `ext3,   
		LibStorage::EXT4() : `ext4,
		LibStorage::BTRFS() : `btrfs,
                LibStorage::VFAT() : `vfat,
                LibStorage::XFS() : `xfs,
                LibStorage::JFS() : `jfs,
                LibStorage::HFS() : `hfs,
                LibStorage::NTFS() : `ntfs,
                LibStorage::SWAP() : `swap,
                LibStorage::NFS() : `nfs,
		LibStorage::NFS4() : `nfs4,
		LibStorage::TMPFS() : `tmpfs,
                LibStorage::FSNONE() : `none
              ]
     ];

integer fromSymbol( map<string,any> conv, symbol val )
    {
    integer ret = conv["def_int"]:-1;
    foreach( integer i, symbol s, conv["m"]:$[],
        ``{
        if( s==val )
            ret = i;
        });
    return( ret );
    }


    // filesystems possible for root volume. used during scan for root volumes.
    global const list<symbol> possible_root_fs = [ `ext2, `ext3, `btrfs, `reiser, `xfs, `jfs ];


    global list<string> system_m_points() { return [ "/", "/usr", "/var", "/opt", Partitions::BootMount() ]; }
    global list<string> crypt_m_points() { return [ "/", Partitions::BootMount(), "/usr" ]; }
    global const list<string> swap_m_points = [ "swap" ];
    global const list<string> tmp_m_points = [ "/tmp", "/var/tmp" ];
    global string default_subvol = "A";

    list<string> suggest_m_points = [];
    list<string> suggest_tmp_points = [];


  global string nchars = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";

global list<string> SuggestMPoints()
    {
    if( size(suggest_m_points)==0 )
	{
	suggest_m_points = [ "/home", "/srv", "/tmp", "/local" ];
	if( Stage::initial() )
	    suggest_m_points = (list<string>)union( system_m_points(),
						    suggest_m_points );
	y2milestone( "SuggestMPoints init:%1", suggest_m_points );
	}
    return( suggest_m_points );
    }

global list<string> SuggesTmpfsMPoints()
    {
    if( size(suggest_tmp_points)==0 )
	{
	suggest_tmp_points = [ "/run", "/var/run", "/tmp", "/var/lock" ];
	y2milestone( "SuggesTmpfsMPoints init:%1", suggest_tmp_points );
	}
    return( suggest_tmp_points );
    }

    any sint = nil;


    const list<string> FstabOptionStrings = [
	"defaults",
      "auto", "noauto",
      "atime", "noatime",
      "ro", "rw",
      "user", "nouser",
      "acl", "noacl",
      "user_xattr", "no_user_xattr",
      "data=journal", "data=ordered", "data=writeback",
      "dev", "nodev", 
      "exec", "noexec", 
      "suid", "nosuid", 
      "async", "sync", "dirsync",
      "procuid", 
      "barrier=none",
      "fs=floppyfss", "fs=cdfss",
      "users", "gid=users",
      "usrquota", "grpquota"
      ];

    const list<string> FstabOptionRegex = [
	"pri=[0-9]\+", "iocharset=.\+", "utf8=\.*",
                                 "nls=.\+", "codepage=.\+", 
				 "gid=[0-9]\+", "umask=[0-7]\+",
				 "loop=.\+", "encryption=.\+",
				 "pri=[0-9]\+",
				 "locale=\.\+", "fmask=[0-7]\+", "dmask=[0-7]\+",
	"usrjquota=.\+", "grpjquota=.\+", "jqfmt=.\+"
    ];


    const map<string, map> FstabDefaultMap = $[
	"pts":    $[ "spec":"devpts", "mount":"/dev/pts", "vfstype":"devpts",
		    "mntops":"mode=0620,gid=5", "freq":0, "passno":0 ],
       "proc":   $[ "spec":"proc", "mount":"/proc", "vfstype":"proc", 
                    "mntops":"defaults", "freq":0, "passno":0 ],
       "sys":    $[ "spec":"sysfs", "mount":"/sys", "vfstype":"sysfs", 
                    "mntops":"noauto", "freq":0, "passno":0 ],
       "debug":  $[ "spec":"debugfs", "mount":"/sys/kernel/debug", 
                    "vfstype":"debugfs", "mntops":"noauto", 
		    "freq":0, "passno":0 ],
       "swap":   $[ "spec":"", "mount":"swap", "vfstype":"swap", 
                    "mntops":"default", "freq":0, "passno":0 ],
       "root":   $[ "spec":"", "mount":"", "vfstype":"auto", 
                    "mntops":"defaults", "freq":1, "passno":1 ],
       "dev":    $[ "spec":"", "mount":"", "vfstype":"auto", 
                    "mntops":"noauto,user", "freq":0, "passno":0 ],
       "nfs":    $[ "spec":"", "mount":"", "vfstype":"nfs", 
                    "mntops":"defaults", "freq":0, "passno":0 ],
       "usb":    $[ "spec":"usbfs", "mount":"/proc/bus/usb", "vfstype":"usbfs", 
                    "mntops":"noauto", "freq":0, "passno":0 ],
       "cdrom":  $[ "spec":"", "mount":"", "vfstype":"subfs", 
                    "mntops":"noauto,fs=cdfss,ro,procuid,nosuid,nodev,exec", 
		    "freq":0, "passno":0 ],
       "floppy":    $[ "spec":"", "mount":"", "vfstype":"auto", 
                    "mntops":"noauto,user,sync", "freq":0, "passno":0 ],
       "zip":    $[ "spec":"", "mount":"", "vfstype":"auto", 
                    "mntops":"noauto,user", "freq":0, "passno":0 ],
       "data":   $[ "spec":"", "mount":"", "vfstype":"auto", 
                    "mntops":"noauto,user", "freq":0, "passno":0 ]
     ];

  /* All supported filesystems */
  map<symbol, boolean> support 	= $[
		   `reiser	: true,
		   `xfs		: true,
		   `ext2        : true,
		   `ext3        : true,
		   `ext4        : false,
		   `btrfs	: true,
		   `jfs    	: true,
		   `vfat  	: true,
		   `ntfs  	: true,
		   `xxefi  	: false,
		   `xbootdisk  	: false,
		   `xbootfat  	: false,
		   `xhibernate 	: true,
		   `raid       	: true,
		   `lvm        	: true
  ];

  list<symbol> unsupportFs = [ `jfs ];


global define list<map<symbol, any> > GetGeneralFstabOptions()
    ``{
    list<map<symbol, any> > options =
	[ $[
	     // button text
	     `widget : `Left(`CheckBox(`id("opt_readonly"), _("Mount &read-only"), false)),
	     `query_key : "opt_readonly",
	     // help text, richtext format
	     `help_text : _("<p><b>Mount Read-Only:</b>
No writing to the file system is possible. Default is false.</p>
"),
             `type : `boolean,
	     `str_opt : $[ 1 : "ro", "default" : "" ],
	     `str_scan : [[ "ro", 1 ], ["rw", 0 ]],
	   ],
	  $[
	     // button text
	     `widget : `Left(`CheckBox(`id("opt_noatime"), _("No &access time"), false)),
	     `query_key : "opt_noatime",
	     // help text, richtext format
	     `help_text : _("<p><b>No access time:</b>
Access times are not updated when a file is read. Default is false.</p>"),
             `type : `boolean,
	     `str_opt  : $[ 1 : "noatime", "default" : "" ],
	     `str_scan : [[ "noatime", 1 ], ["atime", 0 ]],
	   ],
	  $[
	     // button text
	     `widget : `Left(`CheckBox(`id("opt_user"), _("Mountable by &user"), false)),
	     `query_key : "opt_user",
	     // help text, richtext format
	     `help_text : _("<p><b>Mountable by User:</b>
The file system may be mounted by an ordinary user. Default is false.</p>
"),
             `type : `boolean,
	     `str_opt  : $[ 1 : "user", "default" : "" ],
	     `str_scan : [[ "nouser", 0 ], ["user", 1 ]],
	   ],
	  $[
	     // button text
	     `widget : `Left(`CheckBox(`id("opt_noauto"), `opt(`notify), _("Do Not Mount at System &Start-up"), false)),
	     `query_key : "opt_noauto",
	     // help text, richtext format
	     `help_text : _("<p><b>Do Not Mount at System Start-up:</b>
The file system is not automatically mounted when the system starts.
An entry in /etc/fstab is created and the file system is mounted
with the appropriate options when the command <tt>mount &lt;mount point&gt;</tt>
(&lt;mount point&gt; is the directory to which the file system is mounted)
is given. Default is false.</p>
"),
             `type : `boolean,
	     `str_opt  : $[ 1 : "noauto", "default" : "" ],
	     `str_scan : [[ "noauto", 1 ], ["auto", 0 ]],
	   ],
	  $[
	     // button text
	     `widget : `Left(`CheckBox(`id("opt_quota"), `opt(`notify), _("Enable &Quota Support"), false)),
	     `query_key : "opt_quota",
	     // help text, richtext format
	     `help_text : _("<p><b>Enable Quota Support:</b>
The file system is mounted with user quotas enabled.
Default is false.</p>
"),
             `type : `boolean
	   ]
	];
    return( options );
    };

global define list< map<symbol, any> > GetJournalFstabOptions()
    ``{
    list< map<symbol, any> > options =
	[ $[
	     `widget : `VBox( `ComboBox(`id("opt_journal"), `opt(`hstretch),
					// label text
					_("Data &Journaling Mode"),
					["journal", "ordered", "writeback"]),
			      `VSpacing(0.5)),
	     `default   : "ordered",
	     `query_key : "opt_journal",
	     `type : `text,
	     // help text, richtext format
	     `help_text : _("<p><b>Data Journaling Mode:</b>
Specifies the journaling mode for file data.
<tt>journal</tt> -- All data is committed into the journal prior to being
written into the main file system. Highest performance impact.<br>
<tt>ordered</tt> -- All data is forced directly out to the main file system
prior to its metadata being committed to the journal. Medium performance impact.<br>
<tt>writeback</tt> -- Data ordering is not preserved. No performance impact.</p>
"),
	     `str_opt : "data=%1",
	     `str_scan : "data=\(.*\)"
	   ]
	];
    return( options );
    };

global define list< map<symbol, any> > GetAclFstabOptions()
    ``{
    list< map<symbol, any> > options =
	[ $[
	     // button text
	     `widget : `Left(`CheckBox(`id("opt_acl"), _("&Access Control Lists (ACL)"), false)),
	     `query_key : "opt_acl",
	     // help text, richtext format
	     `help_text : _("<p><b>Access Control Lists (ACL):</b>
Enable access control lists on the file system.</p>
"),
             `type : `boolean,
	     `default : true,
	     `str_opt : $[ 0 : "noacl", "default" : "acl" ],
	     `str_scan : [[ "acl", 1 ], ["noacl", 0 ]],
	   ],
	  $[
	     // button text
	     `widget : `Left(`CheckBox(`id("opt_eua"), _("&Extended User Attributes"), false)),
	     `query_key : "opt_eua",
	     // help text, richtext format
	     `help_text : _("<p><b>Extended User Attributes:</b>
Allow extended user attributes on the file system.</p>
"),
             `type : `boolean,
	     `str_opt  : $[ 1 : "user_xattr", "default" : "" ],
	     `str_scan : [[ "user_xattr", 1 ], ["nouser_xattr", 0 ]],
	   ],
	];
    return( options );
    };

global define map<symbol, any> GetArbitraryOptionField()
    ``{
    map<symbol,any> opt = $[
	     // label text
	     `widget : `TextEntry(`id("opt_arbitrary"), _("Arbitrary option &value"), ""),
	     `query_key : "opt_arbitrary",
	     // help text, richtext format
	     `help_text : _("<p><b>Arbitrary Option Value:</b>
In this field, type any legal mount option allowed in the fourth field of /etc/fstab.
Multiple options are separated by commas.</p>
"),
             `type : `text
	   ];
    return( opt );
    };

  list< map<symbol, any> > tmpfs_fst_options = [
	$[ `widget 	    : `TextEntry( `id("tmpfs_size"), `opt(`hstretch),
			      // label text
			      _("Tmpfs &Size"), "" ),
	   `query_key   : "tmpfs_size",
	   `between     : [ 1, 200 ],
	   `empty_allowed : true,
	   `min_size : 100*1024,
	   `valid_chars : "0123456789kKmMgG%",
	   // popup text
	   `error_text  : _("Value must be above 100k or between 1% and 200%. Try again."),
	   `error_text_percent : _("Value must be 1% and 200%. Try again."),
	   `type : `text,
	   `str_opt : "size=%1",
	   `str_scan : "size=\(.*\)",
	   // help text, richtext format
	   `help_text   : _("<p><b>Tmpfs Size:</b>
Size may be either entered as a number followed by K,M,G for Kilo-, Mega- or Gigabyte or
as a number followed by a percent sign meaning percentage of memory.</p>")
     ]];

define map<symbol, map<symbol, any> > GetNormalFilesystems()``{

  list< map<symbol, any> > fat_fst_options =
      [
	$[
	   // label text
	   `widget : `ComboBox(`id("opt_iocharset"), `opt(`editable,`hstretch), _("Char&set for file names"),
	                       ["", "iso8859-1", "iso8859-15", "iso8859-2",
			        "iso8859-5", "iso8859-7", "iso8859-9", "utf8",
			        "koi8-r", "euc-jp", "sjis", "gb2312", "big5", "euc-kr" ]),
	   `query_key : "opt_iocharset",
	   `type : `text,
	     // help text, richtext format
	   `help_text : _("<p><b>Charset for File Names:</b>
Set the charset used for display of file names in Windows partitions.</p>
"),
	   `str_opt : "iocharset=%1",
	   `str_scan : "iocharset=\(.*\)"
	 ],
	$[
	   // label text
	   `widget : `ComboBox(`id("opt_codepage"), `opt(`editable,`hstretch), _("Code&page for short FAT names"),
	                       ["", "437", "852", "932", "936", "949", "950" ]),
	   `query_key : "opt_codepage",
	   `type : `text,
	     // help text, richtext format
	   `help_text : _("<p><b>Codepage for Short FAT Names:</b>
This codepage is used for converting to shortname characters on FAT file systems.</p>
"),
	   `str_opt : "codepage=%1",
	   `str_scan : "codepage=\(.*\)"
	 ]
      ];

  list< map<symbol, any> > vfat_options =
      [
       $[
	 // label text
	 `widget	: `ComboBox(`id("opt_number_of_fats"), `opt(`hstretch), _("Number of &FATs"), [ "auto" , "1", "2" ]),
	 `query_key	: "opt_number_of_fats",
	 `option_str	: "-f",
	     // help text, richtext format
	 `help_text	: _("<p><b>Number of FATs:</b>
Specify the number of file allocation tables in the file system. The default is 2.</p>")
       ],
	 $[
	 // label text
	   `widget	: `ComboBox(`id("opt_fat_size"), `opt(`hstretch), _("FAT &size"), ["auto",
											  `item(`id("12"), "12 bit"),
											  `item(`id("16"), "16 bit"),
											  `item(`id("32"), "32 bit") ]),
	   `query_key 	: "opt_fat_size",
	   `option_str	: "-F",
	     // help text, richtext format
	   `help_text	: _("<p><b>FAT size:</b>
Specifies the type of file allocation tables used (12, 16, or 32-bit). If auto is specified, YaST2 will automatically select the value most suitable for the file system size.</p>
")
	 ],
	 $[
	 // label text
	   `widget 	: `TextEntry(`id("opt_root_dir_entries"), `opt(`hstretch), _("Root &dir entries"), "auto"),
	   `query_key 	: "opt_root_dir_entries",
	   `option_str	: "-r",
	   `between	: [ 112, -1],
	   `valid_chars : "0123456789",
	   // popup text
	   `error_text 	: _("The minimum size for \"Root dir entries\" is 112. Please try again."),
	     // help text, richtext format
	   `help_text	: _("<p><b>Root dir entries:</b>
Select the number of entries available in the root directory.</p>")
	 ]
  ];


  list< map<symbol, any> > reiserfs_options =   [
			     $[
			       // label text
			       `widget     	: `ComboBox(`id("opt_hash"), `opt(`hstretch), _("Hash &function"), ["auto", "r5", "tea" ,"rupasov" ]),
			       `query_key		: "opt_hash",
			       `option_str	: "--hash",
			       `option_blank    : true,
	     // help text, richtext format
			       `help_text		: _("<p><b>Hash function:</b>
This specifies the name of the hash function to use to sort the file names in directories.</p>")
			     ],
			       $[
			       // label text
				 `widget     	: `ComboBox(`id("opt_format"), `opt(`hstretch), _("FS &revision"), ["auto", "3.5", "3.6" ]),
				 `query_key		: "opt_format",
				 `option_str	: "--format",
			         `option_blank  : true,
	     // help text, richtext format
				 `help_text		: _("<p><b>FS revision:</b>
This option defines the reiserfs format revision to use. '3.5' is for backwards compatibility with kernels of the 2.2.x series. '3.6' is more recent, but can only be used with kernel versions greater than or equal to 2.4.</p>
")
			       ]
  ];


  list< map<symbol, any> > xfs_options	=  [
			      $[
			     // label text
				   `widget     	: `ComboBox(`id("opt_blocksize"), `opt(`hstretch), _("Block &size in bytes"), ["auto","512","1024", "2048","4096" /*,"8192", "16384","32768"*/ ]),
				   `query_key	: "opt_blocksize",
				   `option_str	: "-bsize=",
	     // help text, richtext format
				   `help_text  	: _("<p><b>Block size:</b>
Specify the size of blocks in bytes. Valid block size values are 512, 1024, 2048, and 4096 bytes per block. If auto is selected, the standard block size of 4096 is used.</p>
")
				 ],
			      $[
			       // label text
				`widget   	: `ComboBox(`id("opt_bytes_per_inode"), `opt(`hstretch), _("&Inode Size"),["auto","256", "512", "1024", "2048"]),
				`query_key	: "opt_bytes_per_inode",
				`option_str  	: "-isize=",
	     // help text, richtext format
				`help_text  	: _("<p><b>Inode Size:</b>
This option specifies the inode size of the file system.</p>\n")
			      ],
			      $[
			       // label text
				`widget   	: `ComboBox(`id("opt_max_inode_space"), `opt(`hstretch), _("&Percentage of inode space"),["auto", "5", "10", "15", "20","25","30",
																	 "35", "40", "45", "50", "55", "60", "65",
																	 "70", "75", "80", "85", "90", "95",
																	 `item(`id("0"), "100") ]),
				`query_key	: "opt_max_inode_space",
				`option_str  	: "-imaxpct=",
	     // help text, richtext format
				`help_text  	: _("<p><b>Percentage of inode space:</b>
The option \"Percentage of inode space\" specifies the maximum percentage of space in the file system that can be allocated to inodes.</p>
")
			      ],
			      $[
			       // label text
				`widget   	: `ComboBox(`id("opt_inode_align"), `opt(`hstretch), _("Inode &aligned"),[ "auto", `item(`id("1"), "true"),
															 `item( `id("0"), "false")  ]),
				`query_key	: "opt_inode_align",
				`option_str  	: "-ialign=",
	     // help text, richtext format
				`help_text  	: _("<p><b>Inode Aligned:</b>
The option \"Inode Aligned\" is used to specify whether inode allocation is or
is not aligned. The default is that inodes are aligned. Aligned inode access
is normally more efficient than unaligned access.</p>
")
			      ]
  ];


  list< map<symbol, any> > jfs_options = [
/*
	    $[
	   // label text
	   `widget : `ComboBox(`id("opt_iocharset"), `opt(`editable,`hstretch), _("Char&set for file names"),
	                       ["", "iso8859-1", "iso8859-15", "iso8859-2",
			        "iso8859-5", "iso8859-7", "iso8859-9", "utf8",
			        "koi8-r", "euc-jp", "sjis", "gb2312", "big5", "euc-kr" ]),
	   `query_key : "opt_iocharset",
	   `type : `text,
	     // help text, richtext format
	   `help_text : _("<p><b>Charset for File Names:</b>
Set the charset used to display file names on the partition.</p>\n"),
	   `str_opt : "iocharset=%1",
	   `str_scan : "iocharset=\(.*\)"
	 ],
*/
		      $[
		       // label text
			`widget 		: `TextEntry(`id("opt_log_size"), `opt(`hstretch),_("&Log size in megabytes"), "auto"),
			`query_key	: "opt_log_size",
			`option_str	: "-s",
			// no way to find out the max log size ????
			`between		: [ 0 , -1 ], //  -> -1 = infinite
			`valid_chars 	: "0123456789",
		       // popup text
			`error_text 	: _("The \"Log size\" value is incorrect.\nPlease enter a value greater than zero."),
			// xgettext: no-c-format
	     // help text, richtext format
			`help_text  	: _("<p><b>Log size</b>
Set the log size (in megabytes). If auto, the default is 40% of the aggregate size.</p>")
		      ],
		      $[
		       // label text
			`widget		: `CheckBox(`id("opt_blocks_utility"), _("Invoke Bad Blocks List &Utility"), false),
			`query_key	: "opt_blocks_utility",
			`option_str	: "-c"
		      ]
  ];

  list< map<symbol, any> > ext2_options  =  [
			       $[
				 // label text
				 `widget     	: `TextEntry(`id("opt_raid"), `opt(`hstretch), _("Stride &length in blocks"), "none" ),
				 `query_key	: "opt_raid",
				 `option_str	: "-Rstride=",
				 `valid_chars	: "0123456789",
				 `between		: [ 1, -1],
				 // popup text
				 `error_text	: _("The \"Stride length in blocks\" value is not possible.\nPlease select a value greater than 1."),
	     // help text, richtext format
				 `help_text	: _("<p><b>Stride Length in Blocks:</b>
Set RAID-related options for the file system. Currently, the only supported
argument is 'stride', which takes the number of blocks in a
RAID stripe as its argument.</p>
")
			       ],
				 $[
				 // label text
				   `widget     	: `ComboBox(`id("opt_blocksize"), `opt(`hstretch), _("Block &size in bytes"), ["auto","1024", "2048","4096" /*,"8192", "16384","32768"*/ ]),
				   `query_key	: "opt_blocksize",
				   `option_str	: "-b",
	     // help text, richtext format
				   `help_text  	: _("<p><b>Block size:</b>
Specify the size of blocks in bytes. Valid block size values are 1024, 2048, and 4096 bytes per block. If auto is selected, the block size is determined by the file system size and the expected use of the file system.</p>\n")
				 ],
				 $[
				   // label text
				   `widget   	: `ComboBox(`id("opt_inode_density"), `opt(`hstretch), _("Bytes per &inode"),["auto","1024", "2048","4096","8192", "16384","32768" ]),
				   `query_key	: "opt_inode_density",
				   `option_str 	: "-i",
	     // help text, richtext format
				   `help_text  	: _("<p><b>Bytes per inode:</b>
Specify the bytes to inode ratio. YaST2 creates an inode for every &lt;bytes-per-inode&gt; bytes of space on the disk. The larger the bytes-per-inode ratio, the fewer inodes will be created.
Generally, this value should not be smaller than the block size of the file system, since too many inodes will be created in this case.  It is not possible to expand the
number of inodes on a file system after its creation, so be sure to enter a reasonable value for this parameter.</p>
")
				 ],
				 $[
				   // label text
				   `widget   	: `TextEntry(`id("opt_reserved_blocks"), `opt(`hstretch), _("Percentage of blocks &reserved for root"), "auto" ),
				   `query_key	: "opt_reserved_blocks",
				   `option_str  : "-m",
				   //`default 	: 5,
				   `below	: 99,
				   `str_length	: 6,
				   `valid_chars : "0123456789.",
				   // popup text
				   `error_text  : _("The \"Percentage of blocks reserved for root\" value is incorrect.\nAllowed are float numbers not larger than 99. (e.g. 0.5)"),
				   // xgettext: no-c-format
	     // help text, richtext format
				   `help_text  	: _("<p><b>Percentage of blocks reserved for root:</b> Specify the percentage of blocks reserved for the super user. The default is computed so that normally 1 Gig is reserved. Upper limit for reserved default is 5.0, lowest reserved default is 0.1.</p>")
				 ],
			         $[
				   // checkbox text
				   `widget	: `CheckBox(`id("opt_reg_checks"), `opt(`hstretch), _("Disable regular checks")),
				   `query_key	: "opt_reg_checks",
				   `option_str	: "-c 0 -i 0",
				   `option_cmd	: `tunefs,
				   `type	: `boolean,
				   `default     : false,
				   // help text, richtext format
				   `help_text  	: _("<p><b>Disable regular checks:</b>
Disable regular file system check at booting.</p>\n")
				 ]
      ];

  list< map<symbol, any> > ext3_only_options = [
      $[
      // label text
      `widget   	: `ComboBox(`id("opt_bytes_per_inode"), `opt(`hstretch), _("&Inode Size"),["default", "128", "256", "512", "1024"]),
      `query_key	: "opt_bytes_per_inode",
      `option_str  	: "-I",
       // help text, richtext format
      `help_text  	: _("<p><b>Inode Size:</b>
This option specifies the inode size of the file system.</p>\n")
      ],
      $[
      // label text
      `widget   	: `CheckBox(`id("opt_dir_index"), `opt(`hstretch), _("&Directory Index Feature")),
      `query_key	: "opt_dir_index",
      `option_str  	: "-O dir_index",
      `option_false  	: "-O ^dir_index",
      `type             : `boolean,
       // help text, richtext format
      `help_text  	: _("<p><b>Directory Index:</b>
Enables use of hashed b-trees to speed up lookups in large directories.</p>\n")
      ]
  ];

list< map<symbol, any> > ext4_only_options = [
      $[
      // label text
      `widget   	: `CheckBox(`id("no_journal"), `opt(`hstretch), _("&No Journal")),
      `query_key	: "no_journal",
      `option_str  	: "-O ^has_journal",
      `type             : `boolean,
      `default          : false,
       // help text, richtext format
      `help_text  	: _("<p><b>No Journal:</b>
Suppressed use of journaling on filesystem. Only activate this when you really
know what you are doing.</p>\n")
      ]
    ];

  list< map<symbol, any> > ext3_options = (list< map<symbol, any> >)merge( ext2_options, ext3_only_options );
  list< map<symbol, any> > ext4_options = (list< map<symbol, any> >)merge( ext2_options, ext3_only_options );
  ext4_options = (list< map<symbol, any> >)merge( ext4_options, ext4_only_options );

  list< map<symbol, any> > ext2_fst_options = [ ];
  list< map<symbol, any> > ext3_fst_options = [ ];
  list< map<symbol, any> > ext4_fst_options = [ ];
  list< map<symbol, any> > reiser_fst_options = [ ];


  map <symbol, map<symbol, any> > RealFileSystems  = $[
		      `ext2	: $[
				    `name 		: "Ext2",
				    `fsid 		: Partitions::fsid_native,
				    `real_fs            : true,
				    `supports_format 	: true,
				    `fsid_item 		: "0x83 Linux ",
				    `fstype 		: "Linux native" ,
				    `crypt 		: true ,
				    `mountpoints 	: SuggestMPoints(),
				    `mount_option	: "-t ext2",
				    `mount_string	: "ext2",
				    `fst_options  	: ext2_fst_options,
				    `options  		: ext2_options,
		      ],
		      `vfat	: $[
				    `name 		: "FAT",
				    `fsid 		: 12,
				    `real_fs            : true,
				    `alt_fsid           : [ 12, 0x103 ],
				    `supports_format 	: true ,
				    `fsid_item 		: "0x0C Win95 FAT32 ",
				    `fstype 		: "Fat32",
				    `crypt 		: true ,
				    `mountpoints 	: SuggestMPoints() ,
				    `mount_option	: "-t vfat",
				    `mount_string	: "vfat",
				    `needed_modules	: [ "fat", "vfat" ],
				    `fst_options  	: fat_fst_options,
				    `options 		: vfat_options

		      ],
		      `reiser 	: $[
				    `name 		: "Reiser",
				    `fsid 		: Partitions::fsid_native,
				    `real_fs            : true,
				    `supports_format 	: true ,
				    `fsid_item 		: "0x83 Linux " ,
				    `fstype 		: "Linux native",
				    `crypt 		: true,
				    `mountpoints 	: SuggestMPoints(),
				    `mount_option 	: "-t reiserfs",
				    `mount_string	: "reiserfs",
				    `needed_modules	: [ "reiserfs" ],
				    `fst_options  	: reiser_fst_options,
				    `options 		: reiserfs_options
		      ],
		      `xfs 	: $[
				    `name 		: "XFS",
				    `fsid 		: Partitions::fsid_native,
				    `real_fs            : true,
				    `supports_format 	: true ,
				    `fsid_item 		: "0x83 Linux " ,
				    `fstype 		: "Linux native" ,
				    `crypt 		: true,
				    `mountpoints 	: SuggestMPoints(),
				    `mount_option 	: "-t xfs",
				    `mount_string	: "xfs",
				    `needed_modules	: [ "xfs" ],
				    `options 		: xfs_options
		      ],
		      `jfs 	: $[
				    `name 		: "JFS",
				    `fsid 		: Partitions::fsid_native,
				    `real_fs            : true,
				    `supports_format 	: true ,
				    `fsid_item 		: "0x83 Linux " ,
				    `fstype 		: "Linux native" ,
				    `crypt		: true,
				    `mountpoints 	: SuggestMPoints(),
				    `mount_string	: "jfs",
				    `mount_option	: "-t jfs",
				    `needed_modules	: [ "jfs" ],
				    `options      	: jfs_options
		      ],
		      `ext3 	: $[
				    `name 		: "Ext3",
				    `fsid 		: Partitions::fsid_native,
				    `real_fs            : true,
				    `supports_format 	: true ,
				    `fsid_item 		: "0x83 Linux " ,
				    `fstype 		: "Linux native" ,
				    `crypt		: true,
				    `mountpoints 	: SuggestMPoints(),
				    `mount_string	: "ext3",
				    `mount_option	: "-t ext3",
				    `needed_modules	: [ "jbd", "mbcache", "ext3" ],
				    `fst_options  	: ext3_fst_options,
				    `options      	: ext3_options
		      ], 
		      `ext4 	: $[
				    `name 		: "Ext4",
				    `fsid 		: Partitions::fsid_native,
				    `real_fs            : true,
				    `supports_format 	: true ,
				    `fsid_item 		: "0x83 Linux " ,
				    `fstype 		: "Linux native" ,
				    `crypt		: true,
				    `mountpoints 	: SuggestMPoints(),
				    `mount_string	: "ext4",
				    `mount_option	: "-t ext4",
				    `needed_modules	: [ "jbd2", "mbcache", "ext4" ],
				    `fst_options  	: ext4_fst_options,
				    `options      	: ext4_options
		      ],
		      `btrfs 	: $[
				    `name 		: "BtrFS",
				    `fsid 		: Partitions::fsid_native,
				    `real_fs            : true,
				    `supports_format 	: true ,
				    `fsid_item 		: "0x83 Linux " ,
				    `fstype 		: "Linux native" ,
				    `crypt		: true,
				    `mountpoints 	: SuggestMPoints(),
				    `mount_string	: "btrfs",
				    `mount_option	: "-t btrfs",
				    `needed_modules	: [ "btrfs" ],
				    `fst_options  	: [],
				    `options      	: []
		      ],
		      `hfs 	: $[
				    `name 		: "MacHFS",
				    `fsid 		: Partitions::fsid_mac_hfs,
				    `real_fs            : true,
				    `supports_format 	: true,
				    `alt_fsid           : [ 0x83 ],
				    `fsid_item 		: "0x102 Apple_HFS " ,
				    `fstype 		: "Apple_HFS " ,
				    `crypt		: false,
				    `mountpoints 	: [],
				    `mount_string	: "hfs",
				    `mount_option	: "-t hfs",
				    `needed_modules	: [ "hfs" ],
				    `fst_options  	: [],
				    `options      	: []
		      ],
		      `hfsplus  : $[
				    `name 		: "MacHFS+",
				    `fsid 		: Partitions::fsid_mac_hfs,
				    `real_fs            : true,
				    `supports_format 	: false,
				    `alt_fsid           : [ 0x83 ],
				    `fsid_item 		: "0x102 Apple_HFS " ,
				    `fstype 		: "Apple_HFS " ,
				    `crypt		: false,
				    `mountpoints 	: [],
				    `mount_string	: "hfsplus",
				    `mount_option	: "-t hfsplus",
				    `needed_modules	: [ "hfsplus" ],
				    `fst_options  	: [],
				    `options      	: []
		      ],
		      `ntfs  : $[
				    `name 		: "NTFS",
				    `fsid 		: 7,
				    `real_fs            : true,
				    `supports_format 	: false,
				    `alt_fsid           : Partitions::fsid_ntfstypes,
				    `fsid_item 		: "0x07 NTFS " ,
				    `fstype 		: "NTFS " ,
				    `crypt		: false,
				    `mountpoints 	: [],
				    `mount_string	: "ntfs-3g",
				    `mount_option	: "-t ntfs",
				    `needed_modules	: [ "ntfs" ],
				    `fst_options  	: [],
				    `options      	: []
		      ],
		      `tmpfs 	: $[
				    `name 		: "TmpFS",
				    `mountpoints 	: SuggesTmpfsMPoints(),
				    `mount_string	: "tmpfs",
				    `mount_option	: "-t tmpfs",
				    `fst_options  	: tmpfs_fst_options,
		      ]
  ];

  return( RealFileSystems );
  };

  list< map<symbol, any> > swap_fst_options = [
    $[ `widget 	    : `TextEntry( `id("priority"), `opt(`hstretch),
				  // label text
                                  _("Swap &Priority"), "42" ),
       `query_key   : "priority",
       `between	    : [ 0, 32767],
       `empty_allowed : true,
       `valid_chars : "0123456789",
       // popup text
       `error_text  : _("Value must be between 0 and 32767. Try again."),
       `type : `text,
       `str_opt : "pri=%1",
       `str_scan : "pri=\(.*\)",
	 // help text, richtext format
       `help_text   : _("<p><b>Swap Priority:</b>
Enter the swap priority. Higher numbers mean higher priority.</p>
")
     ]];

  map<symbol, any> SwapFileSystems =
    $[ `swap :
	$[ `name 	    : "Swap",
	   `fsid 	    : Partitions::fsid_swap,
	   `real_fs         : true,
	   `supports_format : true,
	   `fsid_item 	    : "0x82 Linux swap ",
	   `fstype 	    : "Linux swap",
	   `crypt 	    : true,
	   `fst_options     : swap_fst_options,
	   `mountpoints     : swap_m_points
	 ]
     ];


  map<symbol, map<symbol, any> > PseudoFileSystems = $[
			    `lvm	: $[
					    `name 		: "LVM",
					    `fsid 		: Partitions::fsid_lvm,
					    `supports_format 	: false,
					    `fsid_item 		: "0x8E Linux LVM "
			    ],
			    `raid	: $[
					    `name 		: "RAID",
					    `fsid 		: Partitions::fsid_raid,
					    `supports_format 	: false,
					    `fsid_item 		: "0xFD Linux RAID "
			    ],
			    `xbootdisk : $[
					   `name 		: "PPCBOOT",
					   `fsid 		: Partitions::fsid_prep_chrp_boot,
					   `supports_format 	: false,
					   `fsid_item 		: "0x41 PPC PReP Boot"
			    ],
			    `xbootfat  : $[
					   `name 		: "FATBOOT",
					   `fsid 		: Partitions::fsid_fat16,
					   `supports_format 	: false,
					   `fsid_item 		: "0x06 FAT16 Boot"
			    ],
			    `xhibernate : $[
					   `name 		: "Hibernate",
					   `fsid 		: Partitions::fsid_hibernation,
					   `supports_format 	: false,
					   `fsid_item 		: "0xA0 Hibernation"
					   ],
			    `xxefi      : $[
			                   `name                : "Efi Boot",
					   `fsid                : Partitions::fsid_gpt_boot,
					   `supports_format     : false,
					   `fsid_item           : "0x103 EFI Boot"
					   ]
  ];


  /**
   * Filesystem Definitions
   * @return map map with all supported filesystems
   */
global define map<symbol, map<symbol, any> > GetAllFileSystems(boolean add_swap, boolean add_pseudo )
    ``{ 
    map<symbol, map<symbol, any> > ret = filter( symbol fs_key, map<symbol,any> fs_map, GetNormalFilesystems(),
                      ``( support[fs_key]:false ));

    if( add_swap )
	{
	ret = (map<symbol, map<symbol, any> >)union( ret, SwapFileSystems );
	}
    if( add_pseudo )
	{
	ret = (map<symbol, map<symbol, any> >)union( ret, filter( symbol fs_key, any fs_map, PseudoFileSystems,
				  ``( support[fs_key]:false )));
	}
    return ret;
    }

global define map<symbol,any> GetTmpfsFilesystem()
    {
    return( GetNormalFilesystems()[`tmpfs]:$[] );
    }

global define list< map<symbol, any> > GetFstabOptWidgets( symbol fsys )
    ``{
    list< map<symbol, any> > ret = [];
    if( fsys == `swap )
	ret = swap_fst_options;
    else if( fsys == `tmpfs )
	ret = tmpfs_fst_options;
    else
	{
	map<symbol, map<symbol, any> > fs = GetAllFileSystems( true, false );
	ret = fs[fsys,`fst_options]:[];
	if( contains( [`ext3, `ext4, `reiser], fsys ) )
	    {
	    ret = (list< map<symbol, any> >)union( ret, GetJournalFstabOptions() );
	    }
	if( contains( [`ext2, `ext3, `ext4, `reiser], fsys ) )
	    {
	    ret = (list< map<symbol, any> >)union( ret, GetAclFstabOptions() );
	    }
	}
    y2milestone("fsys:%1 ret:%2", fsys, ret);
    return ret;
    };


    global void FileSystems()
    {
    if( Arch::sparc64() || Arch::sparc32() )
	{
        support[`vfat] = false;
	}
    if( Arch::ppc() )
	{
	support[`vfat] = Arch::board_chrp();
	support[`xbootdisk] = true;
	support[`xbootfat] = Arch::board_chrp();
	}
    if( Arch::s390() )
	{
	support[`vfat] = false;
	}
    if( Arch::ia64() )
	{
	support[`jfs] = false;
	support[`xxefi] = true;
	}
    if( Arch::alpha() )
	{
	support[`reiser] = false;
	}
    if( Arch::board_mac() )
	{
	support[`hfs] = true;
	support[`hfsplus] = true;
	}
    y2milestone( "support %1", support );
    }


    global void InitSlib(any value)
    {
	sint = value;
	if( sint!=nil )
	    {
	    string ret = LibStorage::StorageInterface::getDefaultSubvolName(sint);
	    y2milestone( "InitSlib libstorage default_subvol:\"%1\"", ret );
	    ret = "@";
	    //ret = "";
	    LibStorage::StorageInterface::setDefaultSubvolName(sint,ret);
	    ret = LibStorage::StorageInterface::getDefaultSubvolName(sint);
	    default_subvol = ret;
	    y2milestone( "InitSlib used default_subvol:\"%1\"", default_subvol );
	    }

    }


global define boolean IsSupported( symbol used_fs)
    ``{
    return support[ used_fs ]:false;
    }

global define boolean IsUnsupported( symbol used_fs)
    ``{
    return( contains( unsupportFs, used_fs ));
    }

global define map<symbol, any> GetFsMap( symbol used_fs )
    ``{
    map<symbol, map<symbol, any> > allfs = GetAllFileSystems( true, true  );
    if( haskey( allfs, used_fs ))
	return allfs[ used_fs]:$[];
    else
	{
	map<symbol, map<symbol, any> > fs = GetNormalFilesystems();
	return( fs[used_fs]:$[] );
	}
    }


    global string GetName( symbol used_fs, string defaultv )
    {
      map<symbol,any> fsmap 	= GetFsMap( used_fs);
      string ret        = fsmap[`name]:"";
      if ( ret == "" && used_fs == `ntfs ) ret = "NTFS";	// obsolete? (included in RealFileSystems)
      if ( ret == "" && used_fs == `nfs ) ret = "NFS";  
      if ( ret == "" && used_fs == `nfs4 ) ret = "NFS4";
      if ( ret == "" ) ret = defaultv;
      return ret;
    }


  global define integer GetFsid( symbol used_fs )``{
      map<symbol,any> fsmap 	= GetFsMap( used_fs);
      return fsmap[`fsid]:Partitions::fsid_native;
  }

  global define boolean GetSupportFormat( symbol used_fs )``{
      map<symbol,any> fsmap 	= GetFsMap( used_fs);
      return (boolean)(fsmap[`supports_format]:nil);
  }

  global define string GetFsidItem( symbol used_fs )``{
      map<symbol,any> fsmap 	= GetFsMap( used_fs);
      return fsmap[`fsid_item ]:"";
  }

  global define string GetFstype( symbol used_fs )``{
      map<symbol,any> fsmap 	= GetFsMap( used_fs);
      return fsmap[`fstype ]:"";
  }

  global define boolean GetCrypt( symbol used_fs )``{
      map<symbol,any> fsmap 	= GetFsMap( used_fs);
      return (boolean)(fsmap[`crypt ]:nil);
  }

  global define list GetPossibleMountPoints( symbol used_fs )``{
      map<symbol,any> fsmap 	= GetFsMap( used_fs);
      return fsmap[`mountpoints ]:[];
  }

  global define string GetMountOption( symbol used_fs )``{
      map<symbol,any> fsmap 	= GetFsMap( used_fs);
      return fsmap[`mount_option ]:"";
  }

  global define list GetOptions( symbol used_fs )``{
      map<symbol,any> fsmap 	= GetFsMap( used_fs);
      return fsmap[`options ]:[];
  }


    /**
     * Return the mount option for each used_fs (-t)
     * @return string
     */
    global string GetMountString(symbol used_fs, string defaultv)
    {
	map<symbol, any> fsmap = GetFsMap(used_fs);
	string ret = fsmap[`mount_string ]:defaultv;
	y2milestone("GetMountString used_fs:%1 ret:%2", used_fs, ret);
	return ret;
    }


    global list<string> GetNeededModules(symbol used_fs)
    {
	map<symbol, any> fsmap = GetFsMap(used_fs);
	list<string> ret = fsmap[`needed_modules ]:[];
	y2milestone("GetNeededModules used_fs:%1 ret:%2", used_fs, ret);
	return ret;
    }


    global integer MinFsSizeK(symbol fsys)
    {
	integer ret = 0;
	integer id = fromSymbol(conv_fs, fsys);
	any caps = LibStorage::FsCapabilities::new("LibStorage::FsCapabilities");
	if (LibStorage::StorageInterface::getFsCapabilities(sint, id, caps))
	    ret = LibStorage::FsCapabilities::swig_minimalFsSizeK_get(caps);
	y2milestone("MinFsSizeK fsys:%1 ret:%2", fsys, ret);
	return ret;
    }


    global boolean MountUuid(symbol fsys)
    {
	boolean ret = false;
	integer id = fromSymbol(conv_fs, fsys);
	any caps = LibStorage::FsCapabilities::new("LibStorage::FsCapabilities");
	if (LibStorage::StorageInterface::getFsCapabilities(sint, id, caps))
	    ret = LibStorage::FsCapabilities::swig_supportsUuid_get(caps);
	y2milestone("MountUuid fsys:%1 ret:%2", fsys, ret);
	return ret;
    }


    global boolean MountLabel(symbol fsys)
    {
	boolean ret = false;
	integer id = fromSymbol(conv_fs, fsys);
	any caps = LibStorage::FsCapabilities::new("LibStorage::FsCapabilities");
	if (LibStorage::StorageInterface::getFsCapabilities(sint, id, caps))
	    ret = LibStorage::FsCapabilities::swig_supportsLabel_get(caps);
	y2milestone("MountLabel fsys:%1 ret:%2", fsys, ret);
	return ret;
    }


    global boolean ChangeLabelMounted(symbol fsys)
    {
	boolean ret = false;
	integer id = fromSymbol(conv_fs, fsys);
	any caps = LibStorage::FsCapabilities::new("LibStorage::FsCapabilities");
	if (LibStorage::StorageInterface::getFsCapabilities(sint, id, caps))
	    ret = LibStorage::FsCapabilities::swig_labelWhileMounted_get(caps);
	y2milestone("ChangeLabelMounted fsys:%1 ret:%2", fsys, ret);
	return ret;
    }


    global integer LabelLength(symbol fsys)
    {
	integer ret = 0;
	integer id = fromSymbol(conv_fs, fsys);
	any caps = LibStorage::FsCapabilities::new("LibStorage::FsCapabilities");
	if (LibStorage::StorageInterface::getFsCapabilities(sint, id, caps))
	    ret = LibStorage::FsCapabilities::swig_labelLength_get(caps);
	y2milestone("LabelLength fsys:%1 ret:%2", fsys, ret);
	return ret;
    }


    global map<string, boolean> IsResizable(symbol fsys)
    {
	map<string, boolean> ret = $[];
	integer id = fromSymbol(conv_fs, fsys);
	any caps = LibStorage::FsCapabilities::new("LibStorage::FsCapabilities");
	if (LibStorage::StorageInterface::getFsCapabilities(sint, id, caps))
	{
	    ret = $[
		"extend" : LibStorage::FsCapabilities::swig_isExtendable_get(caps),
		"shrink" : LibStorage::FsCapabilities::swig_isReduceable_get(caps),
		"mount_extend" : LibStorage::FsCapabilities::swig_isExtendableWhileMounted_get(caps),
		"mount_shrink" : LibStorage::FsCapabilities::swig_isReduceableWhileMounted_get(caps)
	    ];
	}
	y2milestone("IsResizable fsys:%1 ret:%2", fsys, ret);
	return ret;
    }


    global symbol FsToSymbol(string type)
    {
	symbol ret = `none;

	if (type == "ext2")
	    ret = `ext2;
	else if (type == "ext3")
	    ret = `ext3;
	else if (type == "ext4")
	    ret = `ext4;
	else if (type == "btrfs")
	    ret = `btrfs;
	else if (regexpmatch(type, "reiser.*"))
	    ret = `reiser;
	else if (type == "jfs")
	    ret = `jfs;
	else if (type == "xfs" )
	    ret = `xfs;
	else if (type == "vfat" || regexpmatch(type, "fat.*"))
	    ret = `vfat;
	else if (type == "ntfs")
	    ret = `ntfs;
	else if (type == "hfs")
	    ret = `hfs;
	else if (type == "swap")
	    ret = `swap;

	return ret;
    }


global define boolean IsCryptMp( string mount, boolean prefix )
    ``{
    boolean ret = contains( crypt_m_points(), mount );
    if( !ret && prefix )
	{
	list<string> mp = filter(string s, system_m_points(), ``(s!="/") );
	foreach(string s, mp,
	    ``{
	    ret = ret || search( mount, s + "/" )==0;
	    });
	}
    y2milestone( "IsCryptMp mount:%1 prefix:%2 ret:%3", mount, prefix, ret );
    return( ret );
    };

global define boolean IsSystemMp( string mount, boolean prefix )
    ``{
    boolean ret = contains( system_m_points(), mount );
    if( !ret && prefix )
	{
	list<string> mp = filter(string s, system_m_points(), ``(s!="/") );
	foreach(string s, mp,
	    ``{
	    ret = ret || search( mount, s + "/" )==0;
	    });
	}
    if( size(mount)>0 )
	y2milestone( "IsSystemMp mount:%1 prefix:%2 ret:%3", mount, prefix, ret );
    return( ret );
    };

global define string RemoveCryptOpts( string opt )
    ``{
    string ret = opt;
    ret = String::CutRegexMatch( ret, ",*loop[^,]*", true );
    ret = String::CutRegexMatch( ret, ",*encryption=[^,]*", true );
    ret = String::CutRegexMatch( ret, ",*phash=[^,]*", true );
    ret = String::CutRegexMatch( ret, ",*itercountk=[^,]*", true );
    if( size(ret)!=size(opt) )
	{
	ret = String::CutRegexMatch( ret, "^,", false );
	y2milestone( "in %1 ret %2", opt, ret );
	}
    return( ret );
    };

map lenc = $[ "el" : "iso8859-7",
              "hu" : "iso8859-2",
	      "cs" : "iso8859-2",
	      "hr" : "iso8859-2",
	      "sl" : "iso8859-2",
	      "sk" : "iso8859-2",
	      "en" : "iso8859-1",
	      "tr" : "iso8859-9",
	      "lt" : "iso8859-13",
	      "bg" : "iso8859-5",
	      "ru" : "iso8859-5"];

global define string LangTypicalEncoding()
    ``{
    string lang = Encoding::GetEncLang();
    string enc = "utf8";
    if( !Encoding::GetUtf8Lang() )
	{
	enc = "iso8859-15";
	lang = substring(lang, 0, 2);
	lang = tolower(lang);
	if( haskey( lenc, lang ) )
	    {
	    enc = lenc[lang]:"";
	    }
	}
    y2milestone( "LangTypicalEncoding lang %1 ret %2", lang, enc );
    return( enc );
    }

global define string DefaultFstabOptions( map part )
    ``{
    symbol fsys = part["used_fs"]:`none;
    string fst_default = "";
    if( part["format"]:false && contains( [`ext2, `ext3, `ext4, `reiser ], fsys ) )
	{
	fst_default = "acl,user_xattr";
	}
    else if( part["format"]:false && fsys == `btrfs && default_subvol!="" )
	{
	fst_default = "subvol=" + default_subvol;
	}
    else if( !Arch::ia64() && contains( [`vfat, `ntfs], fsys ) )
	{
	fst_default = "users,gid=users";
	string enc = LangTypicalEncoding();
	string code = Encoding::GetCodePage(enc); 
	if( size(enc)>0 )
	    {
	    if( fsys != `ntfs )
		{ 
		fst_default = fst_default + ",umask=0002";
		if( enc=="utf8" )
		    fst_default = fst_default + ",utf8=true";
		else
		    fst_default = fst_default + ",iocharset=" + enc;
		}
	    else
		{
		fst_default = fst_default + ",fmask=133,dmask=022";
		map m = (map)SCR::Execute( .target.bash_output, "locale | grep LC_CTYPE" );
		list<string> sl = splitstring( m["stdout"]:"", "\n" );
		sl = splitstring( sl[0]:"", "=" );
		y2milestone( "DefaultFstabOptions sl %1", sl );
		if( size(sl[1]:"")>0 )
		    fst_default = fst_default + ",locale=" + deletechars(sl[1]:"", "\"" );
		}
	    }
	if( size(code)>0 && code != "437" && fsys!=`ntfs )
	    {
	    fst_default = fst_default + ",codepage=" + code;
	    }
	}

    any dp = LibStorage::ContVolInfo::new("LibStorage::ContVolInfo");
    string dev = part["device"]:"";
    LibStorage::StorageInterface::getContVolInfo(sint, dev, dp);
    integer t = LibStorage::ContVolInfo::swig_ctype_get(dp);
    if( t == LibStorage::DISK() )
	{
	any infos = LibStorage::DiskInfo::new("LibStorage::DiskInfo");
	string disk = LibStorage::ContVolInfo::swig_cdevice_get(dp);
	y2milestone( "DefaultFstabOptions disk:%1", disk );
	integer r = LibStorage::StorageInterface::getDiskInfo(sint, disk, infos);
	if( r==0 )
	    {
	    if(LibStorage::DiskInfo::swig_iscsi_get(infos))
		{
		if( size(fst_default)>0 )
		    fst_default = fst_default + ",";
		fst_default = fst_default + "nofail";
		}
	    }
	}

    y2milestone( "DefaultFstabOptions dev %3 fsys %1 is %2", fsys, fst_default, dev );
    return( fst_default );
    }


global map <string, map <string, any> > DefaultFormatOptions( map part )
{
    map <string, map <string, any> > ret = $[];
    symbol fsys = part["used_fs"]:`none;
    if( part["format"]:false )
    {
	if (contains([ `ext3, `ext4 ], fsys))
	{
	    ret["opt_dir_index"] = $[ "option_str" : "-O dir_index",
				      "option_value" : true ];
	    ret["opt_reg_checks"] = $[ "option_str" : "-c 0 -i 0", 
				       "option_value" : true,
				       "option_cmd" : `tunefs ];
	}
	if( Arch::board_pegasos() && contains( [`ext2, `ext3, `ext4], fsys ) ) 
	{
	    ret["opt_bytes_per_inode"] = $[ "option_str" : "-I",
					    "option_value" : "128" ];
	}
	if( Arch::s390() && contains( [`ext2, `ext3, `ext4], fsys ) ) 
	{
	    ret["opt_blocksize"] = $[ "option_str" : "-b",
	                              "option_value" : "4096" ];
	}
	if( contains( [`ext2, `ext3, `ext4], fsys ) ) 
	{
	    if( Arch::s390() )
	    {
		ret["opt_blocksize"] = $[ "option_str" : "-b",
					  "option_value" : "4096" ];
	    }
	    float f = (1048576.0 / (part["size_k"]:0)) * 100;
	    if( f > 5 )
		f = 5;
	    if( f < 0.1 )
		f = 0.1;
	    ret["opt_reserved_blocks"] = $[ "option_str" : "-m",
					    "option_value" : tostring( f, 1 ) ];
	}
    }
    y2milestone( "DefaultFormatOptions fsys %1 fmt %2 is %3", fsys, 
                 part["format"]:false, ret );
    return ret;
}

global define boolean HasFstabOption( map part, string opt, boolean prefix )
    {
    list<string> l = splitstring( part["fstopt"]:"", "," );
    if( prefix )
	l = filter( string s, l, ``(search(s,opt)==0));
    else
	l = filter( string s, l, ``(s==opt));
    y2milestone( "HasFstabOption fst:%1 opt:%2 prefix:%3 l:%4 ret:%5", 
                 part["fstopt"]:"", opt, prefix, l, size(l)>0 );
    return( size(l)>0 );
    }

global define map CheckFstabOptions( string option_list )
    ``{
    boolean found = false;
    integer index = 0;
    y2milestone( "CheckFstabOptions option_list=%1", option_list );
    list<string> olist = splitstring( option_list, "," );
    list<string> known = [];
    list<string> unknown = [];
    foreach( string o, olist,
	``{
	if( contains( FstabOptionStrings, o ) )
	    {
	    known = add( known, o );
	    }
	else 
	    {
	    found = false;
	    index = 0;
	    while( !found && index<size(FstabOptionRegex) )
		{
		found = regexpmatch( o, FstabOptionRegex[index]:"" );
		index = index + 1;
		}
	    if( found )
		{
		known = add( known, o );
		}
	    else
		{
		unknown = add( unknown, o );
		}
	    }
	});
    map ret = $[  "all_known" : size(unknown)==0, 
                  "known_options" : mergestring( known, "," ),
                  "unknown_options" : mergestring( unknown, "," ) ];
    y2milestone( "CheckFstabOptions ret=%1", ret );
    return( ret );
    }


    global map GetFstabDefaultMap(string key)
    {
	return FstabDefaultMap[key]:$[];
    }

    global list<string> GetFstabDefaultList(string key)
    {
	map m = GetFstabDefaultMap(key);
	return [ m["spec"]:"", m["mount"]:"", m["vfstype"]:"", m["mntops"]:"",
		 tostring(m["freq"]:0), tostring(m["passno"]:0) ];
    }


    global boolean CanMountRo(map part)
    {
	const list<symbol> no_fs = [ `tmpfs, `swap ];
	return !contains(no_fs, part["used_fs"]:`unknown);
    }

    global boolean CanDoQuota(map part)
    {
	const list<symbol> quota_fs = [ `ext2, `ext3, `ext4, `btrfs, `reiser, `xfs ];
	return contains(quota_fs, part["used_fs"]:`unknown);
    }

    global boolean HasQuota(map part)
    {
	list<string> opts = splitstring(part["fstopt"]:"", ",");
	return find(string opt, opts, {
	    return opt == "usrquota" || opt == "grpquota" || search(opt, "usrjquota=") == 0 ||
		search(opt, "grpjquota=") == 0;
	}) != nil;
    }

    global string RemoveQuotaOpts(string fst_opts)
    {
	list<string> opts = splitstring(fst_opts, ",");
	opts = filter(string opt, opts, {
	    return opt != "usrquota" && opt != "grpquota" && search(opt, "usrjquota=") != 0 &&
		search(opt, "grpjquota=") != 0 && search(opt, "jqfmt=") != 0;
	});
	return mergestring(opts, ",");
    }

    global string AddQuotaOpts(map part, string fst_opts)
    {
	const list<symbol> journal = [ `ext3, `ext4, `btrfs, `reiser ];
	string ret = RemoveQuotaOpts(fst_opts);
	if (contains(journal, part["used_fs"]:`unknown))
	    ret = ret + ",usrjquota=aquota.user,grpjquota=aquota.group,jqfmt=vfsv0";
	else
	    ret = ret + ",usrquota,grpquota";
	return ret;
    }

}
