/**
 * Module:		proposal_partitions.ycp
 *
 * $Id$
 *
 * Author:		Klaus Kaempf <kkaempf@suse.de>
 *
 * Purpose:		Proposal function dispatcher - partitions.
 *
 *			See also file proposal-API.txt for details.
 */
{
    textdomain "storage";

    import "Arch";
    import "Wizard";
    import "Mode";
    import "Sequencer";
    import "Storage";
    import "StorageProposal";


    string func  = (string) WFM::Args(0);
    map    param = (map) WFM::Args(1);
    map    ret   = $[];

    y2milestone( "func:%1 param:%2", func, param );


    // check if /home partition keeps unformatted in order to warn for
    // possible incorrectly set file ownership (fate #306325)
    boolean unformatted_home_warning()
    {
	map part = Storage::GetEntryForMountpoint("/home");
	if (!isempty(part) && !part["format"]:false)
	{
	    y2milestone("/home partition will not be formatted");

	    import "UsersSimple";
	    if (UsersSimple::AfterAuth() != "users")
	    {
		y2milestone("non-local user authentication");
		return true;
	    }

	    string device = part["device"]:"";
	    map<symbol, any> resize_info = $[];
	    map<symbol, any> content_info = $[];
	    if (Storage::GetFreeInfo(device, false, resize_info, true, content_info, true) &&
		content_info[`homes]:0 > 1)
	    {
		y2milestone("multiple home directories");
		return true;
	    }
	}

	return false;
    }


    if( func == "MakeProposal" && Mode::autoinst() )
	{
	ret["preformatted_proposal"] = Storage::ChangeText();
	}
    else if( func == "MakeProposal" )
	{
	boolean force_reset      = param["force_reset"     ]:false;
	boolean language_changed = param["language_changed"]:false;

	y2milestone( "force_reset:%1 lang_changed:%2",
	             force_reset, language_changed );
	if( force_reset || Storage::GetPartProposalFirst() )
	    {
	    if( !Storage::GetPartProposalFirst() )
		{
		Storage::ResetOndiskTarget();
		Storage::AddMountPointsForWin(Storage::GetTargetMap());
		}
	    map prop = $[];
	    prop = StorageProposal::get_inst_prop( Storage::GetTargetMap());
	    y2milestone( "prop ok:%1", prop["ok"]:false );
	    if( prop["ok"]:false )
		{
		Storage::SetTargetMap( prop["target"]:$[] );
		Storage::SetPartProposalMode( "accept" );
		y2milestone( "PROPOSAL: %1", Storage::ChangeText());
		}
	    else
		{
		Storage::SetPartProposalMode( "impossible" );
		}
	    Storage::SetPartProposalFirst( false );
	    Storage::SetPartProposalActive( true );
	    y2milestone( "prop=%1", prop );
	    }

	if( Storage::GetPartProposalMode() != "impossible" ||
	    !Storage::GetPartProposalActive() )
	    {
	    ret["preformatted_proposal"] = Storage::ChangeText();

	    if (unformatted_home_warning())
	    {
		ret["warning"] = _("The /home partition will not be formatted. After installation,
ensure that ownerships of home directories are set properly.");
		ret["warning_level"] = `warning;
	    }
	    }
	else
	    {
	    ret["raw_proposal"] = [];
	    // popup text
	    ret["warning"] = _("No automatic proposal possible.
Specify mount points manually in the 'Partitioner' dialog.");
	    ret["warning_level"] = `blocker;
	    }
	Storage::HandleProposalPackages();
	}
    else if ( func == "AskUser" )
	{
	boolean has_next = param["has_next"]:false;

	// call some function that displays a user dialog
	// or a sequence of dialogs here:
	//
	// sequence = DummyMod::AskUser( has_next );

	map aliases =
	    $[ "disk" :
		    ``(WFM::CallFunction("inst_disk", [true, true])),
	       "target_sel" :
		    ``(WFM::CallFunction("inst_target_selection", [true, true])),
	       "target_part" :
		    ``(WFM::CallFunction("inst_target_part", [true, true])),
	       "resize_ui" :
		    ``(WFM::CallFunction("inst_resize_ui", [true, true]))
	     ];

	map seq = $[];

	if( Storage::GetPartProposalMode() != "impossible" )
	    {
	    Storage::SetPartProposalMode( "accept" );
	    }
	else
	    {
	    //Oops, no TargetMap, there are no disks
	    if( size(Storage::GetTargetMap()) == 0)
		//but we might still let user add nfs root
		//or mount iSCSI in expert partitioner (#421541)
		Storage::SetPartMode( "CUSTOM" );
	    else
	        Storage::SetPartMode( "USE_DISK" );
	    }

	seq["disk"] = $[ `abort : `abort, `cancel: `cancel, `next: `next ];

	if( Mode::autoinst() )
	    {
	    Storage::SetPartMode("PROP_MODIFY");
	    seq["ws_start"] = "disk";
	    }
	else
	    {
	    y2milestone( "ProposalActive %1 ProposalMode %2 PartMode %3",
	                 Storage::GetPartProposalActive(),
	                 Storage::GetPartProposalMode(),
			 Storage::GetPartMode() );
	    seq["target_sel"] = $[ `abort : `abort, `cancel: `cancel,
	                           `next : "target_part" ];
	    seq["target_part"] = $[ `abort : `abort, `cancel: `cancel,
	                           `next : "disk" ];
	    if( Arch::i386 () )
		{
		seq["resize_ui"] = $[ `abort : `abort, `cancel: `cancel,
		                      `next : "disk" ];
		seq["target_part",`next] = "resize_ui";
		}
	    seq["disk"] = $[ `abort : `abort, `cancel: `cancel, `next : `next ];
	    if( Storage::GetPartProposalMode() != "impossible" &&
	        Storage::GetPartProposalActive() )
		{
		seq["ws_start"] = "target_sel";
		}
	    else if( Storage::GetPartMode()=="USE_DISK" )
		{
		seq["ws_start"] = "target_sel";
		}
	    else
		{
		seq["ws_start"] = "disk";
		}
	    }
	y2milestone( "proposal sequence %1", seq );

	Wizard::OpenNextBackDialog();
	symbol result = Sequencer::Run(aliases, seq);
	Wizard::CloseDialog();

	y2milestone( "AskUser Mode:%1 ProActive:%2", Storage::GetPartMode(),
	             Storage::GetPartProposalActive() );

	// Fill return map
	Storage::HandleProposalPackages();
	ret = $[ "workflow_sequence" : result ];
	}
    else if ( func == "Description" )
	{
	// Fill return map.
	//
	// Static values do just nicely here, no need to call a function.

	ret =
	    $[
	      // label text
	      "rich_text_title"	:	_("Partitioning"),
	      // label text
	      "menu_title"	:	_("&Partitioning"),
	      "id"		:	"partitions_stuff"
	    ];
    }

    return ret;
}
