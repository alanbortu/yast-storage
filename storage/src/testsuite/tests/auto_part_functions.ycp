{
    integer arg_count = size(WFM::Args());

    if (arg_count < 1) {
	return "Bad WFM::Args";
    }

    string testdata = WFM::Args(0);

    y2milestone ("reading '%1'", testdata);

    //=====================================================
    // read test data

    map testmap = Read (testdata);

    if (size (testmap) <= 0) {
	return "Bad testmap";
    }

    //=====================================================
    // init globals from test data

    integer bytes_per_unit = lookup (testmap, "bytes_per_unit", 512);
    symbol partition_type  = lookup (testmap, "partition_type", `FAT);
    boolean arch_i386	   = lookup (testmap, "arch_i386", false);
    boolean arch_ppc	   = lookup (testmap, "arch_ppc", false);
    boolean arch_sparc32   = lookup (testmap, "arch_sparc32", false);
    boolean arch_sparc64   = lookup (testmap, "arch_sparc64", false);
    boolean arch_alpha	   = lookup (testmap, "arch_alpha", false);
    boolean arch_s390	   = lookup (testmap, "arch_s390", false);
    string target_is	   = lookup (testmap, "target_is", "");
    map targetMap	   = lookup (testmap, "targetmap", $[]);

    map target		= lookup (targetMap, target_is, $[]);
    boolean arch_sparc	= (arch_sparc32 || arch_sparc64);

    integer first_logical_nr = 5;

    //=====================================================
    // check test data consistency

    if (!(arch_i386||arch_ppc||arch_sparc||arch_alpha||arch_s390)) {
	return "No arch";
    }

    if (target_is == "") {
	return "bad target";
    }

    if (size (targetMap) <= 0) {
	return "bad targetMap";
    }


    include "./../../partitioning/include/auto_part_functions.ycp";

    integer max_partitions = compute_max_partitions (target, partition_type);
    integer cyl_count = lookup (target, "cyl_count", 0);
    integer bytes = cyl_count * lookup (target, "cyl_size", 0);
    integer units = bytes / bytes_per_unit;

    if (bytes <= 0) {
	return "Bad cyl values in target";
    }

    list full_region = [0, cyl_count];
    list partitions = lookup (target, "partitions", []);

    if (size_of_region (full_region) != cyl_count * bytes_per_unit) {
	y2error ("size_of_region(%1)->%2 != %3", full_region, size_of_region (full_region), cyl_count * bytes_per_unit);
	return "Bad size_of_region";
    }

    if (size_to_units (bytes) != units) {
	return "Bad size_to_units";
    }

    if (start_of_region (full_region) != 0) {
	return "Bad start_of_region";
    }

    if (end_of_region (full_region) != cyl_count) {
	return "Bad end_of_region";
    }

  any r5  = num_primary (partitions);
  any r7  = contains_extended (partitions);
  any r8  = extended_region (partitions);
  any r10 = can_create_logical (partitions);
  any r11 = bootable (full_region);
  any r12 = can_resize (partitions);
  any r13 = renumber_logical_partitions (partitions);
  any r14 = unused_extended_region (partitions);
  any r15 = unused_logical_region (partitions);

  return ([ r5, r7, r8,
	   r10,r11,r12,r13,r14,r15]);
}
