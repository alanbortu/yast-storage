#
# run a tests file
#
proc data-run { file data } {

  set path [split $file "/"]
  set filename [lindex $path [expr [llength $path]-1]]
  set path [split $data "/"]
  set dataname [lindex $path [expr [llength $path]-1]]

  # extract basename and check extension

  set fsplit [split $filename "."]
  set dsplit [split $dataname "."]

  set filebase [lindex $fsplit 0]
  set database [lindex $dsplit 0]

  # setup filenames

  # $src is the name of the original testfile with absolute path
  # tests/$filename is the name of the original testfile with relative path,
  #                 relative to the testsuite directory 
  set file_input  "tests/$filename"
  set data_input  "data/$dataname"

  set stdout_name "tests/$filebase.$database.out"
  set stderr_name "tests/$filebase.$database.err"
  set log_name    "tests/$filebase.$database.log"
  set tmpout_name "tmp.out.$filebase.$database"
  set tmperr_name "tmp.err.$filebase.$database"
  set tmplog_name "tmp.log.$filebase.$database"

  puts "Running $filebase.$database..."

  # run the test

  set result ""
  set oops [catch { set result [exec "tests/runtest.sh" "$file_input" "(\"$data_input\")" "$tmpout_name" "$tmperr_name" ] } catched]

  if {$oops != 0} {
    fail "test case failed for $filebase.$database: $catched"
    return
  }

  # check return code from runycp

  if {$result != ""} {
    warning "Compilation of $filebase.$database results in '$result'"
    return
  }

  # check stdout

  if {[diff $stdout_name "tmp.out.$filebase.$database"] != 1} {
    fail "Wrong stdout for $filebase.$database"
    return
  }

  # check stderr

  if {[diff $stderr_name "tmp.err.$filebase.$database"] != 1} {
    fail "Wrong stderr for $filebase.$database"
    return
  }

  # ok, all is fine

  pass $filebase.$database

  return
}

proc tests-run { srcdir file } {

set datanames [glob $srcdir/data/*.ycp]

# foreach datafile, call data-run

foreach data $datanames { data-run $file $data }

return

}

proc part-run { src } {

  set path [split $src "/"]
  set filename [lindex $path [expr [llength $path]-1]]

  # extract basename and check extension

  set fname [split $filename "."]

  if {[llength $fname] < 2} {
    fail "Bad filename syntax '$src'"
    return
  }

# if {[lindex $fname [expr [llength $fname]-1]] != "solver"} {
#    set a "1"
#    puts "---- Now I will run pkginfo-server tests ----"
#  }
# if {[lindex $fname [expr [llength $fname]-1]] == "solver"} {
#    set a "1"
#   puts "---- First I will run test on solv commandline tool ---"  
# }

  # setup filenames

  set base_name [lindex $fname 0]

  set stdout_name "tests_propose/$base_name.out"
  set stderr_name "tests_propose/$base_name.err"
  set log_name    "tests_propose/$base_name.log"
  set tmpout_name "tmp.out.$base_name"
  set tmperr_name "tmp.err.$base_name"
  set tmplog_name "tmp.log.$base_name"

  puts "Running $base_name..."

  # run the test

  set result ""
#  set oops [catch { set result [exec "tests/runtest+log.sh" "$src" "$tmpout_name" "$tmperr_name" "$tmplog_name" ] } catched]
#  warning "-------$src---$tmpout_name---$tmperr_name"
   set oops [catch { set result [exec "tests_propose/runtest_part.sh" "$src" "$tmpout_name" "$tmperr_name" ] } catched]

  if {$oops != 0} {
    fail "test case failed for $base_name: $catched"
    return
  }

  # check return code from y2solver

  if {$result != ""} {
    warning "Compilation of $base_name results in '$result'"
    return
  }

  # check stdout

  if {[diff $stdout_name "tmp.out.$base_name"] != 1} {
    fail "Wrong stdout for $base_name"
    return
  }

  # check stderr

  if {[diff $stderr_name "tmp.err.$base_name"] != 1} {
    fail "Wrong stderr for $base_name"
    return
  }

  # check log file

#  if {[file size "tmp.log.$base_name"] == 0 } {
  #   warning "Logging file has empty size for $base_name"
#      exec "rm" "-f" "tmp.log.$base_name"
#  } elseif {[diff $log_name "tmp.log.$base_name"] != 1} {
#    fail "Wrong logging entries for $base_name"
#    return
#  }

  # ok, all is fine

  pass $base_name

  return
}
