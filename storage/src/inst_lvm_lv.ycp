/**
 * File:
 *   lvm_lv.ycp
 *
 * Module:
 *
 * Summary:
 * main for lvm-configs logical volume management
 *
 * Authors:
 *   mike <mike@suse.de>
 *
 * $Id$
 *
 *
 *----------------------------------------------------
 * IMPORTANT: when you read this code notice:
 *
 * vg  = volume group
 * vgs = volume groups
 *
 * pv  = physical volume
 * pvs = physical volumes
 *
 * lv  = logical volume
 * lvs = logical volumes
 *----------------------------------------------------
 *
 */

{



    textdomain "storage";

    import "Mode";
    import "Storage";
    import "Wizard";
    import "FileSystems";

    include "partitioning/lvm_ui_lib.ycp";
    include "partitioning/lvm_lib.ycp";
    include "partitioning/lvm_lv_lib.ycp";
    include "partitioning/lvm_ui_dialogs.ycp";



    string  current_vg       = "none";

    boolean test_mode        = Mode::test;
    map     targetMap        = Storage::GetTargetMap();
    map     modify_targets   = Storage::GetModifyTargets();
    boolean view_all_mnts    = Storage::GetLvmViewAllMnt();

    ////////////////////////////////////////////////
    // Testmode, should be commented in release
    // test_mode   = true;
    // test_mode   = false;
    ////////////////////////////////////////////////


    // supported filesystems -> inst_disk.ycp > global


    list    lvm_vgs  = get_vgs(  targetMap );
    list    parts	 = get_lvs_and_mounted_partitions( targetMap, view_all_mnts, current_vg );
    list    table	 = get_lv_widget_table( parts );

    y2debug( "table: %1", table );



    Wizard::SetContents( _("Logical Volume Manager -- Logical Volumes"),
			     get_lv_content( table, lvm_vgs, "-------", view_all_mnts),
			     "", true, true);
    Wizard::ReplaceHelp(`RichText(`id(`help), getLvHelptext() ));



    //////////////////////////////////////////////////////////////////////
    // First we typically have to create a volumegroup
    // check if there is already a lvm group
    //////////////////////////////////////////////////////////////////////

    // Display current vg:
    current_vg = select( lvm_vgs, 0, "" );
    UI::new_vg_list( lvm_vgs );
    UI::ChangeWidget( `id(`vg), `Value, current_vg);


    any vg = nil;


    //////////////////////////////////////////////////////////////////////
    // mainloop
    //////////////////////////////////////////////////////////////////////

    any     id          =  "";
    symbol  ret         = `next;
    integer max_size    = 0;
    integer used_size   = 0;
    list    size_list   = [];
    string  vg_size_str = "";

    repeat
    {

	/////////////////////////////////////////////////////////////////
	// Show the current state:

    parts	 = get_lvs_and_mounted_partitions( targetMap, view_all_mnts, current_vg );
	table	 = get_lv_widget_table( parts );
	UI::ChangeWidget( `id(`lv_table), `Items, table);

	parts	    = get_lvs_and_mounted_partitions(  targetMap, false, current_vg );
	y2debug( "parts=%1 current_vg=%2", parts, current_vg );
	size_list   = get_lv_size_info( targetMap,  parts, current_vg );
	max_size    = select( size_list, 1, 0 );
	used_size   = select( size_list, 0, 0 );
	y2debug( "list=%3, max_size=%1 used_size=%2", max_size, used_size, size_list );
	vg_size_str = ByteToHumanStringWithZero( max_size );


	if ( UI::HasSpecialWidget( `BarGraph ))
	{
	   UI::ChangeWidget( `id(`vg_size), `Labels,
			     [
			      sformat( "used\n%1", ByteToHumanStringWithZero(used_size)),
			      sformat( "free\n%1", ByteToHumanStringWithZero(max_size))
			     ] );
	   UI::ChangeWidget( `id(`vg_size), `Values, [ used_size / 1048576, max_size / 1048576 ] );
	}
	else
	{
	   UI::ChangeWidget( `id(`vg_size), `Value, vg_size_str);
	}


	if ( id != "" && id != nil )
	{
	    UI::ChangeWidget( `id(`lv_table), `CurrentItem, id);
	}


        /////////////////////////////////////////////////////////////////
        // Wait for User input
	ret= Wizard::UserInput();
	y2milestone(" ret %1", ret );


	////////////////////////////////////////
	// user has changed the current volume group
	////////////////////////////////////////

	if ( ret == `vg )
	{
	    current_vg = UI::QueryWidget( `id(`vg), `Value);
	}



	////////////////////////////////////////
	// Add a new logical volume:
	////////////////////////////////////////


	if ( ret == `viewmnt )
	{
	    view_all_mnts = UI::QueryWidget(`id(`viewmnt), `Value);
	}


	////////////////////////////////////////
	// Add a new logical volume:
	////////////////////////////////////////


	if ( ret == `lv_add )
	{
	    map Lv = $[
		       "create"		:	true,
		       "mount"		:	"",
		       "used_fs"	:	`reiser,
		       "crypt_fs"	:	false,
		       "size"		:       max_size /4 ,
		       "subdev"		:       "",
		       "stripes"	:	1,
		       "fs_options"	:	$[],
		       "format"		:	true,
		       "fsid"		:	Partitions::fsid_lvm,
		       "mount"		:       GetMountPointProposal(targetMap , ["/", "swap", "/boot" ] )
	    ];

	    map createLv = DlgCreateEditLogicaVolume( "create",
						      Lv,
						      max_size,
						      current_vg,
						      get_lv_names(targetMap,current_vg),
						      FileSystems::GetAllFileSystems(false,true),
						      installation,
						      ""
						      );


	    /*
	      notUsedMountpoints(targetMap, []),
					   UI::FileSystemsComboBox( $[ "used_fs"   : `reiser ,
								       "crypt_fs"  :  false  ] , file_systems ),

					   //possibleFilesystems( false, reiserfs_support, xfs_support, jfs_support, `reiser),
					   ByteToHumanStringWithZero(max_size/4),
					   "",
					   1,
							  //`reiser,
					   false,
	    */


	    // has an error occured
	    if ( size(createLv)>0 )
	    {
		map ret = addLogicalVolume( createLv, modify_targets, targetMap, current_vg );

		targetMap      = lookup( ret, "targets",        targetMap );
		modify_targets = lookup( ret, "modify_targets", modify_targets );
	    }
	}

	////////////////////////////////////////
	// Edit/Resize a new logical volume:
	////////////////////////////////////////


	if ( ret == `lv_edit || ret == `lv_table )
	{
	    id = UI::QueryWidget(`id(`lv_table), `CurrentItem);
	    y2milestone("id %1", id);

	    if ( id == nil )
	    {
		// Popup text
		UI::ErrorPopup(_("No device selected.
Select the device to edit.
"));

	    }
	    else
	    {
		map Lv = GetLvData(id, modify_targets, targetMap);

		// if Lv is a lvm partition
		if( Lv != nil )
		{
		    string maindev = Storage::GetMainDevKey( id);
		    string subdev  = Storage::GetSubDevIndex( id );

		    string tmp_vg = lookup( Lv, "vgname", "none");
		    size_list   = get_lv_size_info( targetMap,
		                                get_lvs_and_mounted_partitions(  targetMap, false, tmp_vg ), tmp_vg );
		    max_size    = select( size_list, 1, 0 );
		    used_size   = select( size_list, 0, 0 );

		    y2debug("Lv: %1", Lv);

		    if ( !lookup(Lv, "error", false) )
		    {
			if ( Lv["created"]:false )
			{


			      map createLv = DlgCreateEditLogicaVolume(
								       "edit",
								       Lv,
								       max_size+lookup(Lv, "size", 0),
								       tmp_vg,
								       [],
								       FileSystems::GetAllFileSystems(false, true),
								       installation,
								       Storage::GetDeviceName( maindev, subdev )
								     );


			    // has an error occured
			    if ( size(createLv)>0 )
			    {
				map ret = editLogicalVolume( createLv,
							     modify_targets,
							     targetMap,
							     lookup( Lv, "vgname", "none"),
							     lookup( Lv, "modify_targets_index", 0));

				targetMap      = lookup( ret, "targets",        targetMap );
				modify_targets = lookup( ret, "modify_targets", modify_targets );
			    }
			}
			else
			{
			    map createLv = DlgCreateEditLogicaVolume(
								     "resize",
								     Lv,
								     max_size +lookup(Lv, "size", 0),
								     tmp_vg,
								     [],
								     FileSystems::GetAllFileSystems(false, true),
								     installation,
								     Storage::GetDeviceName( maindev, subdev )
								     );



			    // has an error occured
			    if ( size(createLv)>0 )
			    {
				map ret = resizeLogicalVolume( createLv,
							       modify_targets,
							       targetMap,
							       lookup( Lv, "vgname", "none"));

				targetMap      = lookup( ret, "targets",        targetMap );
				modify_targets = lookup( ret, "modify_targets", modify_targets );
			    }
			}
		    }
		}
	    }
	}

	////////////////////////////////////////
	// Delete a new logical volume:
	////////////////////////////////////////

	// search for old create and delte this entry !!!
	y2debug("ret: %1", ret);

	if ( ret == `lv_delete )
	{
	    id = UI::QueryWidget(`id(`lv_table), `CurrentItem);

	    if ( id == nil )
	    {
		// Popup text
		UI::ErrorPopup(_("No device selected.
Select the device to remove.
"));

	    }
	    else
	    {
		string maindev = Storage::GetMainDevKey( id);
		string subdev  = Storage::GetSubDevIndex( id );
		map Lv         = GetLvData(id, modify_targets, targetMap);

		if( Lv == nil )
		{
		    // Popup
		    UI::ErrorPopup(_("You can only remove logical volumes."));
		    continue;
		}

		// Popup text
		string message = sformat( UI(_("Do you want to remove
the logical volume %1/%2?")), maindev, subdev );

		boolean do_remove = UI::YesNoPopup( message );

		if ( do_remove )
		{
		    y2debug( "Lv:  %1", Lv);
		    y2debug( "modify_targets:  %1", modify_targets );
		    y2debug( "targetMap: %1", targetMap);
		    y2debug( "vgname:  %1", lookup( Lv, "vgname", "none") );
		    any deleteLV = removeLogicalVolume( Lv,
							modify_targets,
							targetMap,
							lookup( Lv, "vgname", "none") );

		    // has an error occured
		    if ( ! lookup(deleteLV, "error", false) )
		    {
			targetMap      = lookup( deleteLV, "targets", $[] );
			modify_targets = lookup( deleteLV, "modify_targets", $[] );
		    }
		}
	    }
	}


	////////////////////////////////////////
	// Finish this step
	////////////////////////////////////////

	if (ret == `next || ret == `back )
	{

	    SCR::Write(Storage::SaveDumpPath("modif"), modify_targets);
	    SCR::Write(Storage::SaveDumpPath("tmap"),  targetMap);
	    Storage::SetModifyTargets( modify_targets );
	    Storage::SetTargetMap( targetMap );
	    Storage::SetLvmViewAllMnt( view_all_mnts );
	}

    } until (ret == `next || ret == `back || ret == `cancel || ret == `abort );


    SCR::Write(Storage::SaveDumpPath("targetMap_l"),  targetMap);

    return ret;
}


// end
